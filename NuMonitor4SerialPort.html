<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NuMonitor for Serial Port</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #0d1117;
            --bg-tertiary: #161b22;
            --bg-elevated: #1c2128;
            --border-color: #30363d;
            --border-active: #58a6ff;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent-green: #39d353;
            --accent-green-dim: rgba(57, 211, 83, 0.15);
            --accent-blue: #58a6ff;
            --accent-blue-dim: rgba(88, 166, 255, 0.15);
            --accent-orange: #d29922;
            --accent-red: #f85149;
            --accent-purple: #a371f7;
            --terminal-green: #00ff9f;
            --terminal-amber: #ffb000;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 20px;
        }

        .logo-area {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo-text {
            font-family: 'Rubik', sans-serif;
            font-weight: 700;
            font-size: 16px;
            letter-spacing: -0.3px;
            color: white;
            white-space: nowrap;
            min-width: 220px;
        }

        .logo-icon-link,
        .logo-text-link {
            text-decoration: none;
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
        }

        .logo-icon-link:hover .logo-icon svg {
            fill: #a8e6e1;
            transform: scale(1.1);
        }

        .logo-icon-link .logo-icon svg {
            transition: all 0.2s ease;
        }

        .logo-text-link:hover .logo-text {
            color: #a8e6e1;
            transform: scale(1.05);
        }

        .logo-text-link .logo-text {
            transition: all 0.2s ease;
            display: inline-block;
        }

        .nu-color {
            color: #81D8D0;
        }

        .changelog-link {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .changelog-link:hover {
            background: var(--bg-elevated);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .changelog-link svg {
            width: 12px;
            height: 12px;
        }

        /* Connection Panel */
        .connection-panel {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .select-wrapper {
            position: relative;
        }

        .select-wrapper::after {
            content: 'â–¾';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            pointer-events: none;
            font-size: 10px;
        }

        select {
            appearance: none;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 32px 8px 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        select:hover {
            border-color: var(--text-secondary);
        }

        select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-dim);
        }

        select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-icon {
            padding: 8px;
            min-width: 36px;
            justify-content: center;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--bg-elevated);
            border-color: var(--text-secondary);
        }

        .btn-connect {
            background: var(--accent-green);
            color: var(--bg-primary);
        }

        .btn-connect:hover:not(:disabled) {
            background: #45e35f;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(57, 211, 83, 0.3);
        }

        .btn-disconnect {
            background: var(--accent-red);
            color: white;
        }

        .btn-disconnect:hover:not(:disabled) {
            background: #ff6b63;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(248, 81, 73, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            transition: all 0.3s ease;
        }

        .status-dot.connected {
            background: var(--accent-green);
            box-shadow: 0 0 8px var(--accent-green);
            animation: pulse 2s infinite;
        }

        .status-dot.reconnecting {
            background: var(--accent-orange);
            box-shadow: 0 0 8px var(--accent-orange);
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Auto Connect Toggle */
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .toggle-switch:hover {
            border-color: var(--text-secondary);
        }

        .toggle-switch input {
            display: none;
        }

        .toggle-slider {
            width: 36px;
            height: 20px;
            background: var(--bg-primary);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s ease;
        }

        .toggle-slider::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--text-secondary);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--accent-green-dim);
        }

        .toggle-switch input:checked + .toggle-slider::after {
            transform: translateX(16px);
            background: var(--accent-green);
        }

        .toggle-label {
            font-size: 12px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        /* Mini Toggle Switch for Terminal Controls */
        .toggle-switch-mini {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .toggle-switch-mini:hover {
            border-color: var(--text-secondary);
        }

        .toggle-switch-mini input {
            display: none;
        }

        .toggle-slider-mini {
            width: 28px;
            height: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
            position: relative;
            transition: all 0.3s ease;
        }

        .toggle-slider-mini::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--text-secondary);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
        }

        .toggle-switch-mini input:checked + .toggle-slider-mini {
            background: var(--accent-green-dim);
        }

        .toggle-switch-mini input:checked + .toggle-slider-mini::after {
            transform: translateX(12px);
            background: var(--accent-green);
        }

        .toggle-label-mini {
            font-size: 14px;
            line-height: 1;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 16px 20px;
            min-height: 0;
            overflow: hidden;
        }

        /* Terminal */
        .terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            min-height: 0;
            overflow: hidden;
        }

        .terminal-header {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .terminal-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .terminal-title svg {
            width: 16px;
            height: 16px;
        }

        .terminal-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .terminal-btn {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .terminal-btn:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .terminal-btn.active {
            background: var(--accent-blue-dim);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .terminal-btn svg {
            width: 16px;
            height: 16px;
        }

        .ctrl-separator {
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 4px;
        }

        /* Terminal Output */
        .terminal-output {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            overflow-x: hidden;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            min-height: 0;
            background: 
                radial-gradient(ellipse at top, rgba(57, 211, 83, 0.03) 0%, transparent 50%),
                var(--bg-secondary);
        }

        .terminal-output::-webkit-scrollbar {
            width: 10px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 5px;
            border: 2px solid var(--bg-tertiary);
        }

        .terminal-output::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .terminal-line {
            display: flex;
            gap: 12px;
            padding: 2px 0;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(4px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .terminal-line .timestamp {
            color: var(--text-muted);
            font-size: 11px;
            white-space: nowrap;
        }

        .terminal-line .content {
            color: var(--terminal-green);
            word-break: break-all;
        }

        .terminal-line .content a.terminal-link {
            color: var(--accent-blue);
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .terminal-line .content a.terminal-link:hover {
            color: var(--accent-cyan);
            text-decoration-style: solid;
        }

        .terminal-line .content a.terminal-link::before {
            content: 'ğŸ”—';
            font-size: 10px;
            margin-right: 2px;
        }

        .terminal-line.sent .content {
            color: var(--accent-blue);
        }

        .terminal-line.sent::before {
            content: 'â†’';
            color: var(--accent-blue);
        }

        .terminal-line.received::before {
            content: 'â†';
            color: var(--accent-green);
        }

        .terminal-line.error .content {
            color: var(--accent-red);
        }

        .terminal-line.info .content {
            color: var(--accent-orange);
            
        }

        .terminal-line.warning .content {
            color: var(--accent-orange);
        }

        .terminal-line.system .content {
            color: var(--accent-purple);
            
        }

        /* Terminal Color Swatches */
        .terminal-colors {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: 8px;
            padding-right: 12px;
            border-right: 1px solid var(--border-color);
        }

        .terminal-color-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .terminal-color-item:hover {
            background: var(--bg-tertiary);
        }

        .terminal-color-swatch {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .terminal-color-item:hover .terminal-color-swatch {
            border-color: var(--text-secondary);
            transform: scale(1.1);
        }

        .terminal-color-label {
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Input Area */
        .input-area {
            flex-shrink: 0;
            display: flex;
            gap: 12px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        /* History Dropdown */
        .history-dropdown {
            position: relative;
        }

        .history-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .history-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .history-btn.has-history {
            color: var(--accent-blue);
        }

        .history-dropdown.open .history-btn {
            background: var(--bg-elevated);
            color: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .history-menu {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 0;
            min-width: 300px;
            max-width: 500px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(8px);
            transition: all 0.15s ease;
            z-index: 300;
        }

        .history-dropdown.open .history-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .history-header {
            padding: 10px 14px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-color);
        }

        .history-list {
            max-height: 280px;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse;
        }

        .history-empty {
            padding: 20px;
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
        }

        .history-item {
            padding: 10px 14px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s ease;
            border-top: 1px solid var(--border-color);
            word-break: break-all;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .history-item:first-child {
            border-top: none;
        }

        .history-item:hover {
            background: var(--bg-tertiary);
        }

        .history-item.selected {
            background: var(--accent-blue-dim);
            color: var(--accent-blue);
        }

        .history-item .history-index {
            display: inline-block;
            min-width: 24px;
            margin-right: 8px;
            color: var(--text-muted);
            font-size: 10px;
            flex-shrink: 0;
        }

        .history-item .history-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .history-item .history-send-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            background: var(--accent-blue);
            border: none;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s ease;
            opacity: 0.8;
        }

        .history-item .history-send-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(88, 166, 255, 0.4);
        }

        .history-item .history-send-btn svg {
            width: 14px;
            height: 14px;
            stroke: white;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .input-wrapper:focus-within {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-dim);
        }

        .input-wrapper input {
            flex: 1;
            padding: 12px 16px;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
        }

        .input-wrapper input::placeholder {
            color: var(--text-muted);
        }

        .input-wrapper input:focus {
            outline: none;
        }

        .input-wrapper input:disabled {
            cursor: not-allowed;
        }

        /* Custom Select for Line Ending */
        .custom-select {
            position: relative;
            user-select: none;
        }

        .custom-select-trigger {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 12px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .custom-select-trigger:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .custom-select.open .custom-select-trigger {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--accent-blue);
        }

        .custom-select-arrow {
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .custom-select.open .custom-select-arrow {
            transform: rotate(180deg);
        }

        .custom-select-options {
            position: absolute;
            bottom: calc(100% + 4px);
            left: 50%;
            transform: translateX(-50%);
            min-width: 140px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            opacity: 0;
            visibility: hidden;
            transition: all 0.15s ease;
            z-index: 100;
            overflow: hidden;
        }

        .custom-select.open .custom-select-options {
            opacity: 1;
            visibility: visible;
        }

        .custom-select-option {
            padding: 10px 16px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .custom-select-option:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .custom-select-option.selected {
            background: var(--accent-blue-dim);
            color: var(--accent-blue);
        }

        .custom-select-option.selected:hover {
            background: var(--accent-blue-dim);
        }

        /* Custom Port Select */
        .port-select-custom {
            position: relative;
            user-select: none;
            min-width: 320px;
        }

        .port-select-trigger {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 38px;
        }

        .port-select-trigger:hover {
            border-color: var(--text-secondary);
        }

        .port-select-trigger.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .port-select-custom.open .port-select-trigger {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-dim);
        }

        .port-select-trigger .port-icon {
            flex-shrink: 0;
            color: var(--text-muted);
        }

        .port-select-trigger .port-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .port-select-trigger .port-arrow {
            flex-shrink: 0;
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .port-select-custom.open .port-arrow {
            transform: rotate(180deg);
        }

        .port-select-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.15s ease;
            z-index: 200;
            max-height: 300px;
            overflow-y: auto;
        }

        .port-select-custom.open .port-select-dropdown {
            opacity: 1;
            visibility: visible;
        }

        .port-select-header {
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-color);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .port-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .port-option:hover {
            background: var(--bg-tertiary);
        }

        .port-option.selected {
            background: var(--accent-blue-dim);
            color: var(--accent-blue);
        }

        .port-option .port-icon {
            flex-shrink: 0;
            color: var(--text-muted);
        }

        .port-option.selected .port-icon {
            color: var(--accent-blue);
        }

        .port-option .port-icon.labeled {
            color: var(--accent-green);
        }

        .port-option .port-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .port-option .port-badge {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            color: var(--text-muted);
        }

        .port-select-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 12px;
        }

        .btn-send {
            background: var(--accent-blue);
            color: white;
            padding: 12px 24px;
        }

        .btn-send:hover:not(:disabled) {
            background: #6fb4ff;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.3);
        }

        .btn-send:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Stats Bar */
        .stats-bar {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-secondary);
        }

        .stats-group {
            display: flex;
            gap: 24px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-item .label {
            color: var(--text-muted);
        }

        .stat-item .value {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }

        .stat-item .value.rx {
            color: var(--accent-green);
        }

        .stat-item .value.tx {
            color: var(--accent-blue);
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            text-align: center;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .empty-state p {
            font-size: 13px;
            max-width: 300px;
        }

        /* Browser Support Warning */
        .browser-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 14, 20, 0.95);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
        }

        .browser-warning.show {
            display: flex;
        }

        .browser-warning svg {
            width: 80px;
            height: 80px;
            margin-bottom: 24px;
            color: var(--accent-orange);
        }

        .browser-warning h2 {
            font-size: 24px;
            margin-bottom: 16px;
        }

        .browser-warning p {
            color: var(--text-secondary);
            max-width: 500px;
            line-height: 1.6;
        }

        .browser-warning a {
            color: var(--accent-blue);
            text-decoration: none;
        }

        .browser-warning a:hover {
            text-decoration: underline;
        }

        
        /* Language Selector */
        .language-selector {
            position: relative;
            user-select: none;
            margin-left: auto;
        }

        .language-trigger {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 36px;
        }

        .language-trigger:hover {
            border-color: var(--text-secondary);
            background: var(--bg-elevated);
        }

        .language-selector.open .language-trigger {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-dim);
        }

        .language-flag {
            width: 20px;
            height: 15px;
            display: inline-block;
            object-fit: cover;
            border-radius: 2px;
            vertical-align: middle;
        }

        .language-text {
            white-space: nowrap;
        }

        .language-arrow {
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .language-selector.open .language-arrow {
            transform: rotate(180deg);
        }

        .language-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            right: 0;
            min-width: 180px;
            max-height: 400px;
            overflow-y: auto;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.2s ease;
            z-index: 1000;
            pointer-events: none;
        }

        .language-dropdown::-webkit-scrollbar {
            width: 6px;
        }

        .language-dropdown::-webkit-scrollbar-track {
            background: transparent;
        }

        .language-dropdown::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .language-dropdown::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        .language-selector.open .language-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            pointer-events: auto;
        }

        .language-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .language-option:first-child {
            border-radius: 6px 6px 0 0;
        }

        .language-option:last-child {
            border-radius: 0 0 6px 6px;
        }

        .language-option:hover {
            background: var(--bg-tertiary);
        }

        .language-option.active {
            background: var(--accent-blue-dim);
            color: var(--accent-blue);
        }

        .language-option.active .language-flag {
            filter: brightness(1.2);
        }


        /* Custom Tooltip (JavaScript controlled) */
        .custom-tooltip {
            position: fixed;
            padding: 8px 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            font-family: 'Space Grotesk', sans-serif;
            white-space: nowrap;
            color: var(--text-primary);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transform: translateY(4px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .custom-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .custom-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--border-color);
        }

        /* Separator */
        .separator {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 4px;
        }

        /* Error Tips */
        .error-tips {
            margin-top: 8px;
            padding: 12px 16px;
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid rgba(248, 81, 73, 0.3);
            border-radius: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .error-tips strong {
            color: var(--accent-red);
            display: block;
            margin-bottom: 8px;
        }

        .error-tips ul {
            margin: 0;
            padding-left: 20px;
        }

        .error-tips li {
            margin: 4px 0;
        }

        /* Label Editor Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            min-width: 400px;
            max-width: 90%;
        }

        .modal h3 {
            margin-bottom: 16px;
            font-size: 16px;
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            margin-bottom: 16px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-info {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 16px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .header {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .connection-panel {
                justify-content: flex-start;
                flex-wrap: wrap;
            }
        }

        @media (max-width: 768px) {
            .connection-panel {
                justify-content: center;
            }

            .input-area {
                flex-direction: column;
            }

            .stats-bar {
                flex-direction: column;
                gap: 8px;
            }

            .separator {
                display: none;
            }

            .port-select-custom {
                min-width: 200px;
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Tab System
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .tab-bar {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
            flex-shrink: 0;
        }

        .tab-bar::-webkit-scrollbar { height: 4px; }
        .tab-bar::-webkit-scrollbar-track { background: transparent; }
        .tab-bar::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }

        .tab-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tab-item:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .tab-item.active {
            background: #21262d;
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .tab-item .tab-icon { font-size: 14px; }

        .tab-item .tab-close {
            display: none;
            width: 14px;
            height: 14px;
            padding: 2px;
            margin-left: 4px;
            border-radius: 3px;
            opacity: 0.6;
            align-items: center;
            justify-content: center;
        }

        .tab-item:hover .tab-close { display: flex; }
        .tab-item .tab-close:hover { background: var(--accent-red); opacity: 1; }

        .tab-content {
            flex: 1;
            display: none;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }

        .tab-content.active { display: flex; }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Chart Container
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 16px;
            background: var(--bg-secondary);
        }

        .chart-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .chart-type-badge {
            padding: 3px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-left: 8px;
        }

        .chart-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .chart-btn.active {
            background: var(--accent-blue-dim);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .chart-btn svg { width: 14px; height: 14px; }

        .chart-area {
            flex: 1;
            position: relative;
            min-height: 200px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Chart Legend
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-top: 12px;
            flex-shrink: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: var(--bg-elevated);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .legend-item:hover { background: var(--bg-primary); }
        .legend-item.hidden { opacity: 0.4; }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .legend-color:hover { transform: scale(1.2); }

        .legend-label {
            font-size: 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }

        .legend-value {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Map Container
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .map-container {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-tertiary);
        }

        .map-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-top: 12px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            flex-shrink: 0;
        }

        .map-status svg {
            stroke: var(--accent-blue);
        }

        .map-points-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .map-points-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            background: var(--bg-elevated);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .map-points-btn:hover {
            background: var(--accent-blue);
            color: white;
        }

        .map-points-btn:active {
            transform: scale(0.95);
        }

        .map-points-value {
            min-width: 60px;
            text-align: center;
            color: var(--text-secondary);
        }

        .map-lock-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-elevated);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .map-lock-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .map-lock-btn.locked {
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .map-lock-btn.locked:hover {
            border-color: var(--accent-cyan);
        }

        .map-lock-btn svg {
            flex-shrink: 0;
        }

        /* Leaflet Tooltip æ¨£å¼è¦†è“‹ */
        .map-tooltip {
            background: rgba(10, 14, 20, 0.95) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: 6px !important;
            color: var(--text-primary) !important;
            padding: 6px 10px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
        }

        .map-tooltip::before {
            border-top-color: rgba(10, 14, 20, 0.95) !important;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           Color Picker Modal
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .color-picker-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .color-picker-modal.show { display: flex; }

        .color-picker {
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            min-width: 240px;
        }

        .color-picker-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }

        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s ease;
            border: 2px solid transparent;
        }

        .color-swatch:hover { transform: scale(1.15); }
        .color-swatch.selected { border-color: white; }
        .palette-separator {
            width: 100%;
            height: 1px;
            background: var(--border-color);
            margin: 8px 0;
            grid-column: 1 / -1;
        }

        .color-custom {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }

        .color-custom input {
            flex: 1;
            padding: 6px 10px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }

        .color-custom input:focus { outline: none; border-color: var(--accent-blue); }

        .color-picker-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 12px;
        }

        .terminal-btn.reload-btn:hover {
            border-color: var(--accent-orange);
            color: var(--accent-orange);
        }

    </style>
</head>
<body>

    <!-- Color Picker Modal -->
    <div class="color-picker-modal" id="colorPickerModal">
        <div class="color-picker">
            <div class="color-picker-title" id="colorPickerTitle" data-i18n="color.picker.title">é¸æ“‡é¡è‰²</div>
            <div class="color-palette" id="colorPalette"></div>
            <div class="color-custom">
                <input type="text" id="colorCustomInput" placeholder="#RRGGBB" maxlength="7">
                <button class="btn btn-secondary btn-icon" id="colorApplyBtn">âœ“</button>
            </div>
            <div class="color-picker-buttons">
                <button class="btn btn-secondary" id="colorResetBtn" data-i18n="terminal.color.reset" style="display: none;">é‡ç½®ç‚ºé è¨­</button>
                <button class="btn btn-secondary" id="colorCancelBtn" data-i18n="btn.cancel">å–æ¶ˆ</button>
                <button class="btn btn-connect" id="colorConfirmBtn" data-i18n="btn.confirm">ç¢ºå®š</button>
            </div>
        </div>
    </div>
    <!-- Browser Support Warning -->
    <div class="browser-warning" id="browserWarning">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
            <line x1="12" y1="9" x2="12" y2="13"/>
            <line x1="12" y1="17" x2="12.01" y2="17"/>
        </svg>
        <h2 data-i18n="browser.warning.title">ç€è¦½å™¨ä¸æ”¯æ´ Web Serial API</h2>
        <p>
            æ­¤æ‡‰ç”¨éœ€è¦ Web Serial API æ”¯æ´ã€‚è«‹ä½¿ç”¨ 
            <a href="https://www.google.com/chrome/" target="_blank">Google Chrome</a> æˆ– 
            <a href="https://www.microsoft.com/edge" target="_blank">Microsoft Edge</a> 
            (ç‰ˆæœ¬ 89 æˆ–æ›´é«˜) ä¾†ä½¿ç”¨æ­¤åŠŸèƒ½ã€‚
        </p>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="logo-area">
            <div class="logo">
                <a href="https://github.com/Nuxtack" target="_blank" class="logo-icon-link" title="Nuxtack GitHub">
                    <div class="logo-icon">
                        <svg width="28" height="28" viewBox="0 0 32373 33553" fill="#81D8D0">
                            <path d="M32306.51 13651.25l-11174.46 -5592.01 0 -7198.5c12113.32,6376.73 11174.53,3823.33 11174.46,12790.52z"/>
                            <path d="M16.96 19856.56l11174.46 5592.01 0 7198.5c-12113.32,-6376.73 -11174.53,-3823.33 -11174.46,-12790.52z"/>
                            <polygon points="16.96,9927.52 32373.56,26094.99 32373.56,33553.52 16.89,17370.21"/>
                            <polygon points="16.89,0 32373.5,16167.46 32373.5,23625.99 16.83,7442.68"/>
                        </svg>
                    </div>
                </a>
                <a href="https://github.com/Nuxtack-tw/NuMonitor4SerialPort" target="_blank" class="logo-text-link">
                    <div class="logo-text"><span class="nu-color">NuMonitor</span> for Serial Port</div>
                </a>
            </div>
            <a href="doc/manual.html" target="_blank" class="changelog-link" data-i18n-tip="manual.tip" data-tip="">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/>
                    <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/>
                </svg>
                <span data-i18n="manual.link">èªªæ˜æ›¸</span>
            </a>
            <a href="doc/changelog.html" target="_blank" class="changelog-link" data-i18n-tip="changelog.tip" data-tip="">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="16" y1="13" x2="8" y2="13"/>
                    <line x1="16" y1="17" x2="8" y2="17"/>
                    <polyline points="10 9 9 9 8 9"/>
                </svg>
                v2.0.0
            </a>
        </div>

        <div class="connection-panel">
            <!-- Select Port Button -->
            <button class="btn btn-secondary tooltip" id="addPortBtn" data-i18n-tip="btn.selectPort.tip" data-tip="">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M5 5C3 5 2 6.5 2 8.5v7C2 17.5 3 19 5 19h14c2 0 3-1.5 3-3.5v-7C22 6.5 21 5 19 5H5z" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linejoin="round"/>
                    <circle cx="5.5" cy="9.5" r="1.1"/><circle cx="9" cy="9.5" r="1.1"/><circle cx="12.5" cy="9.5" r="1.1"/><circle cx="16" cy="9.5" r="1.1"/><circle cx="19.5" cy="9.5" r="1.1"/>
                    <circle cx="7.25" cy="14.5" r="1.1"/><circle cx="10.75" cy="14.5" r="1.1"/><circle cx="14.25" cy="14.5" r="1.1"/><circle cx="17.75" cy="14.5" r="1.1"/>
                </svg>
                <span data-i18n="btn.selectPort">é¸æ“‡é€£æ¥åŸ </span>
            </button>

            <div class="separator"></div>

            <!-- Baud Rate -->
            <div class="select-wrapper tooltip" data-i18n-tip="baudRate.tip" data-tip="">
                <select id="baudRate">
                    <option value="300">300 baud</option>
                    <option value="1200">1200 baud</option>
                    <option value="2400">2400 baud</option>
                    <option value="4800">4800 baud</option>
                    <option value="9600">9600 baud</option>
                    <option value="19200">19200 baud</option>
                    <option value="38400">38400 baud</option>
                    <option value="57600">57600 baud</option>
                    <option value="74880">74880 baud</option>
                    <option value="115200" selected>115200 baud</option>
                    <option value="230400">230400 baud</option>
                    <option value="250000">250000 baud</option>
                    <option value="500000">500000 baud</option>
                    <option value="1000000">1000000 baud</option>
                    <option value="2000000">2000000 baud</option>
                </select>
            </div>

            <div class="separator"></div>

            <!-- Auto Reconnect Toggle -->
            <label class="toggle-switch tooltip" data-i18n-tip="autoReconnect.tip" data-tip="">
                <input type="checkbox" id="autoReconnectToggle" checked>
                <span class="toggle-slider"></span>
                <span class="toggle-label" data-i18n="autoReconnect.label">è‡ªå‹•é‡é€£</span>
            </label>

            <div class="separator"></div>

            <!-- Disconnect Button -->
            <button class="btn btn-disconnect tooltip" id="disconnectBtn" data-i18n-tip="btn.disconnect.tip" data-tip="" disabled>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/>
                    <line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
                <span data-i18n="btn.disconnect">æ–·é–‹</span>
            </button>

            <!-- Status -->
            <div class="status-indicator tooltip" data-i18n-tip="status.tip" data-tip="">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText" data-i18n="status.disconnected">æœªé€£æ¥</span>
            </div>
            
            <div class="separator"></div>

            <!-- Language Selector -->
            <div class="language-selector" id="languageSelector">
                <button class="language-trigger" id="languageTrigger">
                    <img class="language-flag" id="currentLanguageFlag" src="https://flagcdn.com/w20/tw.png" alt="TW" width="20">
                    <span class="language-text" id="currentLanguageText">ç¹é«”ä¸­æ–‡</span>
                    <span class="language-arrow">â–¾</span>
                </button>
                <div class="language-dropdown" id="languageDropdown">
                    <div class="language-option" data-lang="zh-TW">
                        <img class="language-flag" src="https://flagcdn.com/w20/tw.png" alt="TW" width="20">
                        <span>ç¹é«”ä¸­æ–‡</span>
                    </div>
                    <div class="language-option" data-lang="en-US">
                        <img class="language-flag" src="https://flagcdn.com/w20/us.png" alt="US" width="20">
                        <span>English</span>
                    </div>
                    <div class="language-option" data-lang="ja-JP">
                        <img class="language-flag" src="https://flagcdn.com/w20/jp.png" alt="JP" width="20">
                        <span>æ—¥æœ¬èª</span>
                    </div>
                    <div class="language-option" data-lang="fr-FR">
                        <img class="language-flag" src="https://flagcdn.com/w20/fr.png" alt="FR" width="20">
                        <span>FranÃ§ais</span>
                    </div>
                    <div class="language-option" data-lang="de-DE">
                        <img class="language-flag" src="https://flagcdn.com/w20/de.png" alt="DE" width="20">
                        <span>Deutsch</span>
                    </div>
                    <div class="language-option" data-lang="it-IT">
                        <img class="language-flag" src="https://flagcdn.com/w20/it.png" alt="IT" width="20">
                        <span>Italiano</span>
                    </div>
                    <div class="language-option" data-lang="es-ES">
                        <img class="language-flag" src="https://flagcdn.com/w20/es.png" alt="ES" width="20">
                        <span>EspaÃ±ol</span>
                    </div>
                    <div class="language-option" data-lang="pt-PT">
                        <img class="language-flag" src="https://flagcdn.com/w20/pt.png" alt="PT" width="20">
                        <span>PortuguÃªs</span>
                    </div>
                    <div class="language-option" data-lang="tr-TR">
                        <img class="language-flag" src="https://flagcdn.com/w20/tr.png" alt="TR" width="20">
                        <span>TÃ¼rkÃ§e</span>
                    </div>
                    <div class="language-option" data-lang="ar-SA">
                        <img class="language-flag" src="https://flagcdn.com/w20/sa.png" alt="SA" width="20">
                        <span>Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</span>
                    </div>
                    <div class="language-option" data-lang="he-IL">
                        <img class="language-flag" src="https://flagcdn.com/w20/il.png" alt="IL" width="20">
                        <span>×¢×‘×¨×™×ª</span>
                    </div>
                    <div class="language-option" data-lang="fa-IR">
                        <img class="language-flag" src="https://flagcdn.com/w20/ir.png" alt="IR" width="20">
                        <span>ÙØ§Ø±Ø³ÛŒ</span>
                    </div>
                    <div class="language-option" data-lang="ru-RU">
                        <img class="language-flag" src="https://flagcdn.com/w20/ru.png" alt="RU" width="20">
                        <span>Ğ ÑƒÑÑĞºĞ¸Ğ¹</span>
                    </div>
                    <div class="language-option" data-lang="hi-IN">
                        <img class="language-flag" src="https://flagcdn.com/w20/in.png" alt="IN" width="20">
                        <span>à¤¹à¤¿à¤¨à¥à¤¦à¥€</span>
                    </div>
                    <div class="language-option" data-lang="vi-VN">
                        <img class="language-flag" src="https://flagcdn.com/w20/vn.png" alt="VN" width="20">
                        <span>Tiáº¿ng Viá»‡t</span>
                    </div>
                    <div class="language-option" data-lang="th-TH">
                        <img class="language-flag" src="https://flagcdn.com/w20/th.png" alt="TH" width="20">
                        <span>à¸ à¸²à¸©à¸²à¹„à¸—à¸¢</span>
                    </div>
                    <div class="language-option" data-lang="ms-MY">
                        <img class="language-flag" src="https://flagcdn.com/w20/my.png" alt="MY" width="20">
                        <span>Bahasa Melayu</span>
                    </div>
                    <div class="language-option" data-lang="id-ID">
                        <img class="language-flag" src="https://flagcdn.com/w20/id.png" alt="ID" width="20">
                        <span>Bahasa Indonesia</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <div class="terminal-container">

            <!-- Tab Bar -->
            <div class="tab-bar" id="tabBar">
                <div class="tab-item active" data-tab="terminal">
                    <span class="tab-icon">ğŸ“Ÿ</span>
                    <span data-i18n="tab.terminal">çµ‚ç«¯æ©Ÿ</span>
                </div>
            </div>

            <!-- Terminal Tab Content -->
            <div class="tab-content active" id="tabTerminal" data-tab="terminal">
            <div class="terminal-header">
                <div class="terminal-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="4 17 10 11 4 5"/>
                        <line x1="12" y1="19" x2="20" y2="19"/>
                    </svg>
                    <span data-i18n="terminal.output.title">çµ‚ç«¯è¼¸å‡º</span>
                </div>
                <div class="terminal-controls">
                    <div class="terminal-colors">
                        <div class="terminal-color-item" id="colorItemTx" data-type="tx" data-i18n-tip="terminal.color.tx.tip" data-tip="">
                            <div class="terminal-color-swatch" id="swatchTx" style="background: #ffffff;"></div>
                            <span class="terminal-color-label">TX</span>
                        </div>
                        <div class="terminal-color-item" id="colorItemRx" data-type="rx" data-i18n-tip="terminal.color.rx.tip" data-tip="">
                            <div class="terminal-color-swatch" id="swatchRx" style="background: #81D8D0;"></div>
                            <span class="terminal-color-label">RX</span>
                        </div>
                        <div class="terminal-color-item" id="colorItemSys" data-type="sys" data-i18n-tip="terminal.color.sys.tip" data-tip="">
                            <div class="terminal-color-swatch" id="swatchSys" style="background: #ffcc00;"></div>
                            <span class="terminal-color-label">SYS</span>
                        </div>
                    </div>
                    <button class="terminal-btn active" id="textModeBtn" data-i18n-tip="terminal.mode.text.tip" data-tip="">
                        <span style="font-size: 10px; font-weight: bold; font-family: 'JetBrains Mono', monospace;">TXT</span>
                    </button>
                    <button class="terminal-btn" id="hexModeBtn" data-i18n-tip="terminal.mode.hex.tip" data-tip="">
                        <span style="font-size: 10px; font-weight: bold; font-family: 'JetBrains Mono', monospace;">HEX</span>
                    </button>
                    
                    <div class="ctrl-separator"></div>
                    
                    <button class="terminal-btn active" id="echoBtn" data-i18n-tip="terminal.echo.tip" data-tip="">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="9 10 4 15 9 20"/>
                            <path d="M20 4v7a4 4 0 0 1-4 4H4"/>
                        </svg>
                    </button>
                    
                    <button class="terminal-btn" id="timestampBtn" data-i18n-tip="terminal.timestamp.tip" data-tip="">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <polyline points="12 6 12 12 16 14"/>
                        </svg>
                    </button>
                    
                    <button class="terminal-btn active" id="autoScrollBtn" data-i18n-tip="terminal.autoscroll.tip" data-tip="">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 5v14M19 12l-7 7-7-7"/>
                        </svg>
                    </button>
                    
                    <button class="terminal-btn" id="clearBtn" data-i18n-tip="terminal.clear.tip" data-tip="">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="3 6 5 6 21 6"/>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                    </button>
                    
                    <div class="ctrl-separator"></div>
                    
                    <button class="terminal-btn" id="clearAllChartsBtn" data-i18n-tip="plotter.clear.tip" data-tip="">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 3v18h18"/>
                            <path d="M18 9l-5 5-4-4-3 3"/>
                            <line x1="8" y1="4" x2="14" y2="10" stroke="#f85149"/>
                            <line x1="14" y1="4" x2="8" y2="10" stroke="#f85149"/>
                        </svg>
                    </button>
                    
                    <div class="ctrl-separator"></div>
                    
                    <label class="toggle-switch-mini tooltip" data-i18n-tip="plotter.toggle.tip" data-tip="">
                        <input type="checkbox" id="plotterToggle" checked>
                        <span class="toggle-slider-mini"></span>
                        <span class="toggle-label-mini">ğŸ“Š</span>
                    </label>
                </div>
            </div>

            <div class="terminal-output" id="terminalOutput">
                <div class="empty-state">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="4" width="16" height="16" rx="2"/>
                        <path d="M9 9h6M9 13h6M9 17h4"/>
                    </svg>
                    <h3 data-i18n="connection.waiting.title">ç­‰å¾…é€£æ¥</h3>
                    <p data-i18n="connection.waiting.message">é»æ“Šã€Œé¸æ“‡é€£æ¥åŸ ã€é¸æ“‡ä¸²åˆ—åŸ è£ç½®</p>
                </div>
            </div>

            </div>

            <div class="input-area">
                <div class="history-dropdown" id="historyDropdown">
                    <button class="history-btn" id="historyBtn" data-i18n-tip="input.history.tip" data-tip="">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <polyline points="12 6 12 12 16 14"/>
                        </svg>
                    </button>
                    <div class="history-menu" id="historyMenu">
                        <div class="history-header" data-i18n="input.history.title">æ­·å²è¨Šæ¯</div>
                        <div class="history-list" id="historyList">
                            <div class="history-empty" data-i18n="input.history.empty">å°šç„¡æ­·å²è¨Šæ¯</div>
                        </div>
                    </div>
                </div>
                <div class="input-wrapper">
                    <input type="text" id="inputField" data-i18n-placeholder="input.placeholder" placeholder="" disabled>
                </div>
                <div class="custom-select" id="lineEndingSelect" data-i18n-tip="input.lineending.tip" data-tip="">
                    <div class="custom-select-trigger">
                        <span class="custom-select-value">LF</span>
                        <span class="custom-select-arrow">â–¾</span>
                    </div>
                    <div class="custom-select-options">
                        <div class="custom-select-option" data-value="" data-i18n="input.lineending.none" data-i18n-tip="input.lineending.none.tip" data-tip="">None</div>
                        <div class="custom-select-option selected" data-value="\n" data-i18n="input.lineending.lf" data-i18n-tip="input.lineending.lf.tip" data-tip="">LF</div>
                        <div class="custom-select-option" data-value="\r" data-i18n="input.lineending.cr" data-i18n-tip="input.lineending.cr.tip" data-tip="">CR</div>
                        <div class="custom-select-option" data-value="\r\n" data-i18n="input.lineending.crlf" data-i18n-tip="input.lineending.crlf.tip" data-tip="">CRLF</div>
                    </div>
                </div>
                <button class="btn btn-send" id="sendBtn" data-i18n-tip="input.send.tip" data-tip="" disabled>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="22" y1="2" x2="11" y2="13"/>
                        <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                    </svg>
                    <span data-i18n="input.send">ç™¼é€</span>
                </button>
            </div>

            <div class="stats-bar">
                <div class="stats-group">
                    <div class="stat-item tooltip" data-i18n-tip="stats.rx.tip" data-tip="">
                        <span class="label">RX:</span>
                        <span class="value rx" id="rxCount">0</span>
                        <span class="label">bytes</span>
                    </div>
                    <div class="stat-item tooltip" data-i18n-tip="stats.tx.tip" data-tip="">
                        <span class="label">TX:</span>
                        <span class="value tx" id="txCount">0</span>
                        <span class="label">bytes</span>
                    </div>
                </div>
                <div class="stats-group">
                    <div class="stat-item tooltip" data-i18n-tip="stats.port.tip" data-tip="">
                        <span class="label">Port:</span>
                        <span class="value" id="portInfo">-</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Plotter Constants and Color Storage
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const CHART_COLORS = [
            // ä¸»è¦è‰²å½©
            '#81D8D0', '#ffcc00', '#58a6ff', '#f85149',
            '#a371f7', '#3fb950', '#ff7b72', '#79c0ff',
            '#ffa657', '#d2a8ff', '#7ee787', '#a5d6ff',
            '#ffc0cb', '#87ceeb', '#dda0dd', '#f0e68c',
            // æ“´å……è‰²å½©
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4',
            '#ffeaa7', '#dfe6e9', '#fd79a8', '#636e72',
            '#00b894', '#e17055', '#0984e3', '#6c5ce7',
            '#00cec9', '#fab1a0', '#74b9ff', '#a29bfe'
        ];
        
        // ç°éšæ¼¸è®Šï¼ˆç™½åˆ°é»‘ 8 æ ¼ï¼‰
        const GRAYSCALE_COLORS = [
            '#FFFFFF', '#DFDFDF', '#BFBFBF', '#9F9F9F',
            '#7F7F7F', '#5F5F5F', '#3F3F3F', '#000000'
        ];

        const CHART_ICONS = {
            line: 'ğŸ“ˆ', bar: 'ğŸ“Š', area: 'ğŸ“‰', stack: 'ğŸ“Š',
            scatter: 'âš¬', pie: 'ğŸ¥§', gauge: 'ğŸ¯', map: 'ğŸ—ºï¸'
        };

        const CHART_CONFIG = {
            maxDataPoints: 500,
            maxGroups: 10,
            gridLines: 5,
            colors: { background: '#0a0e14', grid: '#21262d', text: '#6e7681', textPrimary: '#e6edf3' },
            fonts: { label: '11px JetBrains Mono', value: 'bold 12px JetBrains Mono', title: '14px Space Grotesk', gauge: 'bold 32px JetBrains Mono' },
            padding: { top: 20, right: 20, bottom: 30, left: 50 }
        };

        const ColorStorage = {
            storageKey: 'numonitor_chartColors',
            get(groupName, label) {
                const colors = JSON.parse(localStorage.getItem(this.storageKey) || '{}');
                return colors[`${groupName}:${label}`];
            },
            set(groupName, label, color) {
                const colors = JSON.parse(localStorage.getItem(this.storageKey) || '{}');
                colors[`${groupName}:${label}`] = color;
                localStorage.setItem(this.storageKey, JSON.stringify(colors));
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Plotter Parser (v2.0 - æ”¯æ´è¨ˆæ•¸å™¨ã€Key:Valueã€åœ°åœ–åº§æ¨™)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class PlotterParser {
            constructor() {
                // ç¾¤çµ„å®šç¾©æ¨¡å¼: {Name|min|max|type}
                this.groupPattern = /^\{([^\|]+)\|([^\|]+)\|([^\|]+)\|([^\}]+)\}(.*)$/;
                
                // è¨ˆæ•¸å™¨æ¨¡å¼: #æ•¸å­— (æ”¯æ´æ•´æ•¸ã€è£œé›¶ã€å°æ•¸)
                this.counterPattern = /^#(-?\d+\.?\d*)\s*/;
                
                // åœ°åœ–åº§æ¨™æ¨¡å¼ (ä¸åˆ†å¤§å°å¯«)
                this.mapPatterns = [
                    // DD: map:25.051075,121.630951 æˆ– map:-25.051075,-121.630951
                    /map:\s*(-?\d+\.?\d*)\s*,\s*(-?\d+\.?\d*)/i,
                    // DD with direction: map:25.051075N,121.630951E
                    /map:\s*(\d+\.?\d*)\s*([NSns])\s*,\s*(\d+\.?\d*)\s*([EWew])/i,
                    // DM: map:25Â°3.0645'N,121Â°37.857'E
                    /map:\s*(\d+)[Â°]\s*(\d+\.?\d*)'?\s*([NSns])\s*,\s*(\d+)[Â°]\s*(\d+\.?\d*)'?\s*([EWew])/i,
                    // DMS: map:25Â°3'3.87"N,121Â°37'51.4"E
                    /map:\s*(\d+)[Â°]\s*(\d+)'\s*(\d+\.?\d*)"?\s*([NSns])\s*,\s*(\d+)[Â°]\s*(\d+)'\s*(\d+\.?\d*)"?\s*([EWew])/i
                ];
            }

            parse(line) {
                if (!line || typeof line !== 'string') return null;
                const trimmed = line.trim();
                if (!trimmed) return null;
                
                const match = trimmed.match(this.groupPattern);
                if (match) {
                    const groupName = match[1].trim();
                    const minVal = this.parseRange(match[2]);
                    const maxVal = this.parseRange(match[3]);
                    const chartType = this.validateChartType(match[4].trim().toLowerCase());
                    const dataStr = match[5].trim();
                    
                    // è§£ææ•¸æ“šéƒ¨åˆ†
                    const { counter, dataPoints, mapCoord } = this.parseDataString(dataStr);
                    if (dataPoints.length === 0) return null;
                    
                    return { 
                        hasGroup: true, 
                        groupName, 
                        minVal, 
                        maxVal, 
                        chartType, 
                        counter,
                        dataPoints,
                        mapCoord
                    };
                } else {
                    // ç„¡ç¾¤çµ„å®šç¾©ï¼Œå˜—è©¦è§£æç‚ºé è¨­æ ¼å¼
                    const { counter, dataPoints, mapCoord } = this.parseDataString(trimmed);
                    if (dataPoints.length === 0) return null;
                    
                    return { 
                        hasGroup: false, 
                        groupName: window.languageManager ? window.languageManager.t('chart.default.group') : 'é è¨­', 
                        minVal: null, 
                        maxVal: null, 
                        chartType: 'line',
                        counter,
                        dataPoints,
                        mapCoord
                    };
                }
            }

            parseRange(value) {
                const trimmed = value.trim().toLowerCase();
                if (trimmed === 'auto') return null;
                const num = parseFloat(trimmed);
                return isNaN(num) ? null : num;
            }

            validateChartType(type) {
                return ['line', 'bar', 'area', 'stack', 'scatter', 'pie', 'gauge'].includes(type) ? type : 'line';
            }

            parseDataString(dataStr) {
                let counter = null;
                let mapCoord = null;
                let remaining = dataStr;
                
                // 1. æå–è¨ˆæ•¸å™¨ #number
                const counterMatch = remaining.match(this.counterPattern);
                if (counterMatch) {
                    counter = parseFloat(counterMatch[1]);
                    remaining = remaining.substring(counterMatch[0].length);
                }
                
                // 2. æå–åœ°åœ–åº§æ¨™ map:lat,lng
                mapCoord = this.parseMapCoordinate(remaining);
                if (mapCoord) {
                    // ç§»é™¤ map: éƒ¨åˆ†
                    remaining = remaining.replace(/map:[^\s]+/i, '').trim();
                }
                
                // 3. è§£ææ•¸æ“šé»
                const dataPoints = this.parseDataPoints(remaining);
                
                return { counter, dataPoints, mapCoord };
            }

            parseMapCoordinate(str) {
                // å˜—è©¦å„ç¨®ç¶“ç·¯åº¦æ ¼å¼
                for (let i = 0; i < this.mapPatterns.length; i++) {
                    const match = str.match(this.mapPatterns[i]);
                    if (match) {
                        return this.convertToDecimalDegrees(match, i);
                    }
                }
                return null;
            }

            convertToDecimalDegrees(match, patternIndex) {
                let lat, lng;
                
                switch (patternIndex) {
                    case 0: // DD: -25.051075,-121.630951
                        lat = parseFloat(match[1]);
                        lng = parseFloat(match[2]);
                        break;
                        
                    case 1: // DD with direction: 25.051075N,121.630951E
                        lat = parseFloat(match[1]);
                        lng = parseFloat(match[3]);
                        if (match[2].toUpperCase() === 'S') lat = -lat;
                        if (match[4].toUpperCase() === 'W') lng = -lng;
                        break;
                        
                    case 2: // DM: 25Â°3.0645'N,121Â°37.857'E
                        lat = parseFloat(match[1]) + parseFloat(match[2]) / 60;
                        lng = parseFloat(match[4]) + parseFloat(match[5]) / 60;
                        if (match[3].toUpperCase() === 'S') lat = -lat;
                        if (match[6].toUpperCase() === 'W') lng = -lng;
                        break;
                        
                    case 3: // DMS: 25Â°3'3.87"N,121Â°37'51.4"E
                        lat = parseFloat(match[1]) + parseFloat(match[2]) / 60 + parseFloat(match[3]) / 3600;
                        lng = parseFloat(match[5]) + parseFloat(match[6]) / 60 + parseFloat(match[7]) / 3600;
                        if (match[4].toUpperCase() === 'S') lat = -lat;
                        if (match[8].toUpperCase() === 'W') lng = -lng;
                        break;
                        
                    default:
                        return null;
                }
                
                // é©—è­‰åº§æ¨™ç¯„åœ
                if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    return null;
                }
                
                return { lat, lng };
            }

            parseDataPoints(dataStr) {
                const dataPoints = [];
                // åˆ†å‰² tokensï¼Œæ”¯æ´ç©ºæ ¼å’Œé€—è™Ÿåˆ†éš”
                const tokens = dataStr.split(/[\s,]+/).filter(t => t.length > 0 && !t.toLowerCase().startsWith('map:'));
                
                tokens.forEach((token, index) => {
                    const colonIndex = token.indexOf(':');
                    if (colonIndex > 0) {
                        // Key:Value æ ¼å¼
                        const label = token.substring(0, colonIndex);
                        const valueStr = token.substring(colonIndex + 1);
                        const value = this.extractNumber(valueStr);
                        if (!isNaN(value)) {
                            dataPoints.push({ label, value, rawValue: valueStr });
                        }
                    } else {
                        // ç´”æ•¸å€¼æ ¼å¼ï¼ˆå‘å¾Œç›¸å®¹ï¼‰
                        const value = this.extractNumber(token);
                        if (!isNaN(value)) {
                            dataPoints.push({ label: `CH${index + 1}`, value, rawValue: token });
                        }
                    }
                });
                
                return dataPoints;
            }

            // æå–æ•¸å€¼ï¼Œéæ¿¾å–®ä½
            extractNumber(str) {
                // åŒ¹é…é–‹é ­çš„æ•¸å€¼éƒ¨åˆ†ï¼ˆåŒ…å«è² è™Ÿå’Œå°æ•¸é»ï¼‰
                const match = str.match(/^(-?\d+\.?\d*)/);
                return match ? parseFloat(match[1]) : NaN;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Chart Base Class
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class ChartBase {
            constructor(ctx, width, height, group) {
                this.ctx = ctx; this.width = width; this.height = height; this.group = group;
                this.padding = { ...CHART_CONFIG.padding };
                this.colors = CHART_CONFIG.colors;
                this.fonts = CHART_CONFIG.fonts;
            }

            getChartArea() {
                return { x: this.padding.left, y: this.padding.top, width: this.width - this.padding.left - this.padding.right, height: this.height - this.padding.top - this.padding.bottom };
            }

            getYRange() {
                let min = this.group.minVal, max = this.group.maxVal;
                if (min === null || max === null) {
                    let dataMin = Infinity, dataMax = -Infinity;
                    this.group.series.forEach((data, label) => {
                        if (this.group.hidden.has(label)) return;
                        data.forEach(v => { if (v < dataMin) dataMin = v; if (v > dataMax) dataMax = v; });
                    });
                    if (dataMin === Infinity) { dataMin = 0; dataMax = 100; }
                    const padding = (dataMax - dataMin) * 0.1 || 1;
                    if (min === null) min = dataMin - padding;
                    if (max === null) max = dataMax + padding;
                }
                return { min, max, range: (max - min) || 1 };
            }

            clear() { 
                const bgColor = this.group.bgColor || this.colors.background;
                this.ctx.fillStyle = bgColor; 
                this.ctx.fillRect(0, 0, this.width, this.height); 
            }

            drawGrid() {
                const area = this.getChartArea();
                const { min, max } = this.getYRange();
                const gridLines = CHART_CONFIG.gridLines;
                this.ctx.strokeStyle = this.colors.grid; this.ctx.lineWidth = 1;
                this.ctx.fillStyle = this.colors.text; this.ctx.font = this.fonts.label;
                this.ctx.textAlign = 'right'; this.ctx.textBaseline = 'middle';
                for (let i = 0; i <= gridLines; i++) {
                    const y = area.y + (i / gridLines) * area.height;
                    const value = max - (i / gridLines) * (max - min);
                    this.ctx.beginPath(); this.ctx.moveTo(area.x, y); this.ctx.lineTo(area.x + area.width, y); this.ctx.stroke();
                    this.ctx.fillText(this.formatValue(value), area.x - 8, y);
                }
                this.ctx.beginPath(); this.ctx.moveTo(area.x, area.y + area.height); this.ctx.lineTo(area.x + area.width, area.y + area.height); this.ctx.stroke();
            }

            formatValue(value) {
                if (Math.abs(value) >= 1000) return value.toFixed(0);
                else if (Math.abs(value) >= 10) return value.toFixed(1);
                else return value.toFixed(2);
            }

            drawEmptyState() {
                this.clear();
                this.ctx.fillStyle = this.colors.text; this.ctx.font = this.fonts.title;
                this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                this.ctx.fillText('ç­‰å¾…æ•¸æ“š...', this.width / 2, this.height / 2);
            }

            hasVisibleData() {
                for (const [label, data] of this.group.series) {
                    if (!this.group.hidden.has(label) && data.length > 0) return true;
                }
                return false;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Line Chart
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class LineChart extends ChartBase {
            render() {
                this.clear();
                if (!this.hasVisibleData()) { this.drawEmptyState(); return; }
                this.drawGrid();
                const area = this.getChartArea();
                const { min, range } = this.getYRange();
                // ä½¿ç”¨ç¾¤çµ„çš„ displayPoints æˆ–é è¨­å€¼
                const displayPoints = this.group.displayPoints || 100;
                const smooth = this.group.smoothEnabled;
                
                // å„²å­˜æ‰€æœ‰ç³»åˆ—çš„é»åº§æ¨™ä¾›éŠæ¨™ä½¿ç”¨
                const allSeriesPoints = new Map();
                
                this.group.series.forEach((data, label) => {
                    if (this.group.hidden.has(label) || data.length === 0) return;
                    this.ctx.strokeStyle = this.group.colors.get(label);
                    this.ctx.lineWidth = 2; this.ctx.lineJoin = 'round'; this.ctx.lineCap = 'round';
                    
                    // è¨ˆç®—è¦é¡¯ç¤ºçš„æ•¸æ“šç¯„åœï¼ˆæœ€æ–°çš„ displayPoints ç­†ï¼‰
                    const startIdx = Math.max(0, data.length - displayPoints);
                    const visibleData = data.slice(startIdx);
                    // Xè»¸æ ¹æ“šå¯¦éš›é»æ•¸è‡ªå‹•èª¿æ•´
                    const pointCount = Math.min(visibleData.length, displayPoints);
                    const xScale = pointCount > 1 ? area.width / (pointCount - 1) : area.width;
                    
                    // è¨ˆç®—é»åº§æ¨™
                    const points = visibleData.map((value, i) => ({
                        x: area.x + i * xScale,
                        y: area.y + area.height - ((value - min) / range) * area.height,
                        value: value,
                        dataIndex: startIdx + i
                    }));
                    
                    allSeriesPoints.set(label, points);
                    
                    this.ctx.beginPath();
                    if (smooth && points.length > 2) {
                        // ä½¿ç”¨è²èŒ²æ›²ç·šå¹³æ»‘
                        this.ctx.moveTo(points[0].x, points[0].y);
                        for (let i = 0; i < points.length - 1; i++) {
                            const cp1x = (points[i].x + points[i + 1].x) / 2;
                            const cp1y = points[i].y;
                            const cp2x = cp1x;
                            const cp2y = points[i + 1].y;
                            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, points[i + 1].x, points[i + 1].y);
                        }
                    } else {
                        // ç›´ç·šé€£æ¥
                        points.forEach((pt, i) => {
                            i === 0 ? this.ctx.moveTo(pt.x, pt.y) : this.ctx.lineTo(pt.x, pt.y);
                        });
                    }
                    this.ctx.stroke();
                });
                
                // ç¹ªè£½ X è»¸éŠæ¨™
                this.drawCursor(area, allSeriesPoints);
            }
            
            drawCursor(area, allSeriesPoints) {
                if (this.group.cursorX === null || this.group.cursorX === undefined) return;
                
                const cursorX = this.group.cursorX;
                // ç¢ºä¿éŠæ¨™åœ¨åœ–è¡¨å€åŸŸå…§
                if (cursorX < area.x || cursorX > area.x + area.width) return;
                
                // ç¹ªè£½å‚ç›´è™›ç·š
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([4, 4]);
                this.ctx.beginPath();
                this.ctx.moveTo(cursorX, area.y);
                this.ctx.lineTo(cursorX, area.y + area.height);
                this.ctx.stroke();
                this.ctx.restore();
                
                // æ‰¾åˆ°æœ€è¿‘çš„æ•¸æ“šé»ç´¢å¼•
                let nearestIndex = -1;
                let minDistance = Infinity;
                
                allSeriesPoints.forEach((points) => {
                    points.forEach((pt, idx) => {
                        const dist = Math.abs(pt.x - cursorX);
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestIndex = idx;
                        }
                    });
                });
                
                if (nearestIndex < 0) return;
                
                // ç²å–è¨ˆæ•¸å™¨å€¼
                const counters = this.group.counters || [];
                const firstSeriesPoints = allSeriesPoints.values().next().value;
                const dataIndex = firstSeriesPoints && firstSeriesPoints[nearestIndex] ? firstSeriesPoints[nearestIndex].dataIndex : nearestIndex;
                const counterValue = counters[dataIndex];
                const counterStr = counterValue !== undefined ? `#${counterValue}` : `#${dataIndex + 1}`;
                
                // ç¹ªè£½è¨ˆæ•¸å™¨æ¨™ç±¤ï¼ˆåœ¨éŠæ¨™ä¸Šæ–¹ï¼‰
                this.ctx.save();
                this.ctx.font = 'bold 11px JetBrains Mono';
                const counterWidth = this.ctx.measureText(counterStr).width + 8;
                const counterX = Math.min(cursorX - counterWidth / 2, area.x + area.width - counterWidth);
                const counterY = area.y - 5;
                
                this.ctx.fillStyle = 'rgba(30, 35, 45, 0.9)';
                this.ctx.beginPath();
                this.ctx.roundRect(Math.max(area.x, counterX), counterY - 16, counterWidth, 18, 4);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#e6edf3';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(counterStr, Math.max(area.x + counterWidth / 2, cursorX), counterY - 7);
                this.ctx.restore();
                
                // åœ¨æ¯æ¢ç·šèˆ‡éŠæ¨™çš„äº¤é»ç¹ªè£½æ•¸å€¼æ¨™ç±¤
                allSeriesPoints.forEach((points, label) => {
                    if (nearestIndex >= points.length) return;
                    const pt = points[nearestIndex];
                    const color = this.group.colors.get(label);
                    const valueStr = `${label}: ${pt.value.toFixed(2)}`;
                    
                    // ç¹ªè£½äº¤é»åœ“é»
                    this.ctx.beginPath();
                    this.ctx.arc(pt.x, pt.y, 5, 0, Math.PI * 2);
                    this.ctx.fillStyle = color;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1.5;
                    this.ctx.stroke();
                    
                    // ç¹ªè£½æ•¸å€¼æ¨™ç±¤
                    this.ctx.save();
                    this.ctx.font = '11px JetBrains Mono';
                    const labelWidth = this.ctx.measureText(valueStr).width + 8;
                    let labelX = pt.x + 10;
                    let labelY = pt.y - 8;
                    
                    // é¿å…è¶…å‡ºå³é‚Šç•Œ
                    if (labelX + labelWidth > area.x + area.width) {
                        labelX = pt.x - labelWidth - 10;
                    }
                    // é¿å…è¶…å‡ºä¸Šé‚Šç•Œ
                    if (labelY - 14 < area.y) {
                        labelY = pt.y + 20;
                    }
                    
                    this.ctx.fillStyle = color + 'E0';
                    this.ctx.beginPath();
                    this.ctx.roundRect(labelX, labelY - 14, labelWidth, 18, 4);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(valueStr, labelX + 4, labelY - 5);
                    this.ctx.restore();
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Bar Chart
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class BarChart extends ChartBase {
            render() {
                this.clear();
                if (!this.hasVisibleData()) { this.drawEmptyState(); return; }
                this.drawGrid();
                const area = this.getChartArea();
                const { min, range } = this.getYRange();
                const labels = Array.from(this.group.series.keys()).filter(l => !this.group.hidden.has(l));
                if (labels.length === 0) return;
                const barWidth = (area.width / (labels.length + 1)) * 0.7;
                const gap = area.width / (labels.length + 1);
                labels.forEach((label, i) => {
                    const data = this.group.series.get(label);
                    const value = data[data.length - 1] || 0;
                    const color = this.group.colors.get(label);
                    const x = area.x + gap * (i + 0.5) - barWidth / 2;
                    const barHeight = ((value - min) / range) * area.height;
                    const y = area.y + area.height - barHeight;
                    this.ctx.fillStyle = color; this.ctx.fillRect(x, y, barWidth, barHeight);
                    this.ctx.fillStyle = this.colors.textPrimary; this.ctx.font = this.fonts.value;
                    this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'bottom';
                    this.ctx.fillText(this.formatValue(value), x + barWidth / 2, y - 4);
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Area Chart
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class AreaChart extends ChartBase {
            render() {
                this.clear();
                if (!this.hasVisibleData()) { this.drawEmptyState(); return; }
                this.drawGrid();
                const area = this.getChartArea();
                const { min, range } = this.getYRange();
                const displayPoints = this.group.displayPoints || 100;
                const smooth = this.group.smoothEnabled;
                const labels = Array.from(this.group.series.keys()).filter(l => !this.group.hidden.has(l));
                
                // å„²å­˜æ‰€æœ‰ç³»åˆ—çš„é»åº§æ¨™ä¾›éŠæ¨™ä½¿ç”¨
                const allSeriesPoints = new Map();
                
                labels.forEach((label) => {
                    const data = this.group.series.get(label);
                    if (data.length === 0) return;
                    const color = this.group.colors.get(label);
                    
                    // è¨ˆç®—è¦é¡¯ç¤ºçš„æ•¸æ“šç¯„åœ
                    const startIdx = Math.max(0, data.length - displayPoints);
                    const visibleData = data.slice(startIdx);
                    const pointCount = Math.min(visibleData.length, displayPoints);
                    const xScale = pointCount > 1 ? area.width / (pointCount - 1) : area.width;
                    
                    // è¨ˆç®—é»åº§æ¨™
                    const points = visibleData.map((value, i) => ({
                        x: area.x + i * xScale,
                        y: area.y + area.height - ((value - min) / range) * area.height,
                        value: value,
                        dataIndex: startIdx + i
                    }));
                    
                    allSeriesPoints.set(label, points);
                    
                    // ç¹ªè£½å¡«å……å€åŸŸ
                    this.ctx.fillStyle = color + '40';
                    this.ctx.beginPath();
                    this.ctx.moveTo(area.x, area.y + area.height);
                    
                    if (smooth && points.length > 2) {
                        this.ctx.lineTo(points[0].x, points[0].y);
                        for (let i = 0; i < points.length - 1; i++) {
                            const cp1x = (points[i].x + points[i + 1].x) / 2;
                            const cp1y = points[i].y;
                            const cp2x = cp1x;
                            const cp2y = points[i + 1].y;
                            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, points[i + 1].x, points[i + 1].y);
                        }
                    } else {
                        points.forEach(pt => this.ctx.lineTo(pt.x, pt.y));
                    }
                    
                    const lastX = points.length > 0 ? points[points.length - 1].x : area.x;
                    this.ctx.lineTo(lastX, area.y + area.height);
                    this.ctx.closePath(); this.ctx.fill();
                    
                    // ç¹ªè£½é‚Šç•Œç·š
                    this.ctx.strokeStyle = color; this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    if (smooth && points.length > 2) {
                        this.ctx.moveTo(points[0].x, points[0].y);
                        for (let i = 0; i < points.length - 1; i++) {
                            const cp1x = (points[i].x + points[i + 1].x) / 2;
                            const cp1y = points[i].y;
                            const cp2x = cp1x;
                            const cp2y = points[i + 1].y;
                            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, points[i + 1].x, points[i + 1].y);
                        }
                    } else {
                        points.forEach((pt, i) => {
                            i === 0 ? this.ctx.moveTo(pt.x, pt.y) : this.ctx.lineTo(pt.x, pt.y);
                        });
                    }
                    this.ctx.stroke();
                });
                
                // ç¹ªè£½ X è»¸éŠæ¨™
                this.drawCursor(area, allSeriesPoints);
            }
            
            drawCursor(area, allSeriesPoints) {
                if (this.group.cursorX === null || this.group.cursorX === undefined) return;
                
                const cursorX = this.group.cursorX;
                if (cursorX < area.x || cursorX > area.x + area.width) return;
                
                // ç¹ªè£½å‚ç›´è™›ç·š
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([4, 4]);
                this.ctx.beginPath();
                this.ctx.moveTo(cursorX, area.y);
                this.ctx.lineTo(cursorX, area.y + area.height);
                this.ctx.stroke();
                this.ctx.restore();
                
                // æ‰¾åˆ°æœ€è¿‘çš„æ•¸æ“šé»ç´¢å¼•
                let nearestIndex = -1;
                let minDistance = Infinity;
                
                allSeriesPoints.forEach((points) => {
                    points.forEach((pt, idx) => {
                        const dist = Math.abs(pt.x - cursorX);
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearestIndex = idx;
                        }
                    });
                });
                
                if (nearestIndex < 0) return;
                
                // ç²å–è¨ˆæ•¸å™¨å€¼
                const counters = this.group.counters || [];
                const firstSeriesPoints = allSeriesPoints.values().next().value;
                const dataIndex = firstSeriesPoints && firstSeriesPoints[nearestIndex] ? firstSeriesPoints[nearestIndex].dataIndex : nearestIndex;
                const counterValue = counters[dataIndex];
                const counterStr = counterValue !== undefined ? `#${counterValue}` : `#${dataIndex + 1}`;
                
                // ç¹ªè£½è¨ˆæ•¸å™¨æ¨™ç±¤
                this.ctx.save();
                this.ctx.font = 'bold 11px JetBrains Mono';
                const counterWidth = this.ctx.measureText(counterStr).width + 8;
                const counterX = Math.min(cursorX - counterWidth / 2, area.x + area.width - counterWidth);
                const counterY = area.y - 5;
                
                this.ctx.fillStyle = 'rgba(30, 35, 45, 0.9)';
                this.ctx.beginPath();
                this.ctx.roundRect(Math.max(area.x, counterX), counterY - 16, counterWidth, 18, 4);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#e6edf3';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(counterStr, Math.max(area.x + counterWidth / 2, cursorX), counterY - 7);
                this.ctx.restore();
                
                // åœ¨æ¯æ¢ç·šèˆ‡éŠæ¨™çš„äº¤é»ç¹ªè£½æ•¸å€¼æ¨™ç±¤
                allSeriesPoints.forEach((points, label) => {
                    if (nearestIndex >= points.length) return;
                    const pt = points[nearestIndex];
                    const color = this.group.colors.get(label);
                    const valueStr = `${label}: ${pt.value.toFixed(2)}`;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(pt.x, pt.y, 5, 0, Math.PI * 2);
                    this.ctx.fillStyle = color;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1.5;
                    this.ctx.stroke();
                    
                    this.ctx.save();
                    this.ctx.font = '11px JetBrains Mono';
                    const labelWidth = this.ctx.measureText(valueStr).width + 8;
                    let labelX = pt.x + 10;
                    let labelY = pt.y - 8;
                    
                    if (labelX + labelWidth > area.x + area.width) labelX = pt.x - labelWidth - 10;
                    if (labelY - 14 < area.y) labelY = pt.y + 20;
                    
                    this.ctx.fillStyle = color + 'E0';
                    this.ctx.beginPath();
                    this.ctx.roundRect(labelX, labelY - 14, labelWidth, 18, 4);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(valueStr, labelX + 4, labelY - 5);
                    this.ctx.restore();
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Stacked Area Chart (å †ç–Šé¢ç©åœ–)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class StackedAreaChart extends ChartBase {
            getYRange() {
                // å †ç–Šåœ–éœ€è¦è¨ˆç®—ç´¯è¨ˆæœ€å¤§å€¼
                let maxStacked = 0;
                const labels = Array.from(this.group.series.keys()).filter(l => !this.group.hidden.has(l));
                if (labels.length === 0) return { min: 0, max: 100, range: 100 };
                
                const dataLength = Math.max(...labels.map(l => this.group.series.get(l).length));
                for (let i = 0; i < dataLength; i++) {
                    let stackedValue = 0;
                    labels.forEach(label => {
                        const data = this.group.series.get(label);
                        if (data[i] !== undefined) stackedValue += Math.max(0, data[i]);
                    });
                    if (stackedValue > maxStacked) maxStacked = stackedValue;
                }
                
                const min = this.group.minVal !== null ? this.group.minVal : 0;
                const max = this.group.maxVal !== null ? Math.max(this.group.maxVal, maxStacked * 1.1) : maxStacked * 1.1 || 100;
                return { min, max, range: (max - min) || 1 };
            }

            render() {
                this.clear();
                if (!this.hasVisibleData()) { this.drawEmptyState(); return; }
                this.drawGrid();
                const area = this.getChartArea();
                const { min, range } = this.getYRange();
                const displayPoints = this.group.displayPoints || 100;
                const smooth = this.group.smoothEnabled;
                const labels = Array.from(this.group.series.keys()).filter(l => !this.group.hidden.has(l));
                
                if (labels.length === 0) return;
                
                // è¨ˆç®—è¦é¡¯ç¤ºçš„æ•¸æ“šç¯„åœ
                const maxDataLen = Math.max(...labels.map(l => this.group.series.get(l).length));
                const startIdx = Math.max(0, maxDataLen - displayPoints);
                const pointCount = Math.min(maxDataLen - startIdx, displayPoints);
                if (pointCount === 0) return;
                
                const xScale = pointCount > 1 ? area.width / (pointCount - 1) : area.width;
                
                // è¨ˆç®—æ¯å€‹é»çš„å †ç–Šç´¯è¨ˆå€¼
                const stackedData = [];
                for (let i = 0; i < pointCount; i++) {
                    const dataIdx = startIdx + i;
                    let cumulative = 0;
                    const pointStack = [];
                    labels.forEach(label => {
                        const data = this.group.series.get(label);
                        const value = data[dataIdx] !== undefined ? Math.max(0, data[dataIdx]) : 0;
                        cumulative += value;
                        pointStack.push({ label, value, cumulative });
                    });
                    stackedData.push(pointStack);
                }
                
                // å¾ä¸‹å¾€ä¸Šç¹ªè£½æ¯å€‹ç³»åˆ—çš„å †ç–Šå€åŸŸ
                for (let seriesIdx = labels.length - 1; seriesIdx >= 0; seriesIdx--) {
                    const label = labels[seriesIdx];
                    const color = this.group.colors.get(label);
                    
                    // è¨ˆç®—ä¸Šé‚Šç•Œå’Œä¸‹é‚Šç•Œ
                    const upperPoints = [];
                    const lowerPoints = [];
                    
                    stackedData.forEach((stack, i) => {
                        const x = area.x + i * xScale;
                        const cumulative = stack[seriesIdx].cumulative;
                        const prevCumulative = seriesIdx > 0 ? stack[seriesIdx - 1].cumulative : 0;
                        
                        const upperY = area.y + area.height - ((cumulative - min) / range) * area.height;
                        const lowerY = area.y + area.height - ((prevCumulative - min) / range) * area.height;
                        
                        upperPoints.push({ x, y: upperY });
                        lowerPoints.push({ x, y: lowerY });
                    });
                    
                    // ç¹ªè£½å¡«å……å€åŸŸ
                    this.ctx.fillStyle = color + '80';
                    this.ctx.beginPath();
                    
                    if (smooth && upperPoints.length > 2) {
                        // ä¸Šé‚Šç•Œ
                        this.ctx.moveTo(upperPoints[0].x, upperPoints[0].y);
                        for (let i = 0; i < upperPoints.length - 1; i++) {
                            const cp1x = (upperPoints[i].x + upperPoints[i + 1].x) / 2;
                            const cp1y = upperPoints[i].y;
                            const cp2x = cp1x;
                            const cp2y = upperPoints[i + 1].y;
                            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, upperPoints[i + 1].x, upperPoints[i + 1].y);
                        }
                        // ä¸‹é‚Šç•Œï¼ˆåå‘ï¼‰
                        for (let i = lowerPoints.length - 1; i >= 0; i--) {
                            if (i === lowerPoints.length - 1) {
                                this.ctx.lineTo(lowerPoints[i].x, lowerPoints[i].y);
                            } else {
                                const cp1x = (lowerPoints[i + 1].x + lowerPoints[i].x) / 2;
                                const cp1y = lowerPoints[i + 1].y;
                                const cp2x = cp1x;
                                const cp2y = lowerPoints[i].y;
                                this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, lowerPoints[i].x, lowerPoints[i].y);
                            }
                        }
                    } else {
                        upperPoints.forEach((pt, i) => {
                            i === 0 ? this.ctx.moveTo(pt.x, pt.y) : this.ctx.lineTo(pt.x, pt.y);
                        });
                        for (let i = lowerPoints.length - 1; i >= 0; i--) {
                            this.ctx.lineTo(lowerPoints[i].x, lowerPoints[i].y);
                        }
                    }
                    
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // ç¹ªè£½ä¸Šé‚Šç•Œç·š
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 1.5;
                    this.ctx.beginPath();
                    if (smooth && upperPoints.length > 2) {
                        this.ctx.moveTo(upperPoints[0].x, upperPoints[0].y);
                        for (let i = 0; i < upperPoints.length - 1; i++) {
                            const cp1x = (upperPoints[i].x + upperPoints[i + 1].x) / 2;
                            const cp1y = upperPoints[i].y;
                            const cp2x = cp1x;
                            const cp2y = upperPoints[i + 1].y;
                            this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, upperPoints[i + 1].x, upperPoints[i + 1].y);
                        }
                    } else {
                        upperPoints.forEach((pt, i) => {
                            i === 0 ? this.ctx.moveTo(pt.x, pt.y) : this.ctx.lineTo(pt.x, pt.y);
                        });
                    }
                    this.ctx.stroke();
                }
                
                // ç¹ªè£½ X è»¸éŠæ¨™
                this.drawStackedCursor(area, stackedData, labels, startIdx, xScale);
            }
            
            drawStackedCursor(area, stackedData, labels, startIdx, xScale) {
                if (this.group.cursorX === null || this.group.cursorX === undefined) return;
                
                const cursorX = this.group.cursorX;
                if (cursorX < area.x || cursorX > area.x + area.width) return;
                
                // ç¹ªè£½å‚ç›´è™›ç·š
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([4, 4]);
                this.ctx.beginPath();
                this.ctx.moveTo(cursorX, area.y);
                this.ctx.lineTo(cursorX, area.y + area.height);
                this.ctx.stroke();
                this.ctx.restore();
                
                // æ‰¾åˆ°æœ€è¿‘çš„æ•¸æ“šé»ç´¢å¼•
                const nearestIndex = Math.round((cursorX - area.x) / xScale);
                if (nearestIndex < 0 || nearestIndex >= stackedData.length) return;
                
                // ç²å–è¨ˆæ•¸å™¨å€¼
                const counters = this.group.counters || [];
                const dataIndex = startIdx + nearestIndex;
                const counterValue = counters[dataIndex];
                const counterStr = counterValue !== undefined ? `#${counterValue}` : `#${dataIndex + 1}`;
                
                // ç¹ªè£½è¨ˆæ•¸å™¨æ¨™ç±¤
                this.ctx.save();
                this.ctx.font = 'bold 11px JetBrains Mono';
                const counterWidth = this.ctx.measureText(counterStr).width + 8;
                const actualX = area.x + nearestIndex * xScale;
                const counterX = Math.min(actualX - counterWidth / 2, area.x + area.width - counterWidth);
                const counterY = area.y - 5;
                
                this.ctx.fillStyle = 'rgba(30, 35, 45, 0.9)';
                this.ctx.beginPath();
                this.ctx.roundRect(Math.max(area.x, counterX), counterY - 16, counterWidth, 18, 4);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#e6edf3';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(counterStr, Math.max(area.x + counterWidth / 2, actualX), counterY - 7);
                this.ctx.restore();
                
                // åœ¨æ¯å€‹ç³»åˆ—é¡¯ç¤ºæ•¸å€¼æ¨™ç±¤
                const { min, range } = this.getYRange();
                const stack = stackedData[nearestIndex];
                
                stack.forEach((item, seriesIdx) => {
                    const color = this.group.colors.get(item.label);
                    const valueStr = `${item.label}: ${item.value.toFixed(2)}`;
                    const y = area.y + area.height - ((item.cumulative - min) / range) * area.height;
                    
                    // ç¹ªè£½äº¤é»åœ“é»
                    this.ctx.beginPath();
                    this.ctx.arc(actualX, y, 5, 0, Math.PI * 2);
                    this.ctx.fillStyle = color;
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1.5;
                    this.ctx.stroke();
                    
                    // ç¹ªè£½æ•¸å€¼æ¨™ç±¤
                    this.ctx.save();
                    this.ctx.font = '11px JetBrains Mono';
                    const labelWidth = this.ctx.measureText(valueStr).width + 8;
                    let labelX = actualX + 10;
                    let labelY = y - 8 - seriesIdx * 22;
                    
                    if (labelX + labelWidth > area.x + area.width) labelX = actualX - labelWidth - 10;
                    if (labelY - 14 < area.y) labelY = y + 20 + seriesIdx * 22;
                    
                    this.ctx.fillStyle = color + 'E0';
                    this.ctx.beginPath();
                    this.ctx.roundRect(labelX, labelY - 14, labelWidth, 18, 4);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#fff';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(valueStr, labelX + 4, labelY - 5);
                    this.ctx.restore();
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Scatter Chart
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class ScatterChart extends ChartBase {
            render() {
                this.clear();
                if (!this.hasVisibleData()) { this.drawEmptyState(); return; }
                this.drawGrid();
                const area = this.getChartArea();
                const { min, range } = this.getYRange();
                const displayPoints = this.group.displayPoints || 100;
                this.group.series.forEach((data, label) => {
                    if (this.group.hidden.has(label) || data.length === 0) return;
                    const color = this.group.colors.get(label);
                    this.ctx.fillStyle = color;
                    // è¨ˆç®—è¦é¡¯ç¤ºçš„æ•¸æ“šç¯„åœ
                    const startIdx = Math.max(0, data.length - displayPoints);
                    const visibleData = data.slice(startIdx);
                    const pointCount = Math.min(visibleData.length, displayPoints);
                    const xScale = pointCount > 1 ? area.width / (pointCount - 1) : area.width;
                    visibleData.forEach((value, i) => {
                        const x = area.x + i * xScale;
                        const y = area.y + area.height - ((value - min) / range) * area.height;
                        this.ctx.beginPath(); this.ctx.arc(x, y, 4, 0, Math.PI * 2); this.ctx.fill();
                    });
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Pie Chart
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class PieChart extends ChartBase {
            render() {
                this.clear();
                if (!this.hasVisibleData()) { this.drawEmptyState(); return; }
                const centerX = this.width / 2, centerY = this.height / 2;
                const radius = Math.min(this.width, this.height) * 0.35;
                const slices = [];
                let total = 0;
                this.group.series.forEach((data, label) => {
                    if (this.group.hidden.has(label)) return;
                    const value = data[data.length - 1] || 0;
                    if (value > 0) { slices.push({ label, value, color: this.group.colors.get(label) }); total += value; }
                });
                if (total === 0) { this.drawEmptyState(); return; }
                let startAngle = -Math.PI / 2;
                slices.forEach(({ value, color }) => {
                    const sliceAngle = (value / total) * Math.PI * 2;
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath(); this.ctx.moveTo(centerX, centerY);
                    this.ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
                    this.ctx.closePath(); this.ctx.fill();
                    this.ctx.strokeStyle = this.colors.background; this.ctx.lineWidth = 2; this.ctx.stroke();
                    if (sliceAngle > 0.2) {
                        const midAngle = startAngle + sliceAngle / 2;
                        const labelX = centerX + Math.cos(midAngle) * radius * 0.65;
                        const labelY = centerY + Math.sin(midAngle) * radius * 0.65;
                        const percent = ((value / total) * 100).toFixed(1);
                        this.ctx.fillStyle = '#ffffff'; this.ctx.font = this.fonts.value;
                        this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(`${percent}%`, labelX, labelY);
                    }
                    startAngle += sliceAngle;
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Gauge Chart
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class GaugeChart extends ChartBase {
            getYRange() {
                let min = this.group.minVal, max = this.group.maxVal;
                if (min === null) min = 0;
                if (max === null) max = 100;
                return { min, max, range: (max - min) || 1 };
            }

            render() {
                this.clear();
                if (!this.hasVisibleData()) { this.drawEmptyState(); return; }
                
                const { min, max, range } = this.getYRange();
                const labels = Array.from(this.group.series.keys()).filter(l => !this.group.hidden.has(l));
                const count = labels.length;
                
                if (count === 0) { this.drawEmptyState(); return; }
                
                // è¨ˆç®—æ¯å€‹å„€è¡¨çš„ä½ç½®å’Œå¤§å°
                const cols = Math.ceil(Math.sqrt(count));
                const rows = Math.ceil(count / cols);
                const cellWidth = this.width / cols;
                const cellHeight = this.height / rows;
                const radius = Math.min(cellWidth, cellHeight) * 0.35;
                
                labels.forEach((label, idx) => {
                    const col = idx % cols;
                    const row = Math.floor(idx / cols);
                    const centerX = cellWidth * (col + 0.5);
                    const centerY = cellHeight * (row + 0.5) + radius * 0.1;
                    
                    const data = this.group.series.get(label) || [];
                    const value = data[data.length - 1] !== undefined ? data[data.length - 1] : min;
                    const color = this.group.colors.get(label) || CHART_COLORS[idx % CHART_COLORS.length];
                    const clampedValue = Math.max(min, Math.min(max, value));
                    
                    // èƒŒæ™¯å¼§
                    this.ctx.strokeStyle = '#30363d';
                    this.ctx.lineWidth = Math.max(8, radius * 0.15);
                    this.ctx.lineCap = 'round';
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, Math.PI, 0);
                    this.ctx.stroke();
                    
                    // æ•¸å€¼å¼§
                    const valueRatio = (clampedValue - min) / range;
                    const angle = Math.PI + valueRatio * Math.PI;
                    this.ctx.strokeStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, Math.PI, angle);
                    this.ctx.stroke();
                    
                    // ä¸­å¿ƒé»
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, Math.max(4, radius * 0.08), 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // æ•¸å€¼æ–‡å­—
                    const fontSize = Math.max(12, radius * 0.4);
                    this.ctx.fillStyle = this.colors.textPrimary;
                    this.ctx.font = `bold ${fontSize}px JetBrains Mono`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(this.formatValue(value), centerX, centerY - radius * 0.3);
                    
                    // æ¨™ç±¤
                    const labelFontSize = Math.max(10, radius * 0.25);
                    this.ctx.font = `${labelFontSize}px Space Grotesk`;
                    this.ctx.fillStyle = this.colors.text;
                    this.ctx.fillText(label, centerX, centerY + radius * 0.4);
                    
                    // æœ€å°/æœ€å¤§å€¼ï¼ˆåªæœ‰å–®ä¸€å„€è¡¨æ™‚é¡¯ç¤ºï¼‰
                    if (count === 1) {
                        this.ctx.font = this.fonts.label;
                        this.ctx.fillText(this.formatValue(min), centerX - radius, centerY + radius * 0.6);
                        this.ctx.fillText(this.formatValue(max), centerX + radius, centerY + radius * 0.6);
                    }
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Chart Manager
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        class ChartManager {
            constructor(tabBar, terminalContainer) {
                this.tabBar = tabBar;
                this.terminalContainer = terminalContainer;
                this.groups = new Map();
                this.colorIndex = 0;
                this.activeTab = 'terminal';
                this.chartRenderers = { line: LineChart, bar: BarChart, area: AreaChart, stack: StackedAreaChart, scatter: ScatterChart, pie: PieChart, gauge: GaugeChart };
                this.initTabEvents();
                if (typeof ResizeObserver !== 'undefined') {
                    this.resizeObserver = new ResizeObserver(() => this.resizeAllCanvases());
                }
                window.addEventListener('resize', () => this.resizeAllCanvases());
            }

            initTabEvents() {
                this.tabBar.addEventListener('click', (e) => {
                    const tabItem = e.target.closest('.tab-item');
                    if (tabItem) {
                        const closeBtn = e.target.closest('.tab-close');
                        if (closeBtn) this.removeGroup(tabItem.dataset.tab.replace('chart-', ''));
                        else this.switchTab(tabItem.dataset.tab);
                    }
                });
            }

            switchTab(tabId) {
                this.activeTab = tabId;
                this.tabBar.querySelectorAll('.tab-item').forEach(tab => tab.classList.toggle('active', tab.dataset.tab === tabId));
                this.terminalContainer.querySelectorAll('.tab-content').forEach(content => content.classList.toggle('active', content.dataset.tab === tabId));
                if (tabId.startsWith('chart-')) {
                    const groupName = tabId.replace('chart-', '');
                    const group = this.groups.get(groupName);
                    if (group) setTimeout(() => this.resizeCanvas(group), 50);
                }
            }

            getOrCreateGroup(parsed) {
                const { groupName, minVal, maxVal, chartType } = parsed;
                if (this.groups.has(groupName)) {
                    const group = this.groups.get(groupName);
                    group.minVal = minVal; group.maxVal = maxVal; group.chartType = chartType;
                    return group;
                }
                if (this.groups.size >= CHART_CONFIG.maxGroups) return null;
                const group = { 
                    name: groupName, 
                    minVal, 
                    maxVal, 
                    chartType, 
                    series: new Map(), 
                    colors: new Map(), 
                    hidden: new Set(), 
                    isPaused: false, 
                    canvas: null, 
                    ctx: null,
                    // æ–°å¢ï¼šè¨ˆæ•¸å™¨å’Œåœ°åœ–æ•¸æ“š
                    counters: [],           // å­˜å„²è¨ˆæ•¸å™¨å€¼
                    mapPoints: [],          // å­˜å„²åœ°åœ–åº§æ¨™ {lat, lng, counter, dataPoints}
                    mapMaxPoints: 10,       // åœ°åœ–æœ€å¤§é¡¯ç¤ºé»æ•¸ (1-100)
                    showMap: false,         // æ˜¯å¦é¡¯ç¤ºåœ°åœ–è¦–åœ–
                    mapLocked: localStorage.getItem(`numonitor_mapLocked_${groupName}`) === 'true',  // è¦–ç•Œé–å®š
                    hasMapData: false,      // æ˜¯å¦æœ‰åœ°åœ–æ•¸æ“š
                    cursorX: null           // Xè»¸éŠæ¨™ä½ç½®
                };
                this.groups.set(groupName, group);
                this.createGroupTab(group);
                return group;
            }

            createGroupTab(group) {
                const tabId = `chart-${group.name}`;
                const icon = CHART_ICONS[group.chartType] || 'ğŸ“ˆ';
                const tabItem = document.createElement('div');
                tabItem.className = 'tab-item';
                tabItem.dataset.tab = tabId;
                tabItem.innerHTML = `<span class="tab-icon">${icon}</span><span>${group.name}</span><span class="tab-close" data-i18n-tip="tab.close" data-tip=""><svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></span>`;
                // Update tooltips for dynamically created elements
                setTimeout(() => {
                    const closeBtn = tabItem.querySelector('.tab-close');
                    if (closeBtn && window.languageManager) {
                        closeBtn.setAttribute('data-tip', window.languageManager.t('tab.close'));
                    }
                }, 0);
                this.tabBar.appendChild(tabItem);

                const tabContent = document.createElement('div');
                tabContent.className = 'tab-content';
                tabContent.id = `tab-${tabId}`;
                tabContent.dataset.tab = tabId;
                // æ ¹æ“šåœ–è¡¨é¡å‹æ±ºå®šæ˜¯å¦é¡¯ç¤ºå¹³æ»‘æ›²ç·šæŒ‰éˆ• (åŒ…å« stack)
                const isTimeSeries = ['line', 'area', 'stack', 'scatter'].includes(group.chartType);
                const lm = window.languageManager;
                const smoothBtn = isTimeSeries ? `<button class="chart-btn" data-action="smooth"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 17c3-6 6-8 9-4s6 2 9-4"/></svg>${lm ? lm.t('chart.btn.smooth') : 'å¹³æ»‘'}</button>` : '';
                // åœ°åœ–æŒ‰éˆ•ï¼ˆåˆå§‹éš±è—ï¼‰
                const mapBtn = isTimeSeries ? `<button class="chart-btn" data-action="map" style="display:none;"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>${lm ? lm.t('chart.btn.map') : 'åœ°åœ–'}</button>` : '';
                
                tabContent.innerHTML = `<div class="chart-container"><div class="chart-header"><div style="display:flex;align-items:center;"><span class="chart-title">${group.name}</span><span class="chart-type-badge">${group.chartType} (100pts)</span></div><div class="chart-controls">${mapBtn}<button class="chart-btn" data-action="pause"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>${lm ? lm.t('chart.btn.pause') : 'æš«åœ'}</button>${smoothBtn}<button class="chart-btn" data-action="clear"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>${lm ? lm.t('chart.btn.clear') : 'æ¸…é™¤'}</button><button class="chart-btn" data-action="export"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>${lm ? lm.t('chart.btn.export') : 'CSV'}</button><button class="chart-btn" data-action="bgcolor"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><path d="M21 15l-5-5L5 21"/></svg>${lm ? lm.t('chart.btn.bgcolor') : 'èƒŒæ™¯'}</button></div></div><div class="chart-area"><canvas class="chart-canvas"></canvas><div class="map-container" style="display:none;"></div></div><div class="chart-legend"></div><div class="map-status" style="display:none;"></div></div>`;
                
                const inputArea = this.terminalContainer.querySelector('.input-area');
                this.terminalContainer.insertBefore(tabContent, inputArea);

                group.canvas = tabContent.querySelector('canvas');
                group.ctx = group.canvas.getContext('2d');
                group.legendEl = tabContent.querySelector('.chart-legend');
                group.mapContainer = tabContent.querySelector('.map-container');
                group.mapStatus = tabContent.querySelector('.map-status');
                group.displayPoints = 100; // é è¨­é¡¯ç¤ºé»æ•¸
                group.smoothEnabled = false; // å¹³æ»‘æ›²ç·šé–‹é—œ
                group.bgColor = localStorage.getItem(`numonitor_bgColor_${group.name}`) || '#0a0e14'; // èƒŒæ™¯é¡è‰²

                // æ»¾è¼ªèª¿æ•´åœ–è¡¨é¡¯ç¤ºé»æ•¸ï¼ˆåœ°åœ–æ¨¡å¼ä¸‹ä¸è™•ç†ï¼Œè®“åœ°åœ–è‡ªè¡Œè™•ç†ç¸®æ”¾ï¼‰
                const chartArea = tabContent.querySelector('.chart-area');
                chartArea.addEventListener('wheel', (e) => {
                    if (group.showMap) {
                        // åœ°åœ–æ¨¡å¼ï¼šä¸æ””æˆªæ»¾è¼ªï¼Œè®“ Leaflet è™•ç†ç¸®æ”¾
                        return;
                    } else if (['line', 'area', 'stack', 'scatter'].includes(group.chartType)) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 1.2 : 0.8; // å‘ä¸‹æ»¾å‹•å¢åŠ é»æ•¸ï¼Œå‘ä¸Šæ¸›å°‘
                        group.displayPoints = Math.max(20, Math.min(2000, Math.round(group.displayPoints * delta)));
                        this.renderChart(group);
                        // æ›´æ–°æ¨™é¡Œé¡¯ç¤ºç•¶å‰é»æ•¸
                        const badge = tabContent.querySelector('.chart-type-badge');
                        if (badge) badge.textContent = `${group.chartType} (${group.displayPoints}pts)`;
                    }
                }, { passive: false });
                
                // X è»¸éŠæ¨™äº‹ä»¶ï¼ˆåƒ…é©ç”¨æ–¼ line, area, stackï¼‰
                if (['line', 'area', 'stack'].includes(group.chartType)) {
                    group.canvas.addEventListener('mousemove', (e) => {
                        if (group.showMap) return;
                        const rect = group.canvas.getBoundingClientRect();
                        const dpr = window.devicePixelRatio || 1;
                        group.cursorX = (e.clientX - rect.left);
                        this.renderChart(group);
                    });
                    group.canvas.addEventListener('mouseleave', () => {
                        group.cursorX = null;
                        this.renderChart(group);
                    });
                }

                tabContent.querySelectorAll('.chart-btn').forEach(btn => {
                    btn.addEventListener('click', () => this.handleChartAction(btn.dataset.action, group, btn));
                });

                group.legendEl.addEventListener('click', (e) => {
                    const colorEl = e.target.closest('.legend-color');
                    const itemEl = e.target.closest('.legend-item');
                    if (colorEl) {
                        e.stopPropagation();
                        const label = colorEl.dataset.label;
                        const currentColor = group.colors.get(label);
                        this.openColorPicker(group, label, currentColor);
                    } else if (itemEl) {
                        const label = itemEl.dataset.label;
                        group.hidden.has(label) ? group.hidden.delete(label) : group.hidden.add(label);
                        this.renderChart(group);
                        this.updateLegend(group);
                    }
                });

                if (this.resizeObserver) this.resizeObserver.observe(tabContent.querySelector('.chart-area'));
                setTimeout(() => this.resizeCanvas(group), 100);
            }

            handleChartAction(action, group, btn) {
                if (action === 'pause') {
                    group.isPaused = !group.isPaused;
                    btn.classList.toggle('active', group.isPaused);
                    const lm = window.languageManager;
                    btn.innerHTML = group.isPaused ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>${lm ? lm.t('chart.btn.resume') : 'ç¹¼çºŒ'}` : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>${lm ? lm.t('chart.btn.pause') : 'æš«åœ'}`;
                } else if (action === 'smooth') {
                    group.smoothEnabled = !group.smoothEnabled;
                    btn.classList.toggle('active', group.smoothEnabled);
                    this.renderChart(group);
                } else if (action === 'clear') {
                    group.series.clear();
                    group.counters = [];
                    group.mapPoints = [];
                    this.renderChart(group);
                    this.updateLegend(group);
                    if (group.showMap) this.renderMap(group);
                } else if (action === 'export') {
                    this.exportCSV(group);
                } else if (action === 'bgcolor') {
                    this.openBgColorPicker(group);
                } else if (action === 'map') {
                    this.toggleMapView(group, btn);
                }
            }
            
            toggleMapView(group, btn) {
                group.showMap = !group.showMap;
                const lm = window.languageManager;
                btn.classList.toggle('active', group.showMap);
                
                // æ›´æ–°æŒ‰éˆ•åœ–ç¤º
                if (group.showMap) {
                    btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>${lm ? lm.t('chart.btn.chart') : 'åœ–è¡¨'}`;
                    group.canvas.style.display = 'none';
                    group.mapContainer.style.display = 'block';
                    group.mapStatus.style.display = 'flex';
                    group.legendEl.style.display = 'none';
                    this.initMap(group);
                    this.renderMap(group);
                    this.updateMapStatus(group);
                } else {
                    btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>${lm ? lm.t('chart.btn.map') : 'åœ°åœ–'}`;
                    group.canvas.style.display = 'block';
                    group.mapContainer.style.display = 'none';
                    group.mapStatus.style.display = 'none';
                    group.legendEl.style.display = 'flex';
                    this.resizeCanvas(group);
                }
            }
            
            initMap(group) {
                if (group.leafletMap) return; // å·²åˆå§‹åŒ–
                
                // è¼‰å…¥ Leaflet CSSï¼ˆå¦‚æœå°šæœªè¼‰å…¥ï¼‰
                if (!document.getElementById('leaflet-css')) {
                    const link = document.createElement('link');
                    link.id = 'leaflet-css';
                    link.rel = 'stylesheet';
                    link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';
                    document.head.appendChild(link);
                }
                
                // è¼‰å…¥ Leaflet JSï¼ˆå¦‚æœå°šæœªè¼‰å…¥ï¼‰
                if (!window.L) {
                    const script = document.createElement('script');
                    script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                    script.onload = () => this.createLeafletMap(group);
                    document.head.appendChild(script);
                } else {
                    this.createLeafletMap(group);
                }
            }
            
            createLeafletMap(group) {
                if (group.leafletMap) return;
                
                // è¨­ç½®å®¹å™¨å°ºå¯¸
                group.mapContainer.style.width = '100%';
                group.mapContainer.style.height = '100%';
                
                // é è¨­ä¸­å¿ƒé»ï¼ˆå°åŒ—ï¼‰
                const defaultCenter = [25.0330, 121.5654];
                const lastPoint = group.mapPoints.length > 0 ? 
                    [group.mapPoints[group.mapPoints.length - 1].lat, group.mapPoints[group.mapPoints.length - 1].lng] : 
                    defaultCenter;
                
                group.leafletMap = L.map(group.mapContainer, {
                    center: lastPoint,
                    zoom: 15,
                    zoomControl: true
                });
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap',
                    maxZoom: 19
                }).addTo(group.leafletMap);
                
                // è»Œè·¡ç·šåœ–å±¤
                group.trackLine = L.polyline([], {
                    color: '#58a6ff',
                    weight: 3,
                    opacity: 0.8
                }).addTo(group.leafletMap);
                
                // è»Œè·¡é»åœ–å±¤çµ„
                group.trackMarkers = L.layerGroup().addTo(group.leafletMap);
                
                // ç•¶å‰ä½ç½®æ¨™è¨˜
                group.currentMarker = null;
                
                // å»¶é²é‡æ–°è¨ˆç®—åœ°åœ–å°ºå¯¸
                setTimeout(() => group.leafletMap.invalidateSize(), 100);
            }
            
            renderMap(group) {
                if (!group.leafletMap || !window.L) return;
                
                // æ¸…é™¤èˆŠæ¨™è¨˜
                group.trackMarkers.clearLayers();
                
                if (group.mapPoints.length === 0) return;
                
                // ç¹ªè£½è»Œè·¡ç·š
                const latLngs = group.mapPoints.map(p => [p.lat, p.lng]);
                group.trackLine.setLatLngs(latLngs);
                
                // ç¹ªè£½è»Œè·¡é»
                group.mapPoints.forEach((point, idx) => {
                    const isLast = idx === group.mapPoints.length - 1;
                    const marker = L.circleMarker([point.lat, point.lng], {
                        radius: isLast ? 8 : 4,
                        fillColor: isLast ? '#f85149' : '#58a6ff',
                        color: isLast ? '#ff7b72' : '#79c0ff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    });
                    
                    // Tooltipï¼šæ»‘é¼  hover å³é¡¯ç¤º
                    const counterStr = point.counter !== null ? `#${point.counter}` : `#${idx + 1}`;
                    
                    // æ§‹å»ºæ•¸æ“šé»é¡¯ç¤ºå…§å®¹ï¼ˆç›´æ¥ä½¿ç”¨åŸå§‹å­—ä¸²ï¼ŒåŒ…å«å–®ä½ï¼‰
                    let dataHtml = '';
                    if (point.dataPoints && point.dataPoints.length > 0) {
                        dataHtml = point.dataPoints.map(dp => 
                            `${dp.label}: ${dp.rawValue || dp.value}`
                        ).join('<br>');
                        dataHtml = '<br>' + dataHtml;
                    }
                    
                    marker.bindTooltip(
                        `<div style="font-family:JetBrains Mono,monospace;font-size:11px;">
                            <strong>${counterStr}</strong><br>
                            Lat: ${point.lat.toFixed(6)}<br>
                            Lng: ${point.lng.toFixed(6)}${dataHtml}
                        </div>`,
                        { 
                            permanent: false,
                            direction: 'top',
                            offset: [0, -8],
                            className: 'map-tooltip'
                        }
                    );
                    
                    group.trackMarkers.addLayer(marker);
                });
                
                // ç§»å‹•åˆ°æœ€æ–°ä½ç½®ï¼ˆåƒ…åœ¨æœªé–å®šæ™‚ï¼‰
                if (!group.mapLocked) {
                    const lastPoint = group.mapPoints[group.mapPoints.length - 1];
                    group.leafletMap.panTo([lastPoint.lat, lastPoint.lng]);
                }
            }
            
            updateMapStatus(group) {
                if (!group.mapStatus) return;
                const lm = window.languageManager;
                const lastPoint = group.mapPoints.length > 0 ? group.mapPoints[group.mapPoints.length - 1] : null;
                const coordStr = lastPoint ? 
                    `${lastPoint.lat >= 0 ? lastPoint.lat.toFixed(6) + 'Â°N' : (-lastPoint.lat).toFixed(6) + 'Â°S'}, ${lastPoint.lng >= 0 ? lastPoint.lng.toFixed(6) + 'Â°E' : (-lastPoint.lng).toFixed(6) + 'Â°W'}` : 
                    '-';
                
                // é–å®šæŒ‰éˆ•çš„åœ–ç¤ºï¼ˆçœ¼ç› + é– ä¸¦æ’ï¼‰
                const lockIcon = group.mapLocked 
                    ? `<svg width="36" height="16" viewBox="0 0 36 16" fill="none" stroke="currentColor" stroke-width="1.5">
                        <!-- çœ¼ç› -->
                        <path d="M1 8s3-6 8-6 8 6 8 6-3 6-8 6S1 8 1 8z"/>
                        <circle cx="9" cy="8" r="2.5" fill="currentColor"/>
                        <!-- é–ï¼ˆé—œé–‰ï¼‰ -->
                        <rect x="22" y="8" width="8" height="6" rx="1" fill="currentColor" stroke="none"/>
                        <path d="M24 8V6a2 2 0 0 1 4 0v2" stroke-width="1.5"/>
                       </svg>`
                    : `<svg width="36" height="16" viewBox="0 0 36 16" fill="none" stroke="currentColor" stroke-width="1.5">
                        <!-- çœ¼ç› -->
                        <path d="M1 8s3-6 8-6 8 6 8 6-3 6-8 6S1 8 1 8z"/>
                        <circle cx="9" cy="8" r="2.5" fill="currentColor"/>
                        <!-- é–ï¼ˆæ‰“é–‹ï¼‰ -->
                        <rect x="22" y="8" width="8" height="6" rx="1" fill="currentColor" stroke="none"/>
                        <path d="M28 8V5a2 2 0 0 0-4 0" stroke-width="1.5"/>
                       </svg>`;
                const lockText = group.mapLocked 
                    ? (lm ? lm.t('map.lock') : 'é–å®š')
                    : (lm ? lm.t('map.follow') : 'è·Ÿéš¨');
                
                group.mapStatus.innerHTML = `
                    <span style="display:flex;align-items:center;gap:6px;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
                        ${coordStr}
                    </span>
                    <div class="map-points-control">
                        <span style="color:var(--text-secondary);">${lm ? lm.t('map.points') : 'è»Œè·¡é»'}:</span>
                        <button class="map-points-btn" data-action="decrease">âˆ’</button>
                        <span class="map-points-value">${group.mapPoints.length}/${group.mapMaxPoints}</span>
                        <button class="map-points-btn" data-action="increase">+</button>
                    </div>
                    <button class="map-lock-btn ${group.mapLocked ? 'locked' : ''}" data-action="toggleLock">
                        ${lockIcon}
                        <span>${lockText}</span>
                    </button>
                `;
                
                // ç¶å®š +/- æŒ‰éˆ•äº‹ä»¶
                group.mapStatus.querySelectorAll('.map-points-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = btn.dataset.action;
                        if (action === 'increase') {
                            group.mapMaxPoints = Math.min(100, group.mapMaxPoints + 5);
                        } else if (action === 'decrease') {
                            group.mapMaxPoints = Math.max(1, group.mapMaxPoints - 5);
                            // è£å‰ªç¾æœ‰é»
                            while (group.mapPoints.length > group.mapMaxPoints) {
                                group.mapPoints.shift();
                            }
                            this.renderMap(group);
                        }
                        // æ›´æ–°é¡¯ç¤º
                        const valueSpan = group.mapStatus.querySelector('.map-points-value');
                        if (valueSpan) {
                            valueSpan.textContent = `${group.mapPoints.length}/${group.mapMaxPoints}`;
                        }
                    });
                });
                
                // ç¶å®šé–å®šæŒ‰éˆ•äº‹ä»¶
                const lockBtn = group.mapStatus.querySelector('.map-lock-btn');
                if (lockBtn) {
                    lockBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        group.mapLocked = !group.mapLocked;
                        // å„²å­˜åˆ° localStorage
                        localStorage.setItem(`numonitor_mapLocked_${group.name}`, group.mapLocked);
                        // æ›´æ–° UI
                        this.updateMapStatus(group);
                        // å¦‚æœè§£é™¤é–å®šï¼Œç«‹å³ç§»å‹•åˆ°æœ€æ–°ä½ç½®
                        if (!group.mapLocked && group.mapPoints.length > 0) {
                            const lastPoint = group.mapPoints[group.mapPoints.length - 1];
                            group.leafletMap.panTo([lastPoint.lat, lastPoint.lng]);
                        }
                    });
                }
            }

            openBgColorPicker(group) {
                window.colorPickerCallback = (newColor) => {
                    group.bgColor = newColor;
                    // å„²å­˜åˆ° localStorage
                    localStorage.setItem(`numonitor_bgColor_${group.name}`, newColor);
                    this.renderChart(group);
                };
                const event = new CustomEvent('openColorPicker', { 
                    detail: { 
                        groupName: group.name, 
                        label: window.languageManager ? window.languageManager.t('chart.bgcolor.label') : 'èƒŒæ™¯é¡è‰²', 
                        currentColor: group.bgColor || '#0a0e14' 
                    } 
                });
                document.dispatchEvent(event);
            }

            exportCSV(group) {
                if (group.series.size === 0) return;
                const labels = Array.from(group.series.keys());
                const maxLen = Math.max(...Array.from(group.series.values()).map(arr => arr.length));
                let csv = 'Index,' + labels.join(',') + '\n';
                for (let i = 0; i < maxLen; i++) {
                    const row = [i];
                    labels.forEach(label => { const data = group.series.get(label); row.push(data[i] !== undefined ? data[i] : ''); });
                    csv += row.join(',') + '\n';
                }
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${group.name}_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }

            openColorPicker(group, label, currentColor) {
                window.colorPickerCallback = (newColor) => {
                    group.colors.set(label, newColor);
                    ColorStorage.set(group.name, label, newColor);
                    this.renderChart(group);
                    this.updateLegend(group);
                };
                const event = new CustomEvent('openColorPicker', { detail: { groupName: group.name, label, currentColor } });
                document.dispatchEvent(event);
            }

            addDataPoints(parsed) {
                // console.log('[Plotter] Adding data points:', parsed);
                const group = this.getOrCreateGroup(parsed);
                if (!group || group.isPaused) return;
                const maxPoints = CHART_CONFIG.maxDataPoints;
                const isTimeSeries = ['line', 'bar', 'area', 'stack', 'scatter'].includes(group.chartType);
                
                // å„²å­˜è¨ˆæ•¸å™¨å€¼
                if (parsed.counter !== null && parsed.counter !== undefined) {
                    group.counters.push(parsed.counter);
                    if (isTimeSeries) { while (group.counters.length > maxPoints) group.counters.shift(); }
                }
                
                // å„²å­˜åœ°åœ–åº§æ¨™
                if (parsed.mapCoord) {
                    group.hasMapData = true;
                    group.mapPoints.push({
                        lat: parsed.mapCoord.lat,
                        lng: parsed.mapCoord.lng,
                        counter: parsed.counter,
                        dataPoints: parsed.dataPoints  // å­˜å„²æ‰€æœ‰æ•¸æ“šé»ï¼ˆå¦‚èˆªé€Ÿã€é«˜åº¦ç­‰ï¼‰
                    });
                    // é™åˆ¶åœ°åœ–é»æ•¸
                    while (group.mapPoints.length > group.mapMaxPoints) {
                        group.mapPoints.shift();
                    }
                    // æ›´æ–°åœ°åœ–æŒ‰éˆ•é¡¯ç¤ºç‹€æ…‹
                    this.updateMapButton(group);
                    
                    // å³æ™‚æ›´æ–°åœ°åœ–ï¼ˆå¦‚æœåœ°åœ–è¦–åœ–å·²é–‹å•Ÿï¼‰
                    if (group.showMap && group.leafletMap) {
                        this.renderMap(group);
                        // æ›´æ–°ç‹€æ…‹æ¬„ä¸­çš„åº§æ¨™å’Œé»æ•¸
                        const coordSpan = group.mapStatus?.querySelector('span:first-child');
                        const valueSpan = group.mapStatus?.querySelector('.map-points-value');
                        if (coordSpan) {
                            const lastPoint = group.mapPoints[group.mapPoints.length - 1];
                            const coordStr = `${lastPoint.lat >= 0 ? lastPoint.lat.toFixed(6) + 'Â°N' : (-lastPoint.lat).toFixed(6) + 'Â°S'}, ${lastPoint.lng >= 0 ? lastPoint.lng.toFixed(6) + 'Â°E' : (-lastPoint.lng).toFixed(6) + 'Â°W'}`;
                            coordSpan.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg> ${coordStr}`;
                        }
                        if (valueSpan) {
                            valueSpan.textContent = `${group.mapPoints.length}/${group.mapMaxPoints}`;
                        }
                    }
                }
                
                parsed.dataPoints.forEach(({ label, value }) => {
                    if (!group.series.has(label)) {
                        group.series.set(label, []);
                        const savedColor = ColorStorage.get(group.name, label);
                        group.colors.set(label, savedColor || CHART_COLORS[this.colorIndex++ % CHART_COLORS.length]);
                    }
                    const data = group.series.get(label);
                    data.push(value);
                    if (isTimeSeries) { while (data.length > maxPoints) data.shift(); }
                    else { while (data.length > 1) data.shift(); }
                });
                this.renderChart(group);
                this.updateLegend(group);
            }
            
            updateMapButton(group) {
                const tabContent = document.getElementById(`tab-chart-${group.name}`);
                if (!tabContent) return;
                const mapBtn = tabContent.querySelector('.chart-btn[data-action="map"]');
                if (mapBtn && group.hasMapData) {
                    mapBtn.style.display = 'flex';
                }
            }

            resizeCanvas(group) {
                if (!group.canvas) return;
                const container = group.canvas.parentElement;
                if (!container) return;
                const rect = container.getBoundingClientRect();
                if (rect.width === 0 || rect.height === 0) return;
                const dpr = window.devicePixelRatio || 1;
                group.canvas.width = rect.width * dpr;
                group.canvas.height = rect.height * dpr;
                group.canvas.style.width = rect.width + 'px';
                group.canvas.style.height = rect.height + 'px';
                group.ctx.setTransform(1, 0, 0, 1, 0, 0);
                group.ctx.scale(dpr, dpr);
                this.renderChart(group);
            }

            resizeAllCanvases() { this.groups.forEach(group => this.resizeCanvas(group)); }

            renderChart(group) {
                if (!group.canvas || !group.ctx) return;
                const dpr = window.devicePixelRatio || 1;
                const width = group.canvas.width / dpr;
                const height = group.canvas.height / dpr;
                if (width <= 0 || height <= 0) return;
                const RendererClass = this.chartRenderers[group.chartType];
                if (!RendererClass) return;
                const renderer = new RendererClass(group.ctx, width, height, group);
                renderer.render();
            }

            updateLegend(group) {
                if (!group.legendEl) return;
                group.legendEl.innerHTML = '';
                group.series.forEach((data, label) => {
                    const color = group.colors.get(label);
                    const value = data[data.length - 1];
                    const isHidden = group.hidden.has(label);
                    const item = document.createElement('div');
                    item.className = 'legend-item' + (isHidden ? ' hidden' : '');
                    item.dataset.label = label;
                    item.innerHTML = `<div class="legend-color" style="background:${color}" data-label="${label}" title="é»æ“Šæ›´æ”¹é¡è‰²"></div><span class="legend-label">${label}</span><span class="legend-value">${value !== undefined ? value.toFixed(2) : '-'}</span>`;
                    group.legendEl.appendChild(item);
                });
            }

            removeGroup(groupName) {
                const group = this.groups.get(groupName);
                if (!group) return;
                const tabId = `chart-${groupName}`;
                const tabItem = this.tabBar.querySelector(`[data-tab="${tabId}"]`);
                if (tabItem) tabItem.remove();
                const tabContent = document.getElementById(`tab-${tabId}`);
                if (tabContent) {
                    if (this.resizeObserver) {
                        const chartArea = tabContent.querySelector('.chart-area');
                        if (chartArea) this.resizeObserver.unobserve(chartArea);
                    }
                    tabContent.remove();
                }
                this.groups.delete(groupName);
                if (this.activeTab === tabId) this.switchTab('terminal');
            }

            clearAll() {
                const groupNames = Array.from(this.groups.keys());
                groupNames.forEach(name => this.removeGroup(name));
                this.colorIndex = 0;
                this.switchTab('terminal');
            }
        }

        // Check for Web Serial API support
        if (!('serial' in navigator)) {
            document.getElementById('browserWarning').classList.add('show');
        }

        // USB Serial Device Database
        const USB_SERIAL_DEVICES = {
            '0403:6001': 'FTDI FT232R', '0403:6010': 'FTDI FT2232', '0403:6014': 'FTDI FT232H',
            '10C4:EA60': 'CP210x', '10C4:EA70': 'CP2105',
            '067B:2303': 'PL2303',
            '1A86:7523': 'CH340', '1A86:5523': 'CH341A', '1A86:7522': 'CH340K', '1A86:55D4': 'CH9102', '1A86:55D3': 'CH343',
            '2341:0043': 'Arduino Uno', '2341:0001': 'Arduino Uno', '2341:0010': 'Arduino Mega',
            '2341:0042': 'Arduino Mega', '2341:8036': 'Arduino Leonardo', '2341:8037': 'Arduino Micro',
            '2A03:0043': 'Arduino Uno',
            '303A:1001': 'ESP32-S3', '303A:1002': 'ESP32-S3', '303A:0002': 'ESP32',
            '16C0:0483': 'Teensy', '0483:5740': 'STM32 VCP',
        };

        function getDeviceName(vid, pid) {
            if (!vid || !pid) return null;
            const key = `${vid.toString(16).toUpperCase().padStart(4, '0')}:${pid.toString(16).toUpperCase().padStart(4, '0')}`;
            return USB_SERIAL_DEVICES[key] || null;
        }

        function getDeviceKey(vid, pid) {
            if (!vid || !pid) return null;
            return `${vid.toString(16).toUpperCase().padStart(4, '0')}:${pid.toString(16).toUpperCase().padStart(4, '0')}`;
        }

        // Device Labels Storage
        const DeviceLabels = {
            getAll() { try { return JSON.parse(localStorage.getItem('serialDeviceLabels') || '{}'); } catch { return {}; } },
            get(key) { return this.getAll()[key] || null; },
            set(key, label) {
                const labels = this.getAll();
                label ? labels[key] = label : delete labels[key];
                localStorage.setItem('serialDeviceLabels', JSON.stringify(labels));
            },
            remove(key) { this.set(key, null); }
        };

        class SerialMonitor {
            constructor() {
                this.port = null;
                this.reader = null;
                this.isConnected = false;
                this.keepReading = false;
                this.rxCount = 0;
                this.txCount = 0;
                this.showTimestamp = false;
                this.autoScroll = true;
                this.hexMode = false;
                this.autoReconnect = true;
                this.echoEnabled = true;  // è¤‡èª¦æŒ‡ä»¤åŠŸèƒ½
                this.buffer = '';
                this.isDisconnecting = false;
                this.textDecoder = new TextDecoder('utf-8', { fatal: false });
                
                // æ­·å²è¨Šæ¯
                this.commandHistory = [];
                this.historyIndex = -1;
                this.maxHistorySize = 30;
                this.tempInput = '';  // æš«å­˜ç•¶å‰è¼¸å…¥
                
                this.lastConnectedDevice = null;
                this.reconnectTimer = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 30;
                this.isReconnecting = false;
                
                this.editingLabelKey = null;
                
                // Terminal Colors
                this.terminalColors = this.loadTerminalColors();
                
                // Plotter
                this.parser = new PlotterParser();
                this.chartManager = null;
                
                this.initElements();
                this.initPlotter();
                this.bindEvents();
            }

            initElements() {
                this.addPortBtn = document.getElementById('addPortBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.baudRateSelect = document.getElementById('baudRate');
                this.autoReconnectToggle = document.getElementById('autoReconnectToggle');
                this.statusDot = document.getElementById('statusDot');
                this.statusText = document.getElementById('statusText');
                this.terminalOutput = document.getElementById('terminalOutput');
                this.inputField = document.getElementById('inputField');
                this.lineEndingSelect = document.getElementById('lineEndingSelect');
                this.sendBtn = document.getElementById('sendBtn');
                
                // æ­·å²è¨Šæ¯ç›¸é—œå…ƒç´ 
                this.historyDropdown = document.getElementById('historyDropdown');
                this.historyBtn = document.getElementById('historyBtn');
                this.historyMenu = document.getElementById('historyMenu');
                this.historyList = document.getElementById('historyList');
                
                this.clearBtn = document.getElementById('clearBtn');
                this.clearAllChartsBtn = document.getElementById('clearAllChartsBtn');
                this.plotterToggle = document.getElementById('plotterToggle');
                this.plotterEnabled = true;
                this.echoBtn = document.getElementById('echoBtn');
                this.timestampBtn = document.getElementById('timestampBtn');
                this.autoScrollBtn = document.getElementById('autoScrollBtn');
                this.textModeBtn = document.getElementById('textModeBtn');
                this.hexModeBtn = document.getElementById('hexModeBtn');
                this.rxCountEl = document.getElementById('rxCount');
                this.txCountEl = document.getElementById('txCount');
                this.portInfoEl = document.getElementById('portInfo');
                
                // Plotter ç›¸é—œå…ƒç´ 
                this.tabBar = document.getElementById('tabBar');
                this.terminalContainer = document.querySelector('.terminal-container');
                
                // Terminal Colors å…ƒç´ 
                this.swatchTx = document.getElementById('swatchTx');
                this.swatchRx = document.getElementById('swatchRx');
                this.swatchSys = document.getElementById('swatchSys');
                this.colorItemTx = document.getElementById('colorItemTx');
                this.colorItemRx = document.getElementById('colorItemRx');
                this.colorItemSys = document.getElementById('colorItemSys');
                
                // åˆå§‹åŒ–è‰²å¡Šé¡è‰²
                this.updateTerminalColorSwatches();
            }

            bindEvents() {
                this.addPortBtn.addEventListener('click', () => this.selectPort());
                
                document.addEventListener('click', (e) => {
                    if (!this.historyDropdown.contains(e.target)) {
                        this.historyDropdown.classList.remove('open');
                    }
                });
                
                // æ­·å²è¨Šæ¯ä¸‹æ‹‰é¸å–®
                this.historyBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.historyDropdown.classList.toggle('open');
                    if (this.historyDropdown.classList.contains('open')) {
                        this.updateHistoryMenu();
                    }
                });
                
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                
                this.autoReconnectToggle.addEventListener('change', (e) => {
                    this.autoReconnect = e.target.checked;
                    this.appendLine(this.autoReconnect ? window.languageManager.t('autoreconnect.enabled') : window.languageManager.t('autoreconnect.disabled'), 'info');
                    if (!this.autoReconnect) this.stopReconnect();
                });

                this.sendBtn.addEventListener('click', () => this.sendData());
                this.clearBtn.addEventListener('click', () => this.clearTerminal());
                this.clearAllChartsBtn.addEventListener('click', () => {
                    if (this.chartManager) {
                        this.chartManager.clearAll();
                        this.appendLine(window.languageManager.t('plotter.cleared'), 'info');
                    }
                });
                this.plotterToggle.addEventListener('change', (e) => {
                    this.plotterEnabled = e.target.checked;
                    this.appendLine(this.plotterEnabled ? 'ğŸ“Š ' + window.languageManager.t('plotter.enabled') : 'ğŸ“Š ' + window.languageManager.t('plotter.disabled'), 'info');
                });
                
                this.echoBtn.addEventListener('click', () => {
                    this.echoEnabled = !this.echoEnabled;
                    this.echoBtn.classList.toggle('active', this.echoEnabled);
                });
                
                this.timestampBtn.addEventListener('click', () => {
                    this.showTimestamp = !this.showTimestamp;
                    this.timestampBtn.classList.toggle('active', this.showTimestamp);
                });

                this.autoScrollBtn.addEventListener('click', () => {
                    this.autoScroll = !this.autoScroll;
                    this.autoScrollBtn.classList.toggle('active', this.autoScroll);
                });

                this.textModeBtn.addEventListener('click', () => {
                    this.hexMode = false;
                    this.textModeBtn.classList.add('active');
                    this.hexModeBtn.classList.remove('active');
                });

                this.hexModeBtn.addEventListener('click', () => {
                    this.hexMode = true;
                    this.hexModeBtn.classList.add('active');
                    this.textModeBtn.classList.remove('active');
                });

                this.inputField.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendData();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.navigateHistory('up');    // ä¸Šéµï¼šå¾€è¼ƒèˆŠçš„è¨Šæ¯
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.navigateHistory('down');  // ä¸‹éµï¼šå¾€è¼ƒæ–°çš„è¨Šæ¯
                    }
                });

                navigator.serial.addEventListener('connect', (e) => {
                    this.appendLine(window.languageManager.t('device.detected'), 'info');
                    
                    if (this.isReconnecting && this.lastConnectedDevice) {
                        const info = e.target.getInfo();
                        const key = getDeviceKey(info.usbVendorId, info.usbProductId);
                        const lastKey = getDeviceKey(this.lastConnectedDevice.vid, this.lastConnectedDevice.pid);
                        if (key === lastKey || (!key && !lastKey)) {
                            this.appendLine(window.languageManager.t('device.restored'), 'system');
                            setTimeout(() => this.attemptReconnect(), 500);
                        }
                    }
                });

                navigator.serial.addEventListener('disconnect', (e) => {
                    if (this.isConnected && this.port === e.target) {
                        const info = e.target.getInfo();
                        this.appendLine(window.languageManager.t('device.disconnected'), 'warning');
                        
                        if (this.autoReconnect) {
                            this.lastConnectedDevice = {
                                vid: info.usbVendorId,
                                pid: info.usbProductId,
                                baudRate: parseInt(this.baudRateSelect.value)
                            };
                            this.startReconnect();
                        }
                        this.forceDisconnect();
                    }
                });
                
                // Terminal Color Picker Events
                this.colorItemTx.addEventListener('click', () => this.openTerminalColorPicker('tx'));
                this.colorItemRx.addEventListener('click', () => this.openTerminalColorPicker('rx'));
                this.colorItemSys.addEventListener('click', () => this.openTerminalColorPicker('sys'));
            }

            startReconnect() {
                if (!this.autoReconnect || this.isReconnecting) return;
                this.isReconnecting = true;
                this.reconnectAttempts = 0;
                this.statusDot.classList.remove('connected');
                this.statusDot.classList.add('reconnecting');
                this.statusText.dataset.i18n = 'status.connecting'; this.statusText.textContent = window.languageManager.t('status.connecting');
                this.appendLine(window.languageManager.t('device.waiting'), 'system');
                
                this.reconnectTimer = setInterval(() => {
                    if (++this.reconnectAttempts > this.maxReconnectAttempts) {
                        this.stopReconnect();
                        this.appendLine(window.languageManager.t('autoreconnect.timeout'), 'warning');
                        return;
                    }
                    this.tryFindAndReconnect();
                }, 1000);
            }
            
            stopReconnect() {
                if (this.reconnectTimer) clearInterval(this.reconnectTimer);
                this.reconnectTimer = null;
                this.isReconnecting = false;
                this.reconnectAttempts = 0;
                if (!this.isConnected) {
                    this.statusDot.classList.remove('reconnecting');
                    this.statusText.dataset.i18n = 'status.disconnected'; this.statusText.textContent = window.languageManager.t('status.disconnected');
                }
            }
            
            async tryFindAndReconnect() {
                if (!this.lastConnectedDevice) return;
                try {
                    const ports = await navigator.serial.getPorts();
                    const targetKey = getDeviceKey(this.lastConnectedDevice.vid, this.lastConnectedDevice.pid);
                    for (const port of ports) {
                        const info = port.getInfo();
                        const key = getDeviceKey(info.usbVendorId, info.usbProductId);
                        if (key === targetKey || (!key && !targetKey)) {
                            this.port = port;
                            await this.attemptReconnect();
                            return;
                        }
                    }
                } catch (e) {}
            }
            
            async attemptReconnect() {
                if (!this.lastConnectedDevice || !this.port) return;
                try {
                    await this.port.open({ baudRate: this.lastConnectedDevice.baudRate });
                    this.stopReconnect();
                    this.isConnected = true;
                    this.keepReading = true;
                    this.isDisconnecting = false;
                    this.textDecoder = new TextDecoder('utf-8', { fatal: false });
                    
                    this.updateConnectionUI(true);
                    const deviceName = getDeviceName(this.lastConnectedDevice.vid, this.lastConnectedDevice.pid);
                    const key = getDeviceKey(this.lastConnectedDevice.vid, this.lastConnectedDevice.pid);
                    this.portInfoEl.textContent = `${deviceName || 'USB Serial'} [${key || ''}]`;
                    this.appendLine(`âœ“ ${window.languageManager.t('device.reconnected')}: ${deviceName || window.languageManager.t('serial.port')} @ ${this.lastConnectedDevice.baudRate} bps`, 'info');
                    this.readLoop();
                } catch (e) {}
            }

            async selectPort() {
                try {
                    const port = await navigator.serial.requestPort();
                    this.port = port;
                    
                    const info = port.getInfo();
                    if (info.usbVendorId) {
                        const deviceName = getDeviceName(info.usbVendorId, info.usbProductId);
                        const key = getDeviceKey(info.usbVendorId, info.usbProductId);
                        this.selectedPortName = deviceName || 'USB Serial';
                        this.selectedPortKey = key;
                        this.appendLine(window.languageManager.t('connection.selected') + ': ' + `${this.selectedPortName} [${key}]`, 'info');
                    } else {
                        this.selectedPortName = 'ä¸²åˆ—åŸ ';
                        this.selectedPortKey = null;
                        this.appendLine(window.languageManager.t('connection.port.selected'), 'info');
                    }
                    
                    // è‡ªå‹•é€£ç·š
                    if (!this.isConnected) {
                        await this.connect();
                    }
                } catch (e) {
                    if (e.name !== 'NotFoundError') {
                        this.appendLine(`${window.languageManager.t('error.general')}: ${e.message}`, 'error');
                    }
                }
            }

            async connect() {
                if (!this.port) {
                    this.appendLine(window.languageManager.t('error.no.port'), 'error');
                    return;
                }

                this.stopReconnect();

                try {
                    const baudRate = parseInt(this.baudRateSelect.value);
                    await this.port.open({ baudRate });
                    
                    this.isConnected = true;
                    this.keepReading = true;
                    this.isDisconnecting = false;
                    this.textDecoder = new TextDecoder('utf-8', { fatal: false });
                    this.updateConnectionUI(true);
                    
                    const info = this.port.getInfo();
                    
                    this.lastConnectedDevice = { vid: info.usbVendorId, pid: info.usbProductId, baudRate };
                    
                    if (info.usbVendorId) {
                        const deviceName = getDeviceName(info.usbVendorId, info.usbProductId);
                        const key = getDeviceKey(info.usbVendorId, info.usbProductId);
                        this.portInfoEl.textContent = `${deviceName || 'USB Serial'} [${key}]`;
                        this.appendLine(window.languageManager.t('connection.connected') + ': ' + `${deviceName || 'USB Serial'} @ ${baudRate} bps`, 'info');
                    } else {
                        this.portInfoEl.textContent = window.languageManager.t('status.connected');
                        this.appendLine(window.languageManager.t('connection.connected') + ' @ ' + `${baudRate} bps`, 'info');
                    }
                    this.readLoop();
                } catch (e) {
                    this.handleConnectionError(e);
                }
            }

            handleConnectionError(error) {
                const tips = error.message.includes('Failed to open')
                    ? ['ç¢ºèªä¸²åˆ—åŸ æœªè¢«å…¶ä»–ç¨‹å¼ä½”ç”¨', 'é—œé–‰ Arduino IDE Serial Monitor', 'å˜—è©¦é‡æ–°æ’æ‹” USB']
                    : ['ç¢ºèªè£ç½®å·²æ­£ç¢ºé€£æ¥', 'å˜—è©¦é‡æ–°æ’æ‹”'];
                
                this.appendLine(`${window.languageManager.t('error.connection')}: ${error.message}`, 'error');
                
                const tipsEl = document.createElement('div');
                tipsEl.className = 'error-tips';
                tipsEl.innerHTML = `<strong>ğŸ”§ ${window.languageManager.t('error.solution.title')}</strong><ul>${tips.map(t => `<li>${t}</li>`).join('')}</ul>`;
                
                const empty = this.terminalOutput.querySelector('.empty-state');
                if (empty) empty.remove();
                this.terminalOutput.appendChild(tipsEl);
                if (this.autoScroll) this.terminalOutput.scrollTop = this.terminalOutput.scrollHeight;
            }

            async disconnect() {
                if (this.isDisconnecting) return;
                this.isDisconnecting = true;
                this.keepReading = false;
                this.lastConnectedDevice = null;
                this.stopReconnect();
                
                try {
                    if (this.reader) try { await this.reader.cancel(); } catch {}
                    if (this.port) try { await this.port.close(); } catch {}
                    this.cleanupConnection();
                    this.appendLine(window.languageManager.t('connection.disconnected'), 'info');
                    this.appendLine('ğŸ’¡ ' + window.languageManager.t('connection.reconnect.tip'), 'info');
                } catch {
                    this.cleanupConnection();
                }
            }

            forceDisconnect() {
                this.keepReading = false;
                this.cleanupConnection();
            }

            cleanupConnection() {
                this.reader = null;
                this.port = null;  // æ¸…é™¤ portï¼Œå¼·åˆ¶ç”¨æˆ¶é‡æ–°é¸æ“‡ä»¥é¿å… USB CDC å•é¡Œ
                this.isConnected = false;
                this.isDisconnecting = false;
                this.keepReading = false;
                this.buffer = '';
                this.updateConnectionUI(false);
                this.portInfoEl.textContent = '-';
            }

            updateConnectionUI(connected) {
                this.statusDot.classList.remove('reconnecting');
                this.statusDot.classList.toggle('connected', connected);
                this.statusText.dataset.i18n = connected ? 'status.connected' : 'status.disconnected'; this.statusText.textContent = window.languageManager.t(this.statusText.dataset.i18n);
                
                this.disconnectBtn.disabled = !connected;  // æœªé€£ç·šæ™‚ç¦ç”¨æ–·é–‹æŒ‰éˆ•
                this.inputField.disabled = !connected;
                this.sendBtn.disabled = !connected;
                this.baudRateSelect.disabled = connected;
                this.addPortBtn.disabled = connected;
            }

            async readLoop() {
                while (this.keepReading && this.port?.readable) {
                    try {
                        this.reader = this.port.readable.getReader();
                        try {
                            while (this.keepReading) {
                                const { value, done } = await this.reader.read();
                                if (done) break;
                                if (value) {
                                    this.rxCount += value.length;
                                    this.rxCountEl.textContent = this.rxCount;
                                    this.hexMode 
                                        ? this.appendHexData(value)
                                        : this.processTextData(this.textDecoder.decode(value, { stream: true }));
                                }
                            }
                        } finally {
                            try { this.reader.releaseLock(); } catch {}
                            this.reader = null;
                        }
                    } catch (e) {
                        if (this.keepReading && e.name !== 'NetworkError') {
                            this.appendLine(`${window.languageManager.t('error.read')}: ${e.message}`, 'error');
                        }
                        break;
                    }
                }
                const remaining = this.textDecoder?.decode();
                if (remaining) this.processTextData(remaining);
            }

            processTextData(text) {
                this.buffer += text;
                const lines = this.buffer.split(/\r\n|\r|\n/);
                this.buffer = lines.pop() || '';
                lines.filter(l => l).forEach(l => {
                    this.appendLine(l, 'received');
                    // è§£æåœ–è¡¨æ•¸æ“šï¼ˆæª¢æŸ¥ç¹ªåœ–åŠŸèƒ½æ˜¯å¦é–‹å•Ÿï¼‰
                    if (this.plotterEnabled && this.chartManager) {
                        const parsed = this.parser.parse(l);
                        if (parsed) {
                            this.chartManager.addDataPoints(parsed);
                        }
                    }
                });
                
                if (this.buffer) {
                    clearTimeout(this.flushTimeout);
                    this.flushTimeout = setTimeout(() => {
                        if (this.buffer) {
                            this.appendLine(this.buffer, 'received');
                            // è§£æåœ–è¡¨æ•¸æ“šï¼ˆæª¢æŸ¥ç¹ªåœ–åŠŸèƒ½æ˜¯å¦é–‹å•Ÿï¼‰
                            if (this.plotterEnabled && this.chartManager) {
                                const parsed = this.parser.parse(this.buffer);
                                if (parsed) this.chartManager.addDataPoints(parsed);
                            }
                            this.buffer = '';
                        }
                    }, 100);
                }
            }

            appendHexData(data) {
                const hex = Array.from(data).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
                const ascii = Array.from(data).map(b => b >= 32 && b <= 126 ? String.fromCharCode(b) : '.').join('');
                this.appendLine(`${hex}  |  ${ascii}`, 'received');
            }

            // æ­·å²è¨Šæ¯å°èˆª
            navigateHistory(direction) {
                // direction: 'up' æˆ– 'down'
                if (this.commandHistory.length === 0) return;
                
                if (direction === 'up') {
                    // ä¸Šéµï¼šé€²å…¥æ­·å² / å¾€è¼ƒèˆŠçš„è¨Šæ¯
                    if (this.historyIndex === -1) {
                        // ç¬¬ä¸€æ¬¡æŒ‰ä¸Šéµï¼Œä¿å­˜ç•¶å‰è¼¸å…¥ï¼Œé¡¯ç¤ºæœ€æ–°æ­·å²
                        this.tempInput = this.inputField.value;
                        this.historyIndex = 0;
                    } else if (this.historyIndex < this.commandHistory.length - 1) {
                        // å¾€æ›´èˆŠçš„æ­·å²
                        this.historyIndex++;
                    }
                    this.inputField.value = this.commandHistory[this.historyIndex];
                } else {
                    // ä¸‹éµï¼šå¾€è¼ƒæ–°çš„è¨Šæ¯ / å›åˆ°ç•¶å‰è¼¸å…¥
                    if (this.historyIndex > 0) {
                        this.historyIndex--;
                        this.inputField.value = this.commandHistory[this.historyIndex];
                    } else if (this.historyIndex === 0) {
                        // å›åˆ°ç•¶å‰è¼¸å…¥
                        this.historyIndex = -1;
                        this.inputField.value = this.tempInput;
                    }
                }
                
                // æ›´æ–°æ­·å²é¸å–®ä¸­çš„é¸ä¸­ç‹€æ…‹
                this.updateHistoryMenuSelection();
                
                // å°‡æ¸¸æ¨™ç§»åˆ°æœ€å¾Œ
                this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);
            }
            
            // æ›´æ–°æ­·å²è¨Šæ¯ä¸‹æ‹‰é¸å–®
            updateHistoryMenu() {
                this.historyList.innerHTML = '';
                
                if (this.commandHistory.length === 0) {
                    this.historyList.innerHTML = '<div class="history-empty" data-i18n="input.history.empty">å°šç„¡æ­·å²è¨Šæ¯</div>';
                    // Update translation immediately after creating the element
                    if (window.languageManager) {
                        window.languageManager.updateUI();
                    }
                    this.historyBtn.classList.remove('has-history');
                    return;
                }
                
                this.historyBtn.classList.add('has-history');
                
                // å¾æœ€èˆŠåˆ°æœ€æ–°æ·»åŠ ï¼ˆå› ç‚º flex-direction: column-reverseï¼‰
                this.commandHistory.forEach((cmd, index) => {
                    const item = document.createElement('div');
                    item.className = 'history-item' + (index === this.historyIndex ? ' selected' : '');
                    item.dataset.index = index;
                    
                    const sendBtnTip = window.languageManager ? window.languageManager.t('input.history.send.tip') : 'ç›´æ¥ç™¼é€';
                    item.innerHTML = `
                        <span class="history-index">${index + 1}.</span>
                        <span class="history-text">${this.escapeHtml(cmd)}</span>
                        <button class="history-send-btn" data-i18n-tip="input.history.send.tip" data-tip="${sendBtnTip}">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"/>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"/>
                            </svg>
                        </button>
                    `;
                    
                    // é»æ“Šæ•´è¡Œ = è¤‡è£½åˆ°è¼¸å…¥æ¡†
                    item.addEventListener('click', (e) => {
                        // å¦‚æœé»æ“Šçš„æ˜¯ç™¼é€æŒ‰éˆ•ï¼Œä¸è™•ç†ï¼ˆç”±æŒ‰éˆ•è‡ªå·±è™•ç†ï¼‰
                        if (e.target.closest('.history-send-btn')) return;
                        this.copyHistoryItem(index);
                    });
                    
                    // é»æ“Šç™¼é€æŒ‰éˆ• = ç›´æ¥ç™¼é€
                    const sendBtn = item.querySelector('.history-send-btn');
                    sendBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.sendHistoryItem(index);
                    });
                    
                    this.historyList.appendChild(item);
                });
            }
            
            // æ›´æ–°æ­·å²é¸å–®ä¸­çš„é¸ä¸­ç‹€æ…‹
            updateHistoryMenuSelection() {
                const items = this.historyList.querySelectorAll('.history-item');
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.historyIndex);
                });
            }
            
            // è¤‡è£½æ­·å²è¨Šæ¯åˆ°è¼¸å…¥æ¡†
            copyHistoryItem(index) {
                this.inputField.value = this.commandHistory[index];
                this.historyDropdown.classList.remove('open');
                this.historyIndex = -1;
                this.tempInput = '';
                this.inputField.focus();
            }
            
            // ç›´æ¥ç™¼é€æ­·å²è¨Šæ¯
            sendHistoryItem(index) {
                this.inputField.value = this.commandHistory[index];
                this.historyDropdown.classList.remove('open');
                this.historyIndex = -1;
                this.tempInput = '';
                this.sendData();
            }
            
            // HTML è½‰ç¾©
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // æ·»åŠ è¨Šæ¯åˆ°æ­·å²è¨˜éŒ„
            addToHistory(text) {
                // é¿å…é‡è¤‡æ·»åŠ ç›¸åŒçš„è¨Šæ¯
                if (this.commandHistory.length === 0 || this.commandHistory[0] !== text) {
                    this.commandHistory.unshift(text);
                    // é™åˆ¶æ­·å²è¨˜éŒ„æ•¸é‡
                    if (this.commandHistory.length > this.maxHistorySize) {
                        this.commandHistory.pop();
                    }
                }
                // é‡ç½®æ­·å²ç´¢å¼•
                this.historyIndex = -1;
                this.tempInput = '';
                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                this.historyBtn.classList.add('has-history');
            }

            async sendData() {
                if (!this.isConnected || !this.port) return;
                const text = this.inputField.value;
                if (!text) return;

                try {
                    const lineEndingValue = this.lineEndingSelect.dataset.selectedValue || '';
                    const lineEnding = lineEndingValue.replace('\\n', '\n').replace('\\r', '\r');
                    const encoded = new TextEncoder().encode(text + lineEnding);
                    const writer = this.port.writable.getWriter();
                    await writer.write(encoded);
                    writer.releaseLock();
                    this.txCount += encoded.length;
                    this.txCountEl.textContent = this.txCount;
                    
                    // æ·»åŠ åˆ°æ­·å²è¨˜éŒ„
                    this.addToHistory(text);
                    
                    // æ ¹æ“š echo è¨­å®šæ±ºå®šæ˜¯å¦è¤‡èª¦
                    if (this.echoEnabled) {
                        this.appendLine(text, 'sent');
                    }
                    
                    this.inputField.value = '';
                } catch (e) {
                    this.appendLine(`${window.languageManager.t('error.send')}: ${e.message}`, 'error');
                }
            }

            appendLine(text, type = 'received') {
                const empty = this.terminalOutput.querySelector('.empty-state');
                if (empty) empty.remove();

                const line = document.createElement('div');
                line.className = `terminal-line ${type}`;
                
                if (this.showTimestamp) {
                    const ts = document.createElement('span');
                    ts.className = 'timestamp';
                    ts.textContent = new Date().toLocaleTimeString('zh-TW', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
                    line.appendChild(ts);
                }
                
                const content = document.createElement('span');
                content.className = 'content';
                
                // è‡ªå‹•è­˜åˆ¥ URL ä¸¦è½‰æ›ç‚ºå¯é»æ“Šé€£çµ
                content.innerHTML = this.linkifyUrls(text);
                
                // å¥—ç”¨å‹•æ…‹é¡è‰²
                if (type === 'sent') {
                    content.style.color = this.terminalColors.tx;
                } else if (type === 'received') {
                    content.style.color = this.terminalColors.rx;
                } else if (['info', 'warning', 'system', 'error'].includes(type)) {
                    content.style.color = this.terminalColors.sys;
                }
                
                line.appendChild(content);
                
                this.terminalOutput.appendChild(line);
                if (this.autoScroll) this.terminalOutput.scrollTop = this.terminalOutput.scrollHeight;
                while (this.terminalOutput.children.length > 1000) this.terminalOutput.removeChild(this.terminalOutput.firstChild);
            }
            
            // URL è­˜åˆ¥èˆ‡è½‰æ›å‡½æ•¸
            linkifyUrls(text) {
                // HTML è½‰ç¾©ï¼ˆé˜²æ­¢ XSSï¼‰
                const escapeHtml = (str) => {
                    const div = document.createElement('div');
                    div.textContent = str;
                    return div.innerHTML;
                };
                
                // URL æ­£å‰‡è¡¨é”å¼
                // åŒ¹é…: http://, https://, ftp://, æˆ– www. é–‹é ­çš„ç¶²å€
                const urlPattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])|(\bwww\.[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gi;
                
                // å…ˆè½‰ç¾©æ•´å€‹æ–‡å­—
                const escaped = escapeHtml(text);
                
                // å°‡ URL æ›¿æ›ç‚ºé€£çµ
                return escaped.replace(urlPattern, (url) => {
                    // å¦‚æœæ˜¯ www. é–‹é ­ï¼Œè£œä¸Š https://
                    const href = url.startsWith('www.') ? 'https://' + url : url;
                    return `<a href="${href}" class="terminal-link" target="_blank" rel="noopener noreferrer" title="${url}">${url}</a>`;
                });
            }

            clearTerminal() {
                this.terminalOutput.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="4" y="4" width="16" height="16" rx="2"/>
                            <path d="M9 9h6M9 13h6M9 17h4"/>
                        </svg>
                        <h3 data-i18n="terminal.empty.title">çµ‚ç«¯å·²æ¸…é™¤</h3>
                        <p data-i18n="terminal.empty.message">ç­‰å¾…æ¥æ”¶æ–°çš„æ•¸æ“š...</p>
                    </div>
                `;
                this.rxCount = this.txCount = 0;
                this.rxCountEl.textContent = this.txCountEl.textContent = '0';
                this.buffer = '';
                // Update i18n after clearing
                if (window.languageManager) {
                    window.languageManager.updateUI();
                }
            }

            // Terminal Colors ç®¡ç†
            loadTerminalColors() {
                const defaults = {
                    tx: '#ffffff',
                    rx: '#81D8D0',
                    sys: '#ffcc00'
                };
                try {
                    const saved = localStorage.getItem('numonitor_terminalColors');
                    if (saved) {
                        return { ...defaults, ...JSON.parse(saved) };
                    }
                } catch (e) {
                    console.warn('Failed to load terminal colors:', e);
                }
                return defaults;
            }

            saveTerminalColors() {
                try {
                    localStorage.setItem('numonitor_terminalColors', JSON.stringify(this.terminalColors));
                } catch (e) {
                    console.warn('Failed to save terminal colors:', e);
                }
            }

            updateTerminalColorSwatches() {
                if (this.swatchTx) this.swatchTx.style.background = this.terminalColors.tx;
                if (this.swatchRx) this.swatchRx.style.background = this.terminalColors.rx;
                if (this.swatchSys) this.swatchSys.style.background = this.terminalColors.sys;
            }

            openTerminalColorPicker(type) {
                const titles = {
                    tx: window.languageManager.t('terminal.color.tx'),
                    rx: window.languageManager.t('terminal.color.rx'),
                    sys: window.languageManager.t('terminal.color.sys')
                };
                const currentColor = this.terminalColors[type];
                const defaultColors = { tx: '#ffffff', rx: '#81D8D0', sys: '#ffcc00' };
                
                window.openColorPicker(currentColor, titles[type], (newColor) => {
                    this.terminalColors[type] = newColor;
                    this.saveTerminalColors();
                    this.updateTerminalColorSwatches();
                    this.applyTerminalColors();
                }, defaultColors[type]);
            }

            applyTerminalColors() {
                // å¥—ç”¨åˆ°ç¾æœ‰çš„çµ‚ç«¯æ©Ÿè¡Œ
                this.terminalOutput.querySelectorAll('.terminal-line.sent .content').forEach(el => {
                    el.style.color = this.terminalColors.tx;
                });
                this.terminalOutput.querySelectorAll('.terminal-line.sent::before').forEach(el => {
                    el.style.color = this.terminalColors.tx;
                });
                this.terminalOutput.querySelectorAll('.terminal-line.received .content').forEach(el => {
                    el.style.color = this.terminalColors.rx;
                });
                this.terminalOutput.querySelectorAll('.terminal-line.info .content, .terminal-line.warning .content, .terminal-line.system .content').forEach(el => {
                    el.style.color = this.terminalColors.sys;
                });
            }

            // Plotter åˆå§‹åŒ–
            initPlotter() {
                if (!this.tabBar) {
                    console.error('[NuMonitor] tabBar å…ƒç´ ä¸å­˜åœ¨!');
                    return;
                }
                if (!this.terminalContainer) {
                    console.error('[NuMonitor] terminalContainer å…ƒç´ ä¸å­˜åœ¨!');
                    return;
                }
                try {
                    this.chartManager = new ChartManager(this.tabBar, this.terminalContainer);
                    console.log('[NuMonitor] Serial Plotter v2.0.0 å·²åˆå§‹åŒ–');
                } catch (e) {
                    console.error('[NuMonitor] ChartManager åˆå§‹åŒ–å¤±æ•—:', e);
                }
            }

            // é‡æ–°è§£ææ‰€æœ‰åœ–è¡¨
            reloadAllCharts() {
                if (!this.chartManager) {
                    console.error('[NuMonitor] chartManager æœªåˆå§‹åŒ–');
                    return;
                }
                this.chartManager.clearAll();
                const receivedLines = this.terminalOutput.querySelectorAll('.terminal-line.received');
                let count = 0;
                receivedLines.forEach(lineEl => {
                    const contentEl = lineEl.querySelector('.content');
                    if (contentEl) {
                        const text = contentEl.textContent;
                        const parsed = this.parser.parse(text);
                        if (parsed) {
                            this.chartManager.addDataPoints(parsed);
                            count++;
                        }
                    }
                });
                this.appendLine(`${window.languageManager.t('chart.reparsed')}: ${count}`, 'info');
            }
        }

        new SerialMonitor();

        // Color Picker initialization
        (function() {
            const modal = document.getElementById('colorPickerModal');
            const palette = document.getElementById('colorPalette');
            const customInput = document.getElementById('colorCustomInput');
            const applyBtn = document.getElementById('colorApplyBtn');
            const cancelBtn = document.getElementById('colorCancelBtn');
            const confirmBtn = document.getElementById('colorConfirmBtn');
            const resetBtn = document.getElementById('colorResetBtn');
            const titleEl = document.getElementById('colorPickerTitle');
            let selectedColor = '';
            let defaultColor = null;
            
            // å…¨å±€é–‹å•Ÿé¡è‰²é¸æ“‡å™¨å‡½æ•¸
            window.openColorPicker = function(currentColor, title, callback, resetDefault) {
                selectedColor = currentColor || '#81D8D0';
                defaultColor = resetDefault || null;
                window.colorPickerCallback = callback;
                
                // è¨­ç½®æ¨™é¡Œ
                if (title && titleEl) {
                    titleEl.textContent = title;
                }
                
                // é¡¯ç¤º/éš±è—é‡ç½®æŒ‰éˆ•
                if (resetBtn) {
                    resetBtn.style.display = defaultColor ? 'block' : 'none';
                }
                
                // å»ºç«‹è‰²ç›¤
                palette.innerHTML = '';
                
                // å½©è‰²å€
                CHART_COLORS.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch' + (color === selectedColor ? ' selected' : '');
                    swatch.style.background = color;
                    swatch.dataset.color = color;
                    palette.appendChild(swatch);
                });
                
                // åˆ†éš”ç·š
                const separator = document.createElement('div');
                separator.className = 'palette-separator';
                palette.appendChild(separator);
                
                // ç°éšå€
                GRAYSCALE_COLORS.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch' + (color === selectedColor ? ' selected' : '');
                    swatch.style.background = color;
                    swatch.dataset.color = color;
                    palette.appendChild(swatch);
                });
                
                customInput.value = selectedColor;
                modal.classList.add('show');
            };
            
            // ç›£è½ openColorPicker äº‹ä»¶ (å‘å¾Œç›¸å®¹)
            document.addEventListener('openColorPicker', (e) => {
                const { currentColor } = e.detail;
                window.openColorPicker(currentColor, null, window.colorPickerCallback, null);
            });
            
            // é»æ“Šè‰²ç›¤
            palette.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-swatch')) {
                    palette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedColor = e.target.dataset.color;
                    customInput.value = selectedColor;
                }
            });
            
            // è‡ªè¨‚é¡è‰²
            applyBtn.addEventListener('click', () => {
                const color = customInput.value;
                if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                    selectedColor = color;
                    palette.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                }
            });
            
            // é‡ç½®ç‚ºé è¨­
            resetBtn.addEventListener('click', () => {
                if (defaultColor) {
                    selectedColor = defaultColor;
                    customInput.value = selectedColor;
                    palette.querySelectorAll('.color-swatch').forEach(s => {
                        s.classList.toggle('selected', s.dataset.color === selectedColor);
                    });
                }
            });
            
            // å–æ¶ˆ
            cancelBtn.addEventListener('click', () => modal.classList.remove('show'));
            
            // ç¢ºå®š
            confirmBtn.addEventListener('click', () => {
                if (selectedColor && window.colorPickerCallback) {
                    window.colorPickerCallback(selectedColor);
                }
                modal.classList.remove('show');
            });
            
            // é»æ“ŠèƒŒæ™¯é—œé–‰
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.classList.remove('show');
            });
        })();

        // Custom Select (Line Ending) initialization
        (function() {
            const customSelect = document.getElementById('lineEndingSelect');
            const trigger = customSelect.querySelector('.custom-select-trigger');
            const valueDisplay = customSelect.querySelector('.custom-select-value');
            const options = customSelect.querySelectorAll('.custom-select-option');
            
            // Set initial value
            const selectedOption = customSelect.querySelector('.custom-select-option.selected');
            if (selectedOption) {
                customSelect.dataset.selectedValue = selectedOption.dataset.value;
            }
            
            // Toggle dropdown
            trigger.addEventListener('click', (e) => {
                e.stopPropagation();
                customSelect.classList.toggle('open');
            });
            
            // Select option
            options.forEach(option => {
                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    options.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    valueDisplay.textContent = option.textContent;
                    customSelect.dataset.selectedValue = option.dataset.value;
                    customSelect.classList.remove('open');
                });
            });
            
            // Close on outside click
            document.addEventListener('click', () => {
                customSelect.classList.remove('open');
            });
        })();

        // Custom Tooltip System (Event Delegation)
        (function() {
            const tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            document.body.appendChild(tooltip);

            let showTimeout;
            let currentTarget = null;

            document.addEventListener('mouseover', (e) => {
                const target = e.target.closest('[data-tip]');
                if (!target || target === currentTarget) return;
                
                currentTarget = target;
                const text = target.getAttribute('data-tip');
                if (!text) return;

                clearTimeout(showTimeout);
                showTimeout = setTimeout(() => {
                    tooltip.textContent = text;
                    
                    const rect = target.getBoundingClientRect();
                    
                    // Position above the element
                    let left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2);
                    let top = rect.top - tooltip.offsetHeight - 10;
                    
                    // Keep within viewport
                    if (left < 8) left = 8;
                    if (left + tooltip.offsetWidth > window.innerWidth - 8) {
                        left = window.innerWidth - tooltip.offsetWidth - 8;
                    }
                    if (top < 8) {
                        top = rect.bottom + 10;
                    }
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.classList.add('visible');
                }, 300);
            });

            document.addEventListener('mouseout', (e) => {
                const target = e.target.closest('[data-tip]');
                if (target && target === currentTarget) {
                    clearTimeout(showTimeout);
                    tooltip.classList.remove('visible');
                    currentTarget = null;
                }
            });
        })();


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  i18n Language Resources (ç°¡åŒ–ç‰ˆ - åªç¿»è­¯é‡è¦çš„ä»‹é¢å…ƒç´ )
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  i18n Language Resources (å®Œæ•´ç‰ˆ)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        window.i18nStrings = {
            'zh-TW': {
                // Header - Connection Panel
                'btn.selectPort': 'é¸æ“‡é€£æ¥åŸ ',
                'btn.selectPort.tip': 'é¸æ“‡è¦é€£æ¥çš„ä¸²åˆ—åŸ ',
                'baudRate.tip': 'è¨­å®šæ³¢ç‰¹ç‡ (bps)',
                'autoReconnect.label': 'è‡ªå‹•é‡é€£',
                'autoReconnect.tip': 'é€£ç·šä¸­æ–·æ™‚è‡ªå‹•é‡é€£',
                'btn.disconnect': 'æ–·é–‹',
                'btn.disconnect.tip': 'æ–·é–‹é€£ç·š',
                'status.tip': 'é€£ç·šç‹€æ…‹',
                'status.disconnected': 'æœªé€£æ¥',
                'status.connecting': 'é€£ç·šä¸­...',
                'status.connected': 'å·²é€£æ¥',
                'lang.switch.tip': 'åˆ‡æ›èªè¨€',
                
                // Terminal Tab
                'tab.terminal': 'çµ‚ç«¯æ©Ÿ',
                // Terminal
                'terminal.output.title': 'çµ‚ç«¯è¼¸å‡º',
                'terminal.mode.text.tip': 'æ–‡å­—æ¨¡å¼ï¼šé¡¯ç¤ºå¯è®€æ–‡å­—',
                'terminal.mode.hex.tip': 'HEX æ¨¡å¼ï¼šé¡¯ç¤ºåå…­é€²ä½æ•¸å€¼',
                'terminal.echo.tip': 'Echoï¼šé¡¯ç¤ºç™¼é€çš„è¨Šæ¯',
                'terminal.timestamp.tip': 'æ™‚é–“æˆ³è¨˜ï¼šé¡¯ç¤ºè¨Šæ¯æ™‚é–“',
                'terminal.autoscroll.tip': 'è‡ªå‹•æ²å‹•åˆ°æœ€æ–°è¨Šæ¯',
                
                // Input History
                'input.history.title': 'æ­·å²è¨Šæ¯',
                'input.history.empty': 'å°šç„¡æ­·å²è¨Šæ¯',
                'input.history.send.tip': 'ç›´æ¥ç™¼é€',
                'tab.plotter': 'ç¹ªåœ–å™¨',
                'tab.close': 'é—œé–‰',
                'plotter.toggle.tip': 'é–‹å•Ÿ/é—œé–‰å³æ™‚ç¹ªåœ–åŠŸèƒ½',
                
                // Terminal Controls
                'terminal.mode.text': 'æ–‡å­—æ¨¡å¼',
                'terminal.mode.text.tip': 'æ–‡å­—æ¨¡å¼ï¼šé¡¯ç¤ºå¯è®€æ–‡å­—',
                'terminal.mode.hex': 'HEX æ¨¡å¼',
                'terminal.mode.hex.tip': 'HEX æ¨¡å¼ï¼šé¡¯ç¤ºåå…­é€²ä½æ•¸å€¼',
                'terminal.echo.tip': 'Echoï¼šé¡¯ç¤ºç™¼é€çš„è¨Šæ¯',
                'terminal.timestamp.tip': 'æ™‚é–“æˆ³è¨˜ï¼šé¡¯ç¤ºè¨Šæ¯æ™‚é–“',
                'terminal.autoscroll.tip': 'è‡ªå‹•æ²å‹•åˆ°æœ€æ–°è¨Šæ¯',
                'terminal.clear.tip': 'æ¸…é™¤çµ‚ç«¯æ©Ÿå…§å®¹',
                
                // Terminal Colors
                'terminal.color.tx': 'è¼¸å…¥ (TX)',
                'terminal.color.tx.tip': 'è¼¸å…¥æ–‡å­—é¡è‰² (TX)',
                'terminal.color.rx': 'è¼¸å‡º (RX)',
                'terminal.color.rx.tip': 'è¼¸å‡ºæ–‡å­—é¡è‰² (RX)',
                'terminal.color.sys': 'ç³»çµ±è¨Šæ¯',
                'terminal.color.sys.tip': 'ç³»çµ±è¨Šæ¯é¡è‰²',
                'terminal.color.reset': 'é‡ç½®ç‚ºé è¨­',
                
                // Plotter Controls
                'plotter.clear.tip': 'æ¸…é™¤æ‰€æœ‰åœ–è¡¨',
                
                // Terminal Empty State
                'terminal.empty.title': 'çµ‚ç«¯å·²æ¸…é™¤',
                'terminal.empty.message': 'ç­‰å¾…æ¥æ”¶æ–°çš„æ•¸æ“š...',
                
                // Input Area
                'input.placeholder': 'è¼¸å…¥è¦ç™¼é€çš„è¨Šæ¯ï¼ŒæŒ‰ Enter ç™¼é€...',
                'input.send': 'ç™¼é€',
                'input.send.tip': 'ç™¼é€è¨Šæ¯ (Enter)',
                'input.history.tip': 'é¡¯ç¤ºæ­·å²è¨Šæ¯',
                'input.lineending.tip': 'è¨­å®šè¡Œå°¾å­—å…ƒ',
                'input.lineending.none': 'ç„¡è¡Œå°¾',
                'input.lineending.none.tip': 'ä¸æ·»åŠ è¡Œå°¾å­—å…ƒ',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'æ›è¡Œ (Line Feed)',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'æ­¸ä½ (Carriage Return)',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                
                // Stats Bar
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'æ¥æ”¶ä½å…ƒçµ„',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'ç™¼é€ä½å…ƒçµ„',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'è£ç½®è³‡è¨Š',
                'stats.bytes': 'bytes',
                
                // Messages
                'msg.copied': 'å·²è¤‡è£½',
                                
                // Color Picker
                'color.picker.title': 'é¸æ“‡é¡è‰²',
                
                // Buttons
                'btn.cancel': 'å–æ¶ˆ',
                'btn.confirm': 'ç¢ºå®š',
                
                // Browser Warning
                'browser.warning.title': 'ç€è¦½å™¨ä¸æ”¯æ´ Web Serial API',
                
                // Changelog
                'manual.link': 'èªªæ˜æ›¸',
                'manual.tip': 'æŸ¥çœ‹ä½¿ç”¨èªªæ˜æ›¸',
                'changelog.tip': 'æŸ¥çœ‹ç‰ˆæœ¬è®Šæ›´è¨˜éŒ„',
                
                // Connection Waiting
                'connection.waiting.title': 'ç­‰å¾…é€£æ¥',
                'connection.waiting.message': 'é»æ“Šã€Œé¸æ“‡é€£æ¥åŸ ã€é¸æ“‡ä¸²åˆ—åŸ è£ç½®',
                'connection.disconnected': 'é€£ç·šå·²æ–·é–‹',
                'connection.reconnect.tip': 'å¦‚éœ€é‡æ–°é€£æ¥ï¼Œè«‹é»æ“Šã€Œé¸æ“‡é€£æ¥åŸ ã€',
                'connection.selected': 'å·²é¸æ“‡',
                'connection.port.selected': 'å·²é¸æ“‡ä¸²åˆ—åŸ ',
                'connection.connected': 'å·²é€£æ¥',
                
                // Auto Reconnect Messages
                'autoreconnect.enabled': 'è‡ªå‹•é‡é€£å·²å•Ÿç”¨',
                'autoreconnect.disabled': 'è‡ªå‹•é‡é€£å·²åœç”¨',
                'autoreconnect.timeout': 'è‡ªå‹•é‡é€£é€¾æ™‚',
                
                // Plotter Messages
                'plotter.enabled': 'ç¹ªåœ–åŠŸèƒ½å·²é–‹å•Ÿ',
                'plotter.disabled': 'ç¹ªåœ–åŠŸèƒ½å·²é—œé–‰',
                
                // Device Messages
                'device.detected': 'åµæ¸¬åˆ°è£ç½®é€£æ¥',
                'device.restored': 'åµæ¸¬åˆ°åŸè£ç½®æ¢å¾©ï¼Œå˜—è©¦é‡æ–°é€£ç·š...',
                'device.disconnected': 'è£ç½®é€£ç·šä¸­æ–·',
                'device.waiting': 'ç­‰å¾…è£ç½®é‡æ–°é€£æ¥...',
                'device.reconnected': 'å·²é‡æ–°é€£æ¥',
                
                // Common
                'serial.port': 'ä¸²åˆ—åŸ ',
                
                // Error Messages
                'error.general': 'éŒ¯èª¤',
                'error.no.port': 'è«‹å…ˆé¸æ“‡é€£æ¥åŸ ',
                'error.connection': 'é€£æ¥éŒ¯èª¤',
                'error.read': 'è®€å–éŒ¯èª¤',
                'error.send': 'ç™¼é€éŒ¯èª¤',
                
                // Chart Messages
                'chart.reparsed': 'å·²é‡æ–°è§£æåœ–è¡¨æ•¸æ“š',
                
                // Chart UI
                'chart.default.group': 'é è¨­',
                'chart.btn.pause': 'æš«åœ',
                'chart.btn.resume': 'ç¹¼çºŒ',
                'chart.btn.smooth': 'å¹³æ»‘',
                'chart.btn.clear': 'æ¸…é™¤',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'èƒŒæ™¯',
                'chart.btn.map': 'ãƒãƒƒãƒ—',
                'chart.btn.chart': 'ãƒãƒ£ãƒ¼ãƒˆ',
                'map.points': 'è»Œè·¡ç‚¹',
                'map.follow': 'è¿½å¾“',
                'map.lock': 'ãƒ­ãƒƒã‚¯',
                'chart.btn.map': 'åœ°åœ–',
                'chart.btn.chart': 'åœ–è¡¨',
                'chart.bgcolor.label': 'èƒŒæ™¯é¡è‰²',
                
                // Map UI
                'map.points': 'è»Œè·¡é»',
                'map.follow': 'è·Ÿéš¨',
                'map.lock': 'é–å®š',
                
                // Error Messages
                'error.solution.title': 'è§£æ±ºæ–¹æ¡ˆï¼š',
                
                
'plotter.cleared': 'æ‰€æœ‰åœ–è¡¨å·²æ¸…é™¤',
            },
            
            'en-US': {
                // Header - Connection Panel
                'btn.selectPort': 'Select Port',
                'btn.selectPort.tip': 'Select a serial port to connect',
                'baudRate.tip': 'Set baud rate (bps)',
                'autoReconnect.label': 'Auto Reconnect',
                'autoReconnect.tip': 'Automatically reconnect when disconnected',
                'btn.disconnect': 'Disconnect',
                'btn.disconnect.tip': 'Disconnect from port',
                'status.tip': 'Connection Status',
                'status.disconnected': 'Disconnected',
                'status.connecting': 'Connecting...',
                'status.connected': 'Connected',
                'lang.switch.tip': 'Switch Language',
                
                // Terminal Tab
                'tab.terminal': 'Terminal',
                // Terminal
                'terminal.output.title': 'Terminal Output',
                'terminal.mode.text.tip': 'Text Mode: Display readable text',
                'terminal.mode.hex.tip': 'HEX Mode: Display hexadecimal values',
                'terminal.echo.tip': 'Echo: Show sent messages',
                'terminal.timestamp.tip': 'Timestamp: Show message time',
                'terminal.autoscroll.tip': 'Auto-scroll to latest message',
                
                // Input History
                'input.history.title': 'Message History',
                'input.history.empty': 'No message history',
                'input.history.send.tip': 'Send directly',
                'tab.plotter': 'Plotter',
                'tab.close': 'Close',
                'plotter.toggle.tip': 'Toggle real-time plotting',
                
                // Terminal Controls
                'terminal.mode.text': 'TEXT',
                'terminal.mode.text.tip': 'Text Mode: Display readable text',
                'terminal.mode.hex': 'HEX',
                'terminal.mode.hex.tip': 'HEX Mode: Display hexadecimal values',
                'terminal.echo.tip': 'Echo: Show sent messages',
                'terminal.timestamp.tip': 'Timestamp: Show message time',
                'terminal.autoscroll.tip': 'Auto-scroll to latest message',
                'terminal.clear.tip': 'Clear terminal content',
                
                // Terminal Colors
                'terminal.color.tx': 'Input (TX)',
                'terminal.color.tx.tip': 'Input text color (TX)',
                'terminal.color.rx': 'Output (RX)',
                'terminal.color.rx.tip': 'Output text color (RX)',
                'terminal.color.sys': 'System Message',
                'terminal.color.sys.tip': 'System message color',
                'terminal.color.reset': 'Reset to Default',
                
                // Plotter Controls
                'plotter.clear.tip': 'Clear all charts',
                
                // Terminal Empty State
                'terminal.empty.title': 'Terminal Cleared',
                'terminal.empty.message': 'Waiting for new data...',
                
                // Input Area
                'input.placeholder': 'Type message to send, press Enter...',
                'input.send': 'Send',
                'input.send.tip': 'Send message (Enter)',
                'input.history.tip': 'Show message history',
                'input.lineending.tip': 'Set line ending character',
                'input.lineending.none': 'No Line Ending',
                'input.lineending.none.tip': 'No line ending character',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Line Feed',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Carriage Return',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                
                // Stats Bar
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Received Bytes',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Transmitted Bytes',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'Device Information',
                'stats.bytes': 'bytes',
                
                // Messages
                'msg.copied': 'Copied',
                                
                // Color Picker
                'color.picker.title': 'Select Color',
                
                // Buttons
                'btn.cancel': 'Cancel',
                'btn.confirm': 'Confirm',
                
                // Browser Warning
                'browser.warning.title': 'Browser does not support Web Serial API',
                
                // Changelog
                'manual.link': 'Manual',
                'manual.tip': 'View user manual',
                'changelog.tip': 'View changelog',
                
                // Connection Waiting
                'connection.waiting.title': 'Waiting for Connection',
                'connection.waiting.message': 'Click "Select Port" to choose a serial port device',
                'connection.disconnected': 'Connection Disconnected',
                'connection.reconnect.tip': 'To reconnect, click "Select Port"',
                'connection.selected': 'Selected',
                'connection.port.selected': 'Serial Port Selected',
                'connection.connected': 'Connected',
                
                // Auto Reconnect Messages
                'autoreconnect.enabled': 'Auto-reconnect enabled',
                'autoreconnect.disabled': 'Auto-reconnect disabled',
                'autoreconnect.timeout': 'Auto-reconnect timeout',
                
                // Plotter Messages
                'plotter.enabled': 'Plotter enabled',
                'plotter.disabled': 'Plotter disabled',
                
                // Device Messages
                'device.detected': 'Device detected',
                'device.restored': 'Original device restored, attempting reconnection...',
                'device.disconnected': 'Device disconnected',
                'device.waiting': 'Waiting for device to reconnect...',
                'device.reconnected': 'Reconnected',
                
                // Common
                'serial.port': 'Serial Port',
                
                // Error Messages
                'error.general': 'Error',
                'error.no.port': 'Please select a port first',
                'error.connection': 'Connection Error',
                'error.read': 'Read Error',
                'error.send': 'Send Error',
                
                // Chart Messages
                'chart.reparsed': 'Chart data reparsed',
                
                // Chart UI
                'chart.default.group': 'Default',
                'chart.btn.pause': 'Pause',
                'chart.btn.resume': 'Resume',
                'chart.btn.smooth': 'Smooth',
                'chart.btn.clear': 'Clear',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Background',
                'chart.btn.map': 'Map',
                'chart.btn.chart': 'Chart',
                'chart.bgcolor.label': 'Background Color',
                
                // Map UI
                'map.points': 'Track Points',
                'map.follow': 'Follow',
                'map.lock': 'Lock',
                
                // Error Messages
                'error.solution.title': 'Solution:',
                
                
'plotter.cleared': 'All charts cleared',
            },
            
            'ja-JP': {
                // Header - Connection Panel
                'btn.selectPort': 'ãƒãƒ¼ãƒˆé¸æŠ',
                'btn.selectPort.tip': 'æ¥ç¶šã™ã‚‹ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã‚’é¸æŠ',
                'baudRate.tip': 'ãƒœãƒ¼ãƒ¬ãƒ¼ãƒˆã‚’è¨­å®š (bps)',
                'autoReconnect.label': 'è‡ªå‹•å†æ¥ç¶š',
                'autoReconnect.tip': 'åˆ‡æ–­æ™‚ã«è‡ªå‹•çš„ã«å†æ¥ç¶š',
                'btn.disconnect': 'åˆ‡æ–­',
                'btn.disconnect.tip': 'ãƒãƒ¼ãƒˆã‹ã‚‰åˆ‡æ–­',
                'status.tip': 'æ¥ç¶šçŠ¶æ…‹',
                'status.disconnected': 'æœªæ¥ç¶š',
                'status.connecting': 'æ¥ç¶šä¸­...',
                'status.connected': 'æ¥ç¶šæ¸ˆã¿',
                'lang.switch.tip': 'è¨€èªåˆ‡æ›¿',
                
                // Terminal Tab
                'tab.terminal': 'ã‚¿ãƒ¼ãƒŸãƒŠãƒ«',
                // Terminal
                'terminal.output.title': 'ã‚¿ãƒ¼ãƒŸãƒŠãƒ«å‡ºåŠ›',
                'terminal.mode.text.tip': 'ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼šèª­ã¿ã‚„ã™ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º',
                'terminal.mode.hex.tip': 'HEXãƒ¢ãƒ¼ãƒ‰ï¼š16é€²æ•°å€¤ã‚’è¡¨ç¤º',
                'terminal.echo.tip': 'ã‚¨ã‚³ãƒ¼ï¼šé€ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º',
                'terminal.timestamp.tip': 'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ™‚åˆ»ã‚’è¡¨ç¤º',
                'terminal.autoscroll.tip': 'æœ€æ–°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«',
                
                // Input History
                'input.history.title': 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´',
                'input.history.empty': 'å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“',
                'input.history.send.tip': 'ç›´æ¥é€ä¿¡',
                'tab.plotter': 'ãƒ—ãƒ­ãƒƒã‚¿',
                'tab.close': 'é–‰ã˜ã‚‹',
                'plotter.toggle.tip': 'ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ­ãƒƒãƒˆæ©Ÿèƒ½ã®åˆ‡æ›¿',
                
                // Terminal Controls
                'terminal.mode.text': 'ãƒ†ã‚­ã‚¹ãƒˆ',
                'terminal.mode.text.tip': 'ãƒ†ã‚­ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ï¼šèª­ã¿ã‚„ã™ã„ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤º',
                'terminal.mode.hex': 'HEX',
                'terminal.mode.hex.tip': 'HEXãƒ¢ãƒ¼ãƒ‰ï¼š16é€²æ•°å€¤ã‚’è¡¨ç¤º',
                'terminal.echo.tip': 'ã‚¨ã‚³ãƒ¼ï¼šé€ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º',
                'terminal.timestamp.tip': 'ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ™‚åˆ»ã‚’è¡¨ç¤º',
                'terminal.autoscroll.tip': 'æœ€æ–°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«',
                'terminal.clear.tip': 'ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã®å†…å®¹ã‚’ã‚¯ãƒªã‚¢',
                
                // Terminal Colors
                'terminal.color.tx': 'å…¥åŠ› (TX)',
                'terminal.color.tx.tip': 'å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (TX)',
                'terminal.color.rx': 'å‡ºåŠ› (RX)',
                'terminal.color.rx.tip': 'å‡ºåŠ›ãƒ†ã‚­ã‚¹ãƒˆã®è‰² (RX)',
                'terminal.color.sys': 'ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸',
                'terminal.color.sys.tip': 'ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è‰²',
                'terminal.color.reset': 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«ãƒªã‚»ãƒƒãƒˆ',
                
                // Plotter Controls
                'plotter.clear.tip': 'ã™ã¹ã¦ã®ãƒãƒ£ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢',
                
                // Terminal Empty State
                'terminal.empty.title': 'ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ',
                'terminal.empty.message': 'æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’å¾…ã£ã¦ã„ã¾ã™...',
                
                // Input Area
                'input.placeholder': 'é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›ã€Enterã‚­ãƒ¼ã§é€ä¿¡...',
                'input.send': 'é€ä¿¡',
                'input.send.tip': 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ (Enter)',
                'input.history.tip': 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å±¥æ­´ã‚’è¡¨ç¤º',
                'input.lineending.tip': 'è¡Œæœ«æ–‡å­—ã‚’è¨­å®š',
                'input.lineending.none': 'è¡Œæœ«ãªã—',
                'input.lineending.none.tip': 'è¡Œæœ«æ–‡å­—ãªã—',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'ãƒ©ã‚¤ãƒ³ãƒ•ã‚£ãƒ¼ãƒ‰',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'ã‚­ãƒ£ãƒªãƒƒã‚¸ãƒªã‚¿ãƒ¼ãƒ³',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                
                // Stats Bar
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'å—ä¿¡ãƒã‚¤ãƒˆ',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'é€ä¿¡ãƒã‚¤ãƒˆ',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±',
                'stats.bytes': 'bytes',
                
                // Messages
                'msg.copied': 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ',
                                
                // Color Picker
                'color.picker.title': 'è‰²ã‚’é¸æŠ',
                
                // Buttons
                'btn.cancel': 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
                'btn.confirm': 'ç¢ºå®š',
                
                // Browser Warning
                'browser.warning.title': 'ãƒ–ãƒ©ã‚¦ã‚¶ãŒWeb Serial APIã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã›ã‚“',
                
                // Changelog
                'manual.link': 'ãƒãƒ‹ãƒ¥ã‚¢ãƒ«',
                'manual.tip': 'ä½¿ç”¨èª¬æ˜æ›¸ã‚’è¦‹ã‚‹',
                'changelog.tip': 'å¤‰æ›´å±¥æ­´ã‚’è¦‹ã‚‹',
                
                // Connection Waiting
                'connection.waiting.title': 'æ¥ç¶šå¾…ã¡',
                'connection.waiting.message': 'ã€Œãƒãƒ¼ãƒˆé¸æŠã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆãƒ‡ãƒã‚¤ã‚¹ã‚’é¸æŠ',
                'connection.disconnected': 'æ¥ç¶šãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ',
                'connection.reconnect.tip': 'å†æ¥ç¶šã™ã‚‹ã«ã¯ã€Œãƒãƒ¼ãƒˆé¸æŠã€ã‚’ã‚¯ãƒªãƒƒã‚¯',
                'connection.selected': 'é¸æŠæ¸ˆã¿',
                'connection.port.selected': 'ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆã‚’é¸æŠã—ã¾ã—ãŸ',
                'connection.connected': 'æ¥ç¶šæ¸ˆã¿',
                
                // Auto Reconnect Messages
                'autoreconnect.enabled': 'è‡ªå‹•å†æ¥ç¶šãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸ',
                'autoreconnect.disabled': 'è‡ªå‹•å†æ¥ç¶šãŒç„¡åŠ¹ã«ãªã‚Šã¾ã—ãŸ',
                'autoreconnect.timeout': 'è‡ªå‹•å†æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ',
                
                // Plotter Messages
                'plotter.enabled': 'ãƒ—ãƒ­ãƒƒã‚¿ãŒæœ‰åŠ¹ã«ãªã‚Šã¾ã—ãŸ',
                'plotter.disabled': 'ãƒ—ãƒ­ãƒƒã‚¿ãŒç„¡åŠ¹ã«ãªã‚Šã¾ã—ãŸ',
                
                // Device Messages
                'device.detected': 'ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡ºã—ã¾ã—ãŸ',
                'device.restored': 'å…ƒã®ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡ºã€å†æ¥ç¶šã‚’è©¦ã¿ã¦ã„ã¾ã™...',
                'device.disconnected': 'ãƒ‡ãƒã‚¤ã‚¹ãŒåˆ‡æ–­ã•ã‚Œã¾ã—ãŸ',
                'device.waiting': 'ãƒ‡ãƒã‚¤ã‚¹ã®å†æ¥ç¶šã‚’å¾…ã£ã¦ã„ã¾ã™...',
                'device.reconnected': 'å†æ¥ç¶šã—ã¾ã—ãŸ',
                
                // Common
                'serial.port': 'ã‚·ãƒªã‚¢ãƒ«ãƒãƒ¼ãƒˆ',
                
                // Error Messages
                'error.general': 'ã‚¨ãƒ©ãƒ¼',
                'error.no.port': 'æœ€åˆã«ãƒãƒ¼ãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„',
                'error.connection': 'æ¥ç¶šã‚¨ãƒ©ãƒ¼',
                'error.read': 'èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼',
                'error.send': 'é€ä¿¡ã‚¨ãƒ©ãƒ¼',
                
                // Chart Messages
                'chart.reparsed': 'ãƒãƒ£ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å†è§£æã—ã¾ã—ãŸ',
                
                // Chart UI
                'chart.default.group': 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ',
                'chart.btn.pause': 'ä¸€æ™‚åœæ­¢',
                'chart.btn.resume': 'å†é–‹',
                'chart.btn.smooth': 'ã‚¹ãƒ ãƒ¼ã‚º',
                'chart.btn.clear': 'ã‚¯ãƒªã‚¢',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'èƒŒæ™¯',
                'chart.btn.map': 'ãƒãƒƒãƒ—',
                'chart.btn.chart': 'ãƒãƒ£ãƒ¼ãƒˆ',
                'map.points': 'è»Œè·¡ç‚¹',
                'map.follow': 'è¿½å¾“',
                'map.lock': 'ãƒ­ãƒƒã‚¯',
                'chart.bgcolor.label': 'èƒŒæ™¯è‰²',
                // Error Messages
                'error.solution.title': 'è§£æ±ºæ–¹æ³•ï¼š',
                
                
'plotter.cleared': 'ã™ã¹ã¦ã®ãƒãƒ£ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ',
            },

            'fr-FR': {
                // Header - Connection Panel
                'btn.selectPort': 'SÃ©lectionner Port',
                'btn.selectPort.tip': 'SÃ©lectionner un port sÃ©rie',
                'baudRate.tip': 'DÃ©finir le dÃ©bit en bauds (bps)',
                'autoReconnect.label': 'Reconnexion Auto',
                'autoReconnect.tip': 'Reconnexion automatique en cas de dÃ©connexion',
                'btn.disconnect': 'DÃ©connecter',
                'btn.disconnect.tip': 'DÃ©connecter du port',
                'status.tip': 'Ã‰tat de connexion',
                'status.disconnected': 'DÃ©connectÃ©',
                'status.connecting': 'Connexion...',
                'status.connected': 'ConnectÃ©',
                'lang.switch.tip': 'Changer de langue',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'Sortie Terminal',
                'terminal.mode.text.tip': 'Mode texte : Afficher le texte lisible',
                'terminal.mode.hex.tip': 'Mode HEX : Afficher les valeurs hexadÃ©cimales',
                'terminal.echo.tip': 'Ã‰cho : Afficher les messages envoyÃ©s',
                'terminal.timestamp.tip': 'Horodatage : Afficher l\'heure du message',
                'terminal.autoscroll.tip': 'DÃ©filement auto vers le dernier message',
                'input.history.title': 'Historique des Messages',
                'input.history.empty': 'Aucun historique',
                'input.history.send.tip': 'Envoyer directement',
                'tab.plotter': 'Traceur',
                'tab.close': 'Fermer',
                'plotter.toggle.tip': 'Activer/DÃ©sactiver le tracÃ© en temps rÃ©el',
                'terminal.mode.text': 'TEXTE',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Effacer le contenu du terminal',
                
                // Terminal Colors
                'terminal.color.tx': 'EntrÃ©e (TX)',
                'terminal.color.tx.tip': 'Couleur du texte d\'entrÃ©e (TX)',
                'terminal.color.rx': 'Sortie (RX)',
                'terminal.color.rx.tip': 'Couleur du texte de sortie (RX)',
                'terminal.color.sys': 'Message SystÃ¨me',
                'terminal.color.sys.tip': 'Couleur des messages systÃ¨me',
                'terminal.color.reset': 'RÃ©initialiser par dÃ©faut',
                
                'plotter.clear.tip': 'Effacer tous les graphiques',
                'terminal.empty.title': 'Terminal EffacÃ©',
                'terminal.empty.message': 'En attente de nouvelles donnÃ©es...',
                'input.placeholder': 'Tapez le message Ã  envoyer, appuyez sur EntrÃ©e...',
                'input.send': 'Envoyer',
                'input.send.tip': 'Envoyer le message (EntrÃ©e)',
                'input.history.tip': 'Afficher l\'historique des messages',
                'input.lineending.tip': 'DÃ©finir le caractÃ¨re de fin de ligne',
                'input.lineending.none': 'Sans fin de ligne',
                'input.lineending.none.tip': 'Pas de caractÃ¨re de fin de ligne',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Saut de ligne',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Retour chariot',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Octets reÃ§us',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Octets transmis',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'Info appareil',
                'stats.bytes': 'octets',
                'msg.copied': 'CopiÃ©',
                'color.picker.title': 'Choisir la couleur',
                'btn.cancel': 'Annuler',
                'btn.confirm': 'Confirmer',
                'browser.warning.title': 'Le navigateur ne prend pas en charge Web Serial API',
                'manual.link': 'Manuel',
                'manual.tip': 'Voir le manuel utilisateur',
                'changelog.tip': 'Voir le journal des modifications',
                'connection.waiting.title': 'En attente de connexion',
                'connection.waiting.message': 'Cliquez sur "SÃ©lectionner Port" pour choisir un appareil',
                'connection.disconnected': 'Connexion dÃ©connectÃ©e',
                'connection.reconnect.tip': 'Pour reconnecter, cliquez sur "SÃ©lectionner Port"',
                'connection.selected': 'SÃ©lectionnÃ©',
                'connection.port.selected': 'Port sÃ©rie sÃ©lectionnÃ©',
                'connection.connected': 'ConnectÃ©',
                'autoreconnect.enabled': 'Reconnexion auto activÃ©e',
                'autoreconnect.disabled': 'Reconnexion auto dÃ©sactivÃ©e',
                'autoreconnect.timeout': 'DÃ©lai de reconnexion auto dÃ©passÃ©',
                'plotter.enabled': 'Traceur activÃ©',
                'plotter.disabled': 'Traceur dÃ©sactivÃ©',
                'device.detected': 'Appareil dÃ©tectÃ©',
                'device.restored': 'Appareil restaurÃ©, tentative de reconnexion...',
                'device.disconnected': 'Appareil dÃ©connectÃ©',
                'device.waiting': 'En attente de reconnexion...',
                'device.reconnected': 'ReconnectÃ©',
                'serial.port': 'Port SÃ©rie',
                'error.general': 'Erreur',
                'error.no.port': 'Veuillez d\'abord sÃ©lectionner un port',
                'error.connection': 'Erreur de connexion',
                'error.read': 'Erreur de lecture',
                'error.send': 'Erreur d\'envoi',
                'chart.reparsed': 'DonnÃ©es du graphique rÃ©analysÃ©es',
                'chart.default.group': 'DÃ©faut',
                'chart.btn.pause': 'Pause',
                'chart.btn.resume': 'Reprendre',
                'chart.btn.smooth': 'Lissage',
                'chart.btn.clear': 'Effacer',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Fond',
                'chart.btn.map': 'Carte',
                'chart.btn.chart': 'Graphique',
                'map.points': 'Points de tracÃ©',
                'map.follow': 'Suivre',
                'map.lock': 'Verrouiller',
                'chart.bgcolor.label': 'Couleur de fond',
                'error.solution.title': 'Solution :',
                'plotter.cleared': 'Tous les graphiques effacÃ©s',
            },

            'de-DE': {
                // Header - Connection Panel
                'btn.selectPort': 'Port WÃ¤hlen',
                'btn.selectPort.tip': 'Seriellen Port auswÃ¤hlen',
                'baudRate.tip': 'Baudrate einstellen (bps)',
                'autoReconnect.label': 'Auto-Verbinden',
                'autoReconnect.tip': 'Automatisch bei Trennung neu verbinden',
                'btn.disconnect': 'Trennen',
                'btn.disconnect.tip': 'Vom Port trennen',
                'status.tip': 'Verbindungsstatus',
                'status.disconnected': 'Getrennt',
                'status.connecting': 'Verbinde...',
                'status.connected': 'Verbunden',
                'lang.switch.tip': 'Sprache wechseln',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'Terminal-Ausgabe',
                'terminal.mode.text.tip': 'Textmodus: Lesbaren Text anzeigen',
                'terminal.mode.hex.tip': 'HEX-Modus: Hexadezimalwerte anzeigen',
                'terminal.echo.tip': 'Echo: Gesendete Nachrichten anzeigen',
                'terminal.timestamp.tip': 'Zeitstempel: Nachrichtenzeit anzeigen',
                'terminal.autoscroll.tip': 'Auto-Scroll zur neuesten Nachricht',
                'input.history.title': 'Nachrichtenverlauf',
                'input.history.empty': 'Kein Verlauf',
                'input.history.send.tip': 'Direkt senden',
                'tab.plotter': 'Plotter',
                'tab.close': 'SchlieÃŸen',
                'plotter.toggle.tip': 'Echtzeit-Plotting umschalten',
                'terminal.mode.text': 'TEXT',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Terminalinhalt lÃ¶schen',
                
                // Terminal Colors
                'terminal.color.tx': 'Eingabe (TX)',
                'terminal.color.tx.tip': 'Eingabetextfarbe (TX)',
                'terminal.color.rx': 'Ausgabe (RX)',
                'terminal.color.rx.tip': 'Ausgabetextfarbe (RX)',
                'terminal.color.sys': 'Systemnachricht',
                'terminal.color.sys.tip': 'Systemnachrichtenfarbe',
                'terminal.color.reset': 'Auf Standard zurÃ¼cksetzen',
                
                'plotter.clear.tip': 'Alle Diagramme lÃ¶schen',
                'terminal.empty.title': 'Terminal GelÃ¶scht',
                'terminal.empty.message': 'Warte auf neue Daten...',
                'input.placeholder': 'Nachricht eingeben, Enter zum Senden...',
                'input.send': 'Senden',
                'input.send.tip': 'Nachricht senden (Enter)',
                'input.history.tip': 'Nachrichtenverlauf anzeigen',
                'input.lineending.tip': 'Zeilenende-Zeichen einstellen',
                'input.lineending.none': 'Kein Zeilenende',
                'input.lineending.none.tip': 'Kein Zeilenende-Zeichen',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Zeilenvorschub',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'WagenrÃ¼cklauf',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Empfangene Bytes',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Gesendete Bytes',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'GerÃ¤teinformation',
                'stats.bytes': 'Bytes',
                'msg.copied': 'Kopiert',
                'color.picker.title': 'Farbe wÃ¤hlen',
                'btn.cancel': 'Abbrechen',
                'btn.confirm': 'BestÃ¤tigen',
                'browser.warning.title': 'Browser unterstÃ¼tzt Web Serial API nicht',
                'manual.link': 'Handbuch',
                'manual.tip': 'Benutzerhandbuch anzeigen',
                'changelog.tip': 'Ã„nderungsprotokoll anzeigen',
                'connection.waiting.title': 'Warte auf Verbindung',
                'connection.waiting.message': 'Klicken Sie "Port WÃ¤hlen" um ein GerÃ¤t auszuwÃ¤hlen',
                'connection.disconnected': 'Verbindung getrennt',
                'connection.reconnect.tip': 'Zum Wiederverbinden "Port WÃ¤hlen" klicken',
                'connection.selected': 'AusgewÃ¤hlt',
                'connection.port.selected': 'Serieller Port ausgewÃ¤hlt',
                'connection.connected': 'Verbunden',
                'autoreconnect.enabled': 'Auto-Verbinden aktiviert',
                'autoreconnect.disabled': 'Auto-Verbinden deaktiviert',
                'autoreconnect.timeout': 'Auto-Verbinden ZeitÃ¼berschreitung',
                'plotter.enabled': 'Plotter aktiviert',
                'plotter.disabled': 'Plotter deaktiviert',
                'device.detected': 'GerÃ¤t erkannt',
                'device.restored': 'GerÃ¤t wiederhergestellt, versuche Neuverbindung...',
                'device.disconnected': 'GerÃ¤t getrennt',
                'device.waiting': 'Warte auf GerÃ¤tewiederverbindung...',
                'device.reconnected': 'Wiederverbunden',
                'serial.port': 'Serieller Port',
                'error.general': 'Fehler',
                'error.no.port': 'Bitte zuerst einen Port auswÃ¤hlen',
                'error.connection': 'Verbindungsfehler',
                'error.read': 'Lesefehler',
                'error.send': 'Sendefehler',
                'chart.reparsed': 'Diagrammdaten neu analysiert',
                'chart.default.group': 'Standard',
                'chart.btn.pause': 'Pause',
                'chart.btn.resume': 'Fortsetzen',
                'chart.btn.smooth': 'GlÃ¤tten',
                'chart.btn.clear': 'LÃ¶schen',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Hintergrund',
                'chart.btn.map': 'Karte',
                'chart.btn.chart': 'Diagramm',
                'map.points': 'Spurpunkte',
                'map.follow': 'Folgen',
                'map.lock': 'Sperren',
                'chart.bgcolor.label': 'Hintergrundfarbe',
                'error.solution.title': 'LÃ¶sung:',
                'plotter.cleared': 'Alle Diagramme gelÃ¶scht',
            },

            'it-IT': {
                // Header - Connection Panel
                'btn.selectPort': 'Seleziona Porta',
                'btn.selectPort.tip': 'Seleziona una porta seriale',
                'baudRate.tip': 'Imposta baud rate (bps)',
                'autoReconnect.label': 'Riconnessione Auto',
                'autoReconnect.tip': 'Riconnetti automaticamente alla disconnessione',
                'btn.disconnect': 'Disconnetti',
                'btn.disconnect.tip': 'Disconnetti dalla porta',
                'status.tip': 'Stato connessione',
                'status.disconnected': 'Disconnesso',
                'status.connecting': 'Connessione...',
                'status.connected': 'Connesso',
                'lang.switch.tip': 'Cambia lingua',
                'tab.terminal': 'Terminale',
                'terminal.output.title': 'Output Terminale',
                'terminal.mode.text.tip': 'ModalitÃ  testo: Mostra testo leggibile',
                'terminal.mode.hex.tip': 'ModalitÃ  HEX: Mostra valori esadecimali',
                'terminal.echo.tip': 'Echo: Mostra messaggi inviati',
                'terminal.timestamp.tip': 'Timestamp: Mostra orario messaggio',
                'terminal.autoscroll.tip': 'Auto-scroll all\'ultimo messaggio',
                'input.history.title': 'Cronologia Messaggi',
                'input.history.empty': 'Nessuna cronologia',
                'input.history.send.tip': 'Invia direttamente',
                'tab.plotter': 'Plotter',
                'tab.close': 'Chiudi',
                'plotter.toggle.tip': 'Attiva/Disattiva plotting in tempo reale',
                'terminal.mode.text': 'TESTO',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Cancella contenuto terminale',
                
                // Terminal Colors
                'terminal.color.tx': 'Input (TX)',
                'terminal.color.tx.tip': 'Colore testo input (TX)',
                'terminal.color.rx': 'Output (RX)',
                'terminal.color.rx.tip': 'Colore testo output (RX)',
                'terminal.color.sys': 'Messaggio di Sistema',
                'terminal.color.sys.tip': 'Colore messaggi di sistema',
                'terminal.color.reset': 'Ripristina predefinito',
                
                'plotter.clear.tip': 'Cancella tutti i grafici',
                'terminal.empty.title': 'Terminale Cancellato',
                'terminal.empty.message': 'In attesa di nuovi dati...',
                'input.placeholder': 'Digita il messaggio da inviare, premi Invio...',
                'input.send': 'Invia',
                'input.send.tip': 'Invia messaggio (Invio)',
                'input.history.tip': 'Mostra cronologia messaggi',
                'input.lineending.tip': 'Imposta carattere fine riga',
                'input.lineending.none': 'Nessun fine riga',
                'input.lineending.none.tip': 'Nessun carattere fine riga',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Line Feed',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Carriage Return',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Byte ricevuti',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Byte trasmessi',
                'stats.port.label': 'Porta:',
                'stats.port.tip': 'Info dispositivo',
                'stats.bytes': 'byte',
                'msg.copied': 'Copiato',
                'color.picker.title': 'Seleziona colore',
                'btn.cancel': 'Annulla',
                'btn.confirm': 'Conferma',
                'browser.warning.title': 'Il browser non supporta Web Serial API',
                'manual.link': 'Manuale',
                'manual.tip': 'Visualizza manuale utente',
                'changelog.tip': 'Visualizza registro modifiche',
                'connection.waiting.title': 'In attesa di connessione',
                'connection.waiting.message': 'Clicca "Seleziona Porta" per scegliere un dispositivo',
                'connection.disconnected': 'Connessione disconnessa',
                'connection.reconnect.tip': 'Per riconnetterti, clicca "Seleziona Porta"',
                'connection.selected': 'Selezionato',
                'connection.port.selected': 'Porta seriale selezionata',
                'connection.connected': 'Connesso',
                'autoreconnect.enabled': 'Riconnessione auto attivata',
                'autoreconnect.disabled': 'Riconnessione auto disattivata',
                'autoreconnect.timeout': 'Timeout riconnessione auto',
                'plotter.enabled': 'Plotter attivato',
                'plotter.disabled': 'Plotter disattivato',
                'device.detected': 'Dispositivo rilevato',
                'device.restored': 'Dispositivo ripristinato, tentativo di riconnessione...',
                'device.disconnected': 'Dispositivo disconnesso',
                'device.waiting': 'In attesa di riconnessione dispositivo...',
                'device.reconnected': 'Riconnesso',
                'serial.port': 'Porta Seriale',
                'error.general': 'Errore',
                'error.no.port': 'Seleziona prima una porta',
                'error.connection': 'Errore di connessione',
                'error.read': 'Errore di lettura',
                'error.send': 'Errore di invio',
                'chart.reparsed': 'Dati grafico rianalizzati',
                'chart.default.group': 'Predefinito',
                'chart.btn.pause': 'Pausa',
                'chart.btn.resume': 'Riprendi',
                'chart.btn.smooth': 'Smooth',
                'chart.btn.clear': 'Cancella',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Sfondo',
                'chart.btn.map': 'Mappa',
                'chart.btn.chart': 'Grafico',
                'map.points': 'Punti traccia',
                'map.follow': 'Segui',
                'map.lock': 'Blocca',
                'chart.bgcolor.label': 'Colore sfondo',
                'error.solution.title': 'Soluzione:',
                'plotter.cleared': 'Tutti i grafici cancellati',
            },

            'es-ES': {
                // Header - Connection Panel
                'btn.selectPort': 'Seleccionar Puerto',
                'btn.selectPort.tip': 'Seleccionar un puerto serie',
                'baudRate.tip': 'Establecer velocidad en baudios (bps)',
                'autoReconnect.label': 'ReconexiÃ³n Auto',
                'autoReconnect.tip': 'Reconectar automÃ¡ticamente al desconectar',
                'btn.disconnect': 'Desconectar',
                'btn.disconnect.tip': 'Desconectar del puerto',
                'status.tip': 'Estado de conexiÃ³n',
                'status.disconnected': 'Desconectado',
                'status.connecting': 'Conectando...',
                'status.connected': 'Conectado',
                'lang.switch.tip': 'Cambiar idioma',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'Salida del Terminal',
                'terminal.mode.text.tip': 'Modo texto: Mostrar texto legible',
                'terminal.mode.hex.tip': 'Modo HEX: Mostrar valores hexadecimales',
                'terminal.echo.tip': 'Eco: Mostrar mensajes enviados',
                'terminal.timestamp.tip': 'Marca de tiempo: Mostrar hora del mensaje',
                'terminal.autoscroll.tip': 'Auto-desplazar al Ãºltimo mensaje',
                'input.history.title': 'Historial de Mensajes',
                'input.history.empty': 'Sin historial',
                'input.history.send.tip': 'Enviar directamente',
                'tab.plotter': 'Graficador',
                'tab.close': 'Cerrar',
                'plotter.toggle.tip': 'Activar/Desactivar grÃ¡ficos en tiempo real',
                'terminal.mode.text': 'TEXTO',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Borrar contenido del terminal',
                
                // Terminal Colors
                'terminal.color.tx': 'Entrada (TX)',
                'terminal.color.tx.tip': 'Color del texto de entrada (TX)',
                'terminal.color.rx': 'Salida (RX)',
                'terminal.color.rx.tip': 'Color del texto de salida (RX)',
                'terminal.color.sys': 'Mensaje del Sistema',
                'terminal.color.sys.tip': 'Color de mensajes del sistema',
                'terminal.color.reset': 'Restablecer predeterminado',
                
                'plotter.clear.tip': 'Borrar todos los grÃ¡ficos',
                'terminal.empty.title': 'Terminal Borrado',
                'terminal.empty.message': 'Esperando nuevos datos...',
                'input.placeholder': 'Escribe el mensaje a enviar, presiona Enter...',
                'input.send': 'Enviar',
                'input.send.tip': 'Enviar mensaje (Enter)',
                'input.history.tip': 'Mostrar historial de mensajes',
                'input.lineending.tip': 'Establecer carÃ¡cter de fin de lÃ­nea',
                'input.lineending.none': 'Sin fin de lÃ­nea',
                'input.lineending.none.tip': 'Sin carÃ¡cter de fin de lÃ­nea',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Salto de lÃ­nea',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Retorno de carro',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Bytes recibidos',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Bytes transmitidos',
                'stats.port.label': 'Puerto:',
                'stats.port.tip': 'Info del dispositivo',
                'stats.bytes': 'bytes',
                'msg.copied': 'Copiado',
                'color.picker.title': 'Seleccionar color',
                'btn.cancel': 'Cancelar',
                'btn.confirm': 'Confirmar',
                'browser.warning.title': 'El navegador no soporta Web Serial API',
                'manual.link': 'Manual',
                'manual.tip': 'Ver manual de usuario',
                'changelog.tip': 'Ver registro de cambios',
                'connection.waiting.title': 'Esperando conexiÃ³n',
                'connection.waiting.message': 'Haz clic en "Seleccionar Puerto" para elegir un dispositivo',
                'connection.disconnected': 'ConexiÃ³n desconectada',
                'connection.reconnect.tip': 'Para reconectar, haz clic en "Seleccionar Puerto"',
                'connection.selected': 'Seleccionado',
                'connection.port.selected': 'Puerto serie seleccionado',
                'connection.connected': 'Conectado',
                'autoreconnect.enabled': 'ReconexiÃ³n automÃ¡tica activada',
                'autoreconnect.disabled': 'ReconexiÃ³n automÃ¡tica desactivada',
                'autoreconnect.timeout': 'Tiempo de reconexiÃ³n agotado',
                'plotter.enabled': 'Graficador activado',
                'plotter.disabled': 'Graficador desactivado',
                'device.detected': 'Dispositivo detectado',
                'device.restored': 'Dispositivo restaurado, intentando reconexiÃ³n...',
                'device.disconnected': 'Dispositivo desconectado',
                'device.waiting': 'Esperando reconexiÃ³n del dispositivo...',
                'device.reconnected': 'Reconectado',
                'serial.port': 'Puerto Serie',
                'error.general': 'Error',
                'error.no.port': 'Por favor selecciona un puerto primero',
                'error.connection': 'Error de conexiÃ³n',
                'error.read': 'Error de lectura',
                'error.send': 'Error de envÃ­o',
                'chart.reparsed': 'Datos del grÃ¡fico reanalizados',
                'chart.default.group': 'Predeterminado',
                'chart.btn.pause': 'Pausar',
                'chart.btn.resume': 'Reanudar',
                'chart.btn.smooth': 'Suavizar',
                'chart.btn.clear': 'Borrar',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Fondo',
                'chart.btn.map': 'Mapa',
                'chart.btn.chart': 'GrÃ¡fico',
                'map.points': 'Puntos de ruta',
                'map.follow': 'Seguir',
                'map.lock': 'Bloquear',
                'chart.bgcolor.label': 'Color de fondo',
                'error.solution.title': 'SoluciÃ³n:',
                'plotter.cleared': 'Todos los grÃ¡ficos borrados',
            },

            'pt-PT': {
                // Header - Connection Panel
                'btn.selectPort': 'Selecionar Porta',
                'btn.selectPort.tip': 'Selecionar uma porta sÃ©rie',
                'baudRate.tip': 'Definir taxa de transmissÃ£o (bps)',
                'autoReconnect.label': 'ReconexÃ£o Auto',
                'autoReconnect.tip': 'Reconectar automaticamente ao desconectar',
                'btn.disconnect': 'Desconectar',
                'btn.disconnect.tip': 'Desconectar da porta',
                'status.tip': 'Estado da conexÃ£o',
                'status.disconnected': 'Desconectado',
                'status.connecting': 'Conectando...',
                'status.connected': 'Conectado',
                'lang.switch.tip': 'Mudar idioma',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'SaÃ­da do Terminal',
                'terminal.mode.text.tip': 'Modo texto: Mostrar texto legÃ­vel',
                'terminal.mode.hex.tip': 'Modo HEX: Mostrar valores hexadecimais',
                'terminal.echo.tip': 'Eco: Mostrar mensagens enviadas',
                'terminal.timestamp.tip': 'Timestamp: Mostrar hora da mensagem',
                'terminal.autoscroll.tip': 'Auto-scroll para a Ãºltima mensagem',
                'input.history.title': 'HistÃ³rico de Mensagens',
                'input.history.empty': 'Sem histÃ³rico',
                'input.history.send.tip': 'Enviar diretamente',
                'tab.plotter': 'Plotter',
                'tab.close': 'Fechar',
                'plotter.toggle.tip': 'Ativar/Desativar plotting em tempo real',
                'terminal.mode.text': 'TEXTO',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Limpar conteÃºdo do terminal',
                
                // Terminal Colors
                'terminal.color.tx': 'Entrada (TX)',
                'terminal.color.tx.tip': 'Cor do texto de entrada (TX)',
                'terminal.color.rx': 'SaÃ­da (RX)',
                'terminal.color.rx.tip': 'Cor do texto de saÃ­da (RX)',
                'terminal.color.sys': 'Mensagem do Sistema',
                'terminal.color.sys.tip': 'Cor das mensagens do sistema',
                'terminal.color.reset': 'Restaurar padrÃ£o',
                
                'plotter.clear.tip': 'Limpar todos os grÃ¡ficos',
                'terminal.empty.title': 'Terminal Limpo',
                'terminal.empty.message': 'Aguardando novos dados...',
                'input.placeholder': 'Digite a mensagem para enviar, pressione Enter...',
                'input.send': 'Enviar',
                'input.send.tip': 'Enviar mensagem (Enter)',
                'input.history.tip': 'Mostrar histÃ³rico de mensagens',
                'input.lineending.tip': 'Definir caractere de fim de linha',
                'input.lineending.none': 'Sem fim de linha',
                'input.lineending.none.tip': 'Sem caractere de fim de linha',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Line Feed',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Carriage Return',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Bytes recebidos',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Bytes transmitidos',
                'stats.port.label': 'Porta:',
                'stats.port.tip': 'Info do dispositivo',
                'stats.bytes': 'bytes',
                'msg.copied': 'Copiado',
                'color.picker.title': 'Selecionar cor',
                'btn.cancel': 'Cancelar',
                'btn.confirm': 'Confirmar',
                'browser.warning.title': 'O navegador nÃ£o suporta Web Serial API',
                'manual.link': 'Manual',
                'manual.tip': 'Ver manual do utilizador',
                'changelog.tip': 'Ver registo de alteraÃ§Ãµes',
                'connection.waiting.title': 'Aguardando conexÃ£o',
                'connection.waiting.message': 'Clique em "Selecionar Porta" para escolher um dispositivo',
                'connection.disconnected': 'ConexÃ£o desconectada',
                'connection.reconnect.tip': 'Para reconectar, clique em "Selecionar Porta"',
                'connection.selected': 'Selecionado',
                'connection.port.selected': 'Porta sÃ©rie selecionada',
                'connection.connected': 'Conectado',
                'autoreconnect.enabled': 'ReconexÃ£o automÃ¡tica ativada',
                'autoreconnect.disabled': 'ReconexÃ£o automÃ¡tica desativada',
                'autoreconnect.timeout': 'Tempo de reconexÃ£o esgotado',
                'plotter.enabled': 'Plotter ativado',
                'plotter.disabled': 'Plotter desativado',
                'device.detected': 'Dispositivo detetado',
                'device.restored': 'Dispositivo restaurado, tentando reconexÃ£o...',
                'device.disconnected': 'Dispositivo desconectado',
                'device.waiting': 'Aguardando reconexÃ£o do dispositivo...',
                'device.reconnected': 'Reconectado',
                'serial.port': 'Porta SÃ©rie',
                'error.general': 'Erro',
                'error.no.port': 'Por favor selecione uma porta primeiro',
                'error.connection': 'Erro de conexÃ£o',
                'error.read': 'Erro de leitura',
                'error.send': 'Erro de envio',
                'chart.reparsed': 'Dados do grÃ¡fico reanalisados',
                'chart.default.group': 'PadrÃ£o',
                'chart.btn.pause': 'Pausar',
                'chart.btn.resume': 'Retomar',
                'chart.btn.smooth': 'Suavizar',
                'chart.btn.clear': 'Limpar',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Fundo',
                'chart.btn.map': 'Mapa',
                'chart.btn.chart': 'GrÃ¡fico',
                'map.points': 'Pontos de trajeto',
                'map.follow': 'Seguir',
                'map.lock': 'Bloquear',
                'chart.bgcolor.label': 'Cor de fundo',
                'error.solution.title': 'SoluÃ§Ã£o:',
                'plotter.cleared': 'Todos os grÃ¡ficos limpos',
            },

            'tr-TR': {
                // Header - Connection Panel
                'btn.selectPort': 'Port SeÃ§',
                'btn.selectPort.tip': 'Bir seri port seÃ§in',
                'baudRate.tip': 'Baud hÄ±zÄ±nÄ± ayarla (bps)',
                'autoReconnect.label': 'Otomatik BaÄŸlan',
                'autoReconnect.tip': 'BaÄŸlantÄ± kesildiÄŸinde otomatik yeniden baÄŸlan',
                'btn.disconnect': 'BaÄŸlantÄ±yÄ± Kes',
                'btn.disconnect.tip': 'Porttan baÄŸlantÄ±yÄ± kes',
                'status.tip': 'BaÄŸlantÄ± durumu',
                'status.disconnected': 'BaÄŸlÄ± DeÄŸil',
                'status.connecting': 'BaÄŸlanÄ±yor...',
                'status.connected': 'BaÄŸlÄ±',
                'lang.switch.tip': 'Dil deÄŸiÅŸtir',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'Terminal Ã‡Ä±kÄ±ÅŸÄ±',
                'terminal.mode.text.tip': 'Metin modu: Okunabilir metin gÃ¶ster',
                'terminal.mode.hex.tip': 'HEX modu: OnaltÄ±lÄ±k deÄŸerleri gÃ¶ster',
                'terminal.echo.tip': 'Eko: GÃ¶nderilen mesajlarÄ± gÃ¶ster',
                'terminal.timestamp.tip': 'Zaman damgasÄ±: Mesaj zamanÄ±nÄ± gÃ¶ster',
                'terminal.autoscroll.tip': 'Son mesaja otomatik kaydÄ±r',
                'input.history.title': 'Mesaj GeÃ§miÅŸi',
                'input.history.empty': 'GeÃ§miÅŸ yok',
                'input.history.send.tip': 'DoÄŸrudan gÃ¶nder',
                'tab.plotter': 'Ã‡izici',
                'tab.close': 'Kapat',
                'plotter.toggle.tip': 'GerÃ§ek zamanlÄ± Ã§izimi aÃ§/kapat',
                'terminal.mode.text': 'METÄ°N',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Terminal iÃ§eriÄŸini temizle',
                
                // Terminal Colors
                'terminal.color.tx': 'GiriÅŸ (TX)',
                'terminal.color.tx.tip': 'GiriÅŸ metin rengi (TX)',
                'terminal.color.rx': 'Ã‡Ä±kÄ±ÅŸ (RX)',
                'terminal.color.rx.tip': 'Ã‡Ä±kÄ±ÅŸ metin rengi (RX)',
                'terminal.color.sys': 'Sistem MesajÄ±',
                'terminal.color.sys.tip': 'Sistem mesajÄ± rengi',
                'terminal.color.reset': 'VarsayÄ±lana sÄ±fÄ±rla',
                
                'plotter.clear.tip': 'TÃ¼m grafikleri temizle',
                'terminal.empty.title': 'Terminal Temizlendi',
                'terminal.empty.message': 'Yeni veri bekleniyor...',
                'input.placeholder': 'GÃ¶nderilecek mesajÄ± yazÄ±n, Enter\'a basÄ±n...',
                'input.send': 'GÃ¶nder',
                'input.send.tip': 'Mesaj gÃ¶nder (Enter)',
                'input.history.tip': 'Mesaj geÃ§miÅŸini gÃ¶ster',
                'input.lineending.tip': 'SatÄ±r sonu karakterini ayarla',
                'input.lineending.none': 'SatÄ±r sonu yok',
                'input.lineending.none.tip': 'SatÄ±r sonu karakteri yok',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'SatÄ±r besleme',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'SatÄ±r baÅŸÄ±',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'AlÄ±nan baytlar',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'GÃ¶nderilen baytlar',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'Cihaz bilgisi',
                'stats.bytes': 'bayt',
                'msg.copied': 'KopyalandÄ±',
                'color.picker.title': 'Renk seÃ§',
                'btn.cancel': 'Ä°ptal',
                'btn.confirm': 'Onayla',
                'browser.warning.title': 'TarayÄ±cÄ± Web Serial API\'yi desteklemiyor',
                'manual.link': 'KÄ±lavuz',
                'manual.tip': 'KullanÄ±m kÄ±lavuzunu gÃ¶rÃ¼ntÃ¼le',
                'changelog.tip': 'DeÄŸiÅŸiklik gÃ¼nlÃ¼ÄŸÃ¼nÃ¼ gÃ¶rÃ¼ntÃ¼le',
                'connection.waiting.title': 'BaÄŸlantÄ± bekleniyor',
                'connection.waiting.message': 'Bir cihaz seÃ§mek iÃ§in "Port SeÃ§"e tÄ±klayÄ±n',
                'connection.disconnected': 'BaÄŸlantÄ± kesildi',
                'connection.reconnect.tip': 'Yeniden baÄŸlanmak iÃ§in "Port SeÃ§"e tÄ±klayÄ±n',
                'connection.selected': 'SeÃ§ildi',
                'connection.port.selected': 'Seri port seÃ§ildi',
                'connection.connected': 'BaÄŸlÄ±',
                'autoreconnect.enabled': 'Otomatik baÄŸlantÄ± etkinleÅŸtirildi',
                'autoreconnect.disabled': 'Otomatik baÄŸlantÄ± devre dÄ±ÅŸÄ±',
                'autoreconnect.timeout': 'Otomatik baÄŸlantÄ± zaman aÅŸÄ±mÄ±',
                'plotter.enabled': 'Ã‡izici etkinleÅŸtirildi',
                'plotter.disabled': 'Ã‡izici devre dÄ±ÅŸÄ±',
                'device.detected': 'Cihaz algÄ±landÄ±',
                'device.restored': 'Cihaz geri yÃ¼klendi, yeniden baÄŸlanÄ±lÄ±yor...',
                'device.disconnected': 'Cihaz baÄŸlantÄ±sÄ± kesildi',
                'device.waiting': 'Cihaz yeniden baÄŸlantÄ±sÄ± bekleniyor...',
                'device.reconnected': 'Yeniden baÄŸlandÄ±',
                'serial.port': 'Seri Port',
                'error.general': 'Hata',
                'error.no.port': 'LÃ¼tfen Ã¶nce bir port seÃ§in',
                'error.connection': 'BaÄŸlantÄ± hatasÄ±',
                'error.read': 'Okuma hatasÄ±',
                'error.send': 'GÃ¶nderme hatasÄ±',
                'chart.reparsed': 'Grafik verileri yeniden ayrÄ±ÅŸtÄ±rÄ±ldÄ±',
                'chart.default.group': 'VarsayÄ±lan',
                'chart.btn.pause': 'Duraklat',
                'chart.btn.resume': 'Devam',
                'chart.btn.smooth': 'YumuÅŸat',
                'chart.btn.clear': 'Temizle',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Arka Plan',
                'chart.btn.map': 'Harita',
                'chart.btn.chart': 'Grafik',
                'map.points': 'Ä°z noktalarÄ±',
                'map.follow': 'Takip',
                'map.lock': 'Kilitle',
                'chart.bgcolor.label': 'Arka plan rengi',
                'error.solution.title': 'Ã‡Ã¶zÃ¼m:',
                'plotter.cleared': 'TÃ¼m grafikler temizlendi',
            },

            'ar-SA': {
                // Header - Connection Panel
                'btn.selectPort': 'Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ÙØ°',
                'btn.selectPort.tip': 'Ø§Ø®ØªØ± Ù…Ù†ÙØ° ØªØ³Ù„Ø³Ù„ÙŠ Ù„Ù„Ø§ØªØµØ§Ù„',
                'baudRate.tip': 'ØªØ¹ÙŠÙŠÙ† Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø¨Ø§ÙˆØ¯ (bps)',
                'autoReconnect.label': 'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ',
                'autoReconnect.tip': 'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù†Ø¯ Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„',
                'btn.disconnect': 'Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„',
                'btn.disconnect.tip': 'Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ù† Ø§Ù„Ù…Ù†ÙØ°',
                'status.tip': 'Ø­Ø§Ù„Ø© Ø§Ù„Ø§ØªØµØ§Ù„',
                'status.disconnected': 'ØºÙŠØ± Ù…ØªØµÙ„',
                'status.connecting': 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„...',
                'status.connected': 'Ù…ØªØµÙ„',
                'lang.switch.tip': 'ØªØºÙŠÙŠØ± Ø§Ù„Ù„ØºØ©',
                'tab.terminal': 'Ø§Ù„Ø·Ø±ÙÙŠØ©',
                'terminal.output.title': 'Ù…Ø®Ø±Ø¬Ø§Øª Ø§Ù„Ø·Ø±ÙÙŠØ©',
                'terminal.mode.text.tip': 'ÙˆØ¶Ø¹ Ø§Ù„Ù†Øµ: Ø¹Ø±Ø¶ Ù†Øµ Ù‚Ø§Ø¨Ù„ Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©',
                'terminal.mode.hex.tip': 'ÙˆØ¶Ø¹ HEX: Ø¹Ø±Ø¶ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø³Øª Ø¹Ø´Ø±ÙŠØ©',
                'terminal.echo.tip': 'Ø§Ù„ØµØ¯Ù‰: Ø¹Ø±Ø¶ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù…Ø±Ø³Ù„Ø©',
                'terminal.timestamp.tip': 'Ø§Ù„Ø·Ø§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠ: Ø¹Ø±Ø¶ ÙˆÙ‚Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø©',
                'terminal.autoscroll.tip': 'Ø§Ù„ØªÙ…Ø±ÙŠØ± Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ø¢Ø®Ø± Ø±Ø³Ø§Ù„Ø©',
                'input.history.title': 'Ø³Ø¬Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„',
                'input.history.empty': 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø³Ø¬Ù„',
                'input.history.send.tip': 'Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¨Ø§Ø´Ø±',
                'tab.plotter': 'Ø§Ù„Ø±Ø§Ø³Ù…',
                'tab.close': 'Ø¥ØºÙ„Ø§Ù‚',
                'plotter.toggle.tip': 'ØªÙØ¹ÙŠÙ„/ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø±Ø³Ù… ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ',
                'terminal.mode.text': 'Ù†Øµ',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Ù…Ø³Ø­ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø·Ø±ÙÙŠØ©',
                
                // Terminal Colors
                'terminal.color.tx': 'Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ (TX)',
                'terminal.color.tx.tip': 'Ù„ÙˆÙ† Ù†Øµ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ (TX)',
                'terminal.color.rx': 'Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (RX)',
                'terminal.color.rx.tip': 'Ù„ÙˆÙ† Ù†Øµ Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (RX)',
                'terminal.color.sys': 'Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù†Ø¸Ø§Ù…',
                'terminal.color.sys.tip': 'Ù„ÙˆÙ† Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†Ø¸Ø§Ù…',
                'terminal.color.reset': 'Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ',
                
                'plotter.clear.tip': 'Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©',
                'terminal.empty.title': 'ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø·Ø±ÙÙŠØ©',
                'terminal.empty.message': 'ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©...',
                'input.placeholder': 'Ø§ÙƒØªØ¨ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ø¥Ø±Ø³Ø§Ù„ØŒ Ø§Ø¶ØºØ· Enter...',
                'input.send': 'Ø¥Ø±Ø³Ø§Ù„',
                'input.send.tip': 'Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© (Enter)',
                'input.history.tip': 'Ø¹Ø±Ø¶ Ø³Ø¬Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„',
                'input.lineending.tip': 'ØªØ¹ÙŠÙŠÙ† Ø­Ø±Ù Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø³Ø·Ø±',
                'input.lineending.none': 'Ø¨Ø¯ÙˆÙ† Ù†Ù‡Ø§ÙŠØ© Ø³Ø·Ø±',
                'input.lineending.none.tip': 'Ø¨Ø¯ÙˆÙ† Ø­Ø±Ù Ù†Ù‡Ø§ÙŠØ© Ø³Ø·Ø±',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'ØªØºØ°ÙŠØ© Ø§Ù„Ø³Ø·Ø±',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…Ø¤Ø´Ø±',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª Ø§Ù„Ù…Ø³ØªÙ„Ù…Ø©',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Ø§Ù„Ø¨Ø§ÙŠØªØ§Øª Ø§Ù„Ù…Ø±Ø³Ù„Ø©',
                'stats.port.label': 'Ø§Ù„Ù…Ù†ÙØ°:',
                'stats.port.tip': 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²',
                'stats.bytes': 'Ø¨Ø§ÙŠØª',
                'msg.copied': 'ØªÙ… Ø§Ù„Ù†Ø³Ø®',
                'color.picker.title': 'Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ÙˆÙ†',
                'btn.cancel': 'Ø¥Ù„ØºØ§Ø¡',
                'btn.confirm': 'ØªØ£ÙƒÙŠØ¯',
                'browser.warning.title': 'Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… Web Serial API',
                'manual.link': 'Ø§Ù„Ø¯Ù„ÙŠÙ„',
                'manual.tip': 'Ø¹Ø±Ø¶ Ø¯Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…',
                'changelog.tip': 'Ø¹Ø±Ø¶ Ø³Ø¬Ù„ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª',
                'connection.waiting.title': 'ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„',
                'connection.waiting.message': 'Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ "Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ÙØ°" Ù„Ø§Ø®ØªÙŠØ§Ø± Ø¬Ù‡Ø§Ø²',
                'connection.disconnected': 'ØªÙ… Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„',
                'connection.reconnect.tip': 'Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ØŒ Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ "Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ÙØ°"',
                'connection.selected': 'Ù…Ø­Ø¯Ø¯',
                'connection.port.selected': 'ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ù†ÙØ° Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠ',
                'connection.connected': 'Ù…ØªØµÙ„',
                'autoreconnect.enabled': 'ØªÙ… ØªÙØ¹ÙŠÙ„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ',
                'autoreconnect.disabled': 'ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ',
                'autoreconnect.timeout': 'Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ',
                'plotter.enabled': 'ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø±Ø§Ø³Ù…',
                'plotter.disabled': 'ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø±Ø§Ø³Ù…',
                'device.detected': 'ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø¬Ù‡Ø§Ø²',
                'device.restored': 'ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù‡Ø§Ø²ØŒ Ø¬Ø§Ø±ÙŠ Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„...',
                'device.disconnected': 'ØªÙ… Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„ Ø§Ù„Ø¬Ù‡Ø§Ø²',
                'device.waiting': 'ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¹Ø§Ø¯Ø© Ø§ØªØµØ§Ù„ Ø§Ù„Ø¬Ù‡Ø§Ø²...',
                'device.reconnected': 'ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø§ØªØµØ§Ù„',
                'serial.port': 'Ø§Ù„Ù…Ù†ÙØ° Ø§Ù„ØªØ³Ù„Ø³Ù„ÙŠ',
                'error.general': 'Ø®Ø·Ø£',
                'error.no.port': 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù†ÙØ° Ø£ÙˆÙ„Ø§Ù‹',
                'error.connection': 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„',
                'error.read': 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©',
                'error.send': 'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„',
                'chart.reparsed': 'ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù„ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠ',
                'chart.default.group': 'Ø§ÙØªØ±Ø§Ø¶ÙŠ',
                'chart.btn.pause': 'Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª',
                'chart.btn.resume': 'Ø§Ø³ØªØ¦Ù†Ø§Ù',
                'chart.btn.smooth': 'ØªÙ†Ø¹ÙŠÙ…',
                'chart.btn.clear': 'Ù…Ø³Ø­',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Ø§Ù„Ø®Ù„ÙÙŠØ©',
                'chart.btn.map': 'Ø®Ø±ÙŠØ·Ø©',
                'chart.btn.chart': 'Ø±Ø³Ù… Ø¨ÙŠØ§Ù†ÙŠ',
                'map.points': 'Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø±',
                'map.follow': 'Ù…ØªØ§Ø¨Ø¹Ø©',
                'map.lock': 'Ù‚ÙÙ„',
                'chart.bgcolor.label': 'Ù„ÙˆÙ† Ø§Ù„Ø®Ù„ÙÙŠØ©',
                'error.solution.title': 'Ø§Ù„Ø­Ù„:',
                'plotter.cleared': 'ØªÙ… Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ø¨ÙŠØ§Ù†ÙŠØ©',
            },

            'he-IL': {
                // Header - Connection Panel
                'btn.selectPort': '×‘×—×¨ ×¤×•×¨×˜',
                'btn.selectPort.tip': '×‘×—×¨ ×¤×•×¨×˜ ×˜×•×¨×™ ×œ×”×ª×—×‘×¨×•×ª',
                'baudRate.tip': '×”×’×“×¨ ×§×¦×‘ ×©×™×“×•×¨ (bps)',
                'autoReconnect.label': '×—×™×‘×•×¨ ××—×“×© ××•×˜×•××˜×™',
                'autoReconnect.tip': '×”×ª×—×‘×¨ ××—×“×© ××•×˜×•××˜×™×ª ×›××©×¨ ×× ×•×ª×§',
                'btn.disconnect': '× ×ª×§',
                'btn.disconnect.tip': '× ×ª×§ ××”×¤×•×¨×˜',
                'status.tip': '××¦×‘ ×—×™×‘×•×¨',
                'status.disconnected': '×× ×•×ª×§',
                'status.connecting': '××ª×—×‘×¨...',
                'status.connected': '××—×•×‘×¨',
                'lang.switch.tip': '×”×—×œ×£ ×©×¤×”',
                'tab.terminal': '××¡×•×£',
                'terminal.output.title': '×¤×œ×˜ ×”××¡×•×£',
                'terminal.mode.text.tip': '××¦×‘ ×˜×§×¡×˜: ×”×¦×’ ×˜×§×¡×˜ ×§×¨×™×',
                'terminal.mode.hex.tip': '××¦×‘ HEX: ×”×¦×’ ×¢×¨×›×™× ×”×§×¡×“×¦×™××œ×™×™×',
                'terminal.echo.tip': '×”×“: ×”×¦×’ ×”×•×“×¢×•×ª ×©× ×©×œ×—×•',
                'terminal.timestamp.tip': '×—×•×ª××ª ×–××Ÿ: ×”×¦×’ ×–××Ÿ ×”×”×•×“×¢×”',
                'terminal.autoscroll.tip': '×’×œ×™×œ×” ××•×˜×•××˜×™×ª ×œ×”×•×“×¢×” ×”××—×¨×•× ×”',
                'input.history.title': '×”×™×¡×˜×•×¨×™×™×ª ×”×•×“×¢×•×ª',
                'input.history.empty': '××™×Ÿ ×”×™×¡×˜×•×¨×™×”',
                'input.history.send.tip': '×©×œ×— ×™×©×™×¨×•×ª',
                'tab.plotter': '××ª×•×•×”',
                'tab.close': '×¡×’×•×¨',
                'plotter.toggle.tip': '×”×¤×¢×œ/×›×‘×” ×ª×¨×©×™× ×‘×–××Ÿ ×××ª',
                'terminal.mode.text': '×˜×§×¡×˜',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': '× ×§×” ×ª×•×›×Ÿ ×”××¡×•×£',
                
                // Terminal Colors
                'terminal.color.tx': '×§×œ×˜ (TX)',
                'terminal.color.tx.tip': '×¦×‘×¢ ×˜×§×¡×˜ ×§×œ×˜ (TX)',
                'terminal.color.rx': '×¤×œ×˜ (RX)',
                'terminal.color.rx.tip': '×¦×‘×¢ ×˜×§×¡×˜ ×¤×œ×˜ (RX)',
                'terminal.color.sys': '×”×•×“×¢×ª ××¢×¨×›×ª',
                'terminal.color.sys.tip': '×¦×‘×¢ ×”×•×“×¢×•×ª ××¢×¨×›×ª',
                'terminal.color.reset': '××™×¤×•×¡ ×œ×‘×¨×™×¨×ª ××—×“×œ',
                
                'plotter.clear.tip': '× ×§×” ××ª ×›×œ ×”×ª×¨×©×™××™×',
                'terminal.empty.title': '×”××¡×•×£ × ×•×§×”',
                'terminal.empty.message': '×××ª×™×Ÿ ×œ× ×ª×•× ×™× ×—×“×©×™×...',
                'input.placeholder': '×”×§×œ×“ ×”×•×“×¢×” ×œ×©×œ×™×—×”, ×œ×—×¥ Enter...',
                'input.send': '×©×œ×—',
                'input.send.tip': '×©×œ×— ×”×•×“×¢×” (Enter)',
                'input.history.tip': '×”×¦×’ ×”×™×¡×˜×•×¨×™×™×ª ×”×•×“×¢×•×ª',
                'input.lineending.tip': '×”×’×“×¨ ×ª×• ×¡×•×£ ×©×•×¨×”',
                'input.lineending.none': '×œ×œ× ×¡×•×£ ×©×•×¨×”',
                'input.lineending.none.tip': '×œ×œ× ×ª×• ×¡×•×£ ×©×•×¨×”',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': '×”×–× ×ª ×©×•×¨×”',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': '×—×–×¨×ª ×’×¨×¨×”',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': '×‘×ª×™× ×©×”×ª×§×‘×œ×•',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': '×‘×ª×™× ×©× ×©×œ×—×•',
                'stats.port.label': '×¤×•×¨×˜:',
                'stats.port.tip': '××™×“×¢ ×¢×œ ×”××›×©×™×¨',
                'stats.bytes': '×‘×ª×™×',
                'msg.copied': '×”×•×¢×ª×§',
                'color.picker.title': '×‘×—×¨ ×¦×‘×¢',
                'btn.cancel': '×‘×™×˜×•×œ',
                'btn.confirm': '××™×©×•×¨',
                'browser.warning.title': '×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘-Web Serial API',
                'manual.link': '××“×¨×™×š',
                'manual.tip': '×”×¦×’ ××“×¨×™×š ×œ××©×ª××©',
                'changelog.tip': '×”×¦×’ ×™×•××Ÿ ×©×™× ×•×™×™×',
                'connection.waiting.title': '×××ª×™×Ÿ ×œ×—×™×‘×•×¨',
                'connection.waiting.message': '×œ×—×¥ ×¢×œ "×‘×—×¨ ×¤×•×¨×˜" ×›×“×™ ×œ×‘×—×•×¨ ××›×©×™×¨',
                'connection.disconnected': '×”×—×™×‘×•×¨ × ×•×ª×§',
                'connection.reconnect.tip': '×œ×”×ª×—×‘×¨×•×ª ××—×“×©, ×œ×—×¥ ×¢×œ "×‘×—×¨ ×¤×•×¨×˜"',
                'connection.selected': '× ×‘×—×¨',
                'connection.port.selected': '× ×‘×—×¨ ×¤×•×¨×˜ ×˜×•×¨×™',
                'connection.connected': '××—×•×‘×¨',
                'autoreconnect.enabled': '×—×™×‘×•×¨ ××—×“×© ××•×˜×•××˜×™ ××•×¤×¢×œ',
                'autoreconnect.disabled': '×—×™×‘×•×¨ ××—×“×© ××•×˜×•××˜×™ ××•×©×‘×ª',
                'autoreconnect.timeout': '×¤×¡×§ ×–××Ÿ ×œ×—×™×‘×•×¨ ××—×“×© ××•×˜×•××˜×™',
                'plotter.enabled': '×”××ª×•×•×” ××•×¤×¢×œ',
                'plotter.disabled': '×”××ª×•×•×” ××•×©×‘×ª',
                'device.detected': '×–×•×”×” ××›×©×™×¨',
                'device.restored': '×”××›×©×™×¨ ×©×•×—×–×¨, ×× ×¡×” ×œ×”×ª×—×‘×¨ ××—×“×©...',
                'device.disconnected': '×”××›×©×™×¨ × ×•×ª×§',
                'device.waiting': '×××ª×™×Ÿ ×œ×—×™×‘×•×¨ ××—×“×© ×©×œ ×”××›×©×™×¨...',
                'device.reconnected': '××—×•×‘×¨ ××—×“×©',
                'serial.port': '×¤×•×¨×˜ ×˜×•×¨×™',
                'error.general': '×©×’×™××”',
                'error.no.port': '×× × ×‘×—×¨ ×¤×•×¨×˜ ×ª×—×™×œ×”',
                'error.connection': '×©×’×™××ª ×—×™×‘×•×¨',
                'error.read': '×©×’×™××ª ×§×¨×™××”',
                'error.send': '×©×’×™××ª ×©×œ×™×—×”',
                'chart.reparsed': '× ×ª×•× ×™ ×”×ª×¨×©×™× × ×•×ª×—×• ××—×“×©',
                'chart.default.group': '×‘×¨×™×¨×ª ××—×“×œ',
                'chart.btn.pause': '×”×©×”×”',
                'chart.btn.resume': '×”××©×š',
                'chart.btn.smooth': '×”×—×œ×§×”',
                'chart.btn.clear': '× ×§×”',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': '×¨×§×¢',
                'chart.btn.map': '××¤×”',
                'chart.btn.chart': '×ª×¨×©×™×',
                'map.points': '× ×§×•×“×•×ª ××¡×œ×•×œ',
                'map.follow': '×¢×§×•×‘',
                'map.lock': '× ×¢×•×œ',
                'chart.bgcolor.label': '×¦×‘×¢ ×¨×§×¢',
                'error.solution.title': '×¤×ª×¨×•×Ÿ:',
                'plotter.cleared': '×›×œ ×”×ª×¨×©×™××™× × ×•×§×•',
            },

            'fa-IR': {
                // Header - Connection Panel
                'btn.selectPort': 'Ø§Ù†ØªØ®Ø§Ø¨ Ù¾ÙˆØ±Øª',
                'btn.selectPort.tip': 'ÛŒÚ© Ù¾ÙˆØ±Øª Ø³Ø±ÛŒØ§Ù„ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯',
                'baudRate.tip': 'ØªÙ†Ø¸ÛŒÙ… Ù†Ø±Ø® Ø¨Ø§ÙˆØ¯ (bps)',
                'autoReconnect.label': 'Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø±',
                'autoReconnect.tip': 'Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ù‡Ù†Ú¯Ø§Ù… Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„',
                'btn.disconnect': 'Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„',
                'btn.disconnect.tip': 'Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„ Ø§Ø² Ù¾ÙˆØ±Øª',
                'status.tip': 'ÙˆØ¶Ø¹ÛŒØª Ø§ØªØµØ§Ù„',
                'status.disconnected': 'Ù‚Ø·Ø¹ Ø´Ø¯Ù‡',
                'status.connecting': 'Ø¯Ø± Ø­Ø§Ù„ Ø§ØªØµØ§Ù„...',
                'status.connected': 'Ù…ØªØµÙ„',
                'lang.switch.tip': 'ØªØºÛŒÛŒØ± Ø²Ø¨Ø§Ù†',
                'tab.terminal': 'ØªØ±Ù…ÛŒÙ†Ø§Ù„',
                'terminal.output.title': 'Ø®Ø±ÙˆØ¬ÛŒ ØªØ±Ù…ÛŒÙ†Ø§Ù„',
                'terminal.mode.text.tip': 'Ø­Ø§Ù„Øª Ù…ØªÙ†: Ù†Ù…Ø§ÛŒØ´ Ù…ØªÙ† Ø®ÙˆØ§Ù†Ø§',
                'terminal.mode.hex.tip': 'Ø­Ø§Ù„Øª HEX: Ù†Ù…Ø§ÛŒØ´ Ù…Ù‚Ø§Ø¯ÛŒØ± Ø´Ø§Ù†Ø²Ø¯Ù‡â€ŒØ´Ø§Ù†Ø²Ø¯Ù‡ÛŒ',
                'terminal.echo.tip': 'Ø§Ú©Ùˆ: Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù‡',
                'terminal.timestamp.tip': 'Ø¨Ø±Ú†Ø³Ø¨ Ø²Ù…Ø§Ù†: Ù†Ù…Ø§ÛŒØ´ Ø²Ù…Ø§Ù† Ù¾ÛŒØ§Ù…',
                'terminal.autoscroll.tip': 'Ù¾ÛŒÙ…Ø§ÛŒØ´ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ù‡ Ø¢Ø®Ø±ÛŒÙ† Ù¾ÛŒØ§Ù…',
                'input.history.title': 'ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§',
                'input.history.empty': 'Ø¨Ø¯ÙˆÙ† ØªØ§Ø±ÛŒØ®Ú†Ù‡',
                'input.history.send.tip': 'Ø§Ø±Ø³Ø§Ù„ Ù…Ø³ØªÙ‚ÛŒÙ…',
                'tab.plotter': 'Ø±Ø³Ø§Ù…',
                'tab.close': 'Ø¨Ø³ØªÙ†',
                'plotter.toggle.tip': 'ÙØ¹Ø§Ù„/ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø±Ø³Ù… Ø¨Ù„Ø§Ø¯Ø±Ù†Ú¯',
                'terminal.mode.text': 'Ù…ØªÙ†',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù…Ø­ØªÙˆØ§ÛŒ ØªØ±Ù…ÛŒÙ†Ø§Ù„',
                
                // Terminal Colors
                'terminal.color.tx': 'ÙˆØ±ÙˆØ¯ÛŒ (TX)',
                'terminal.color.tx.tip': 'Ø±Ù†Ú¯ Ù…ØªÙ† ÙˆØ±ÙˆØ¯ÛŒ (TX)',
                'terminal.color.rx': 'Ø®Ø±ÙˆØ¬ÛŒ (RX)',
                'terminal.color.rx.tip': 'Ø±Ù†Ú¯ Ù…ØªÙ† Ø®Ø±ÙˆØ¬ÛŒ (RX)',
                'terminal.color.sys': 'Ù¾ÛŒØ§Ù… Ø³ÛŒØ³ØªÙ…',
                'terminal.color.sys.tip': 'Ø±Ù†Ú¯ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…',
                'terminal.color.reset': 'Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø¨Ù‡ Ù¾ÛŒØ´â€ŒÙØ±Ø¶',
                
                'plotter.clear.tip': 'Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† ØªÙ…Ø§Ù… Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§',
                'terminal.empty.title': 'ØªØ±Ù…ÛŒÙ†Ø§Ù„ Ù¾Ø§Ú© Ø´Ø¯',
                'terminal.empty.message': 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯...',
                'input.placeholder': 'Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ Ø±Ø§ ØªØ§ÛŒÙ¾ Ú©Ù†ÛŒØ¯ØŒ Enter Ø±Ø§ ÙØ´Ø§Ø± Ø¯Ù‡ÛŒØ¯...',
                'input.send': 'Ø§Ø±Ø³Ø§Ù„',
                'input.send.tip': 'Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… (Enter)',
                'input.history.tip': 'Ù†Ù…Ø§ÛŒØ´ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§',
                'input.lineending.tip': 'ØªÙ†Ø¸ÛŒÙ… Ú©Ø§Ø±Ø§Ú©ØªØ± Ø§Ù†ØªÙ‡Ø§ÛŒ Ø®Ø·',
                'input.lineending.none': 'Ø¨Ø¯ÙˆÙ† Ø§Ù†ØªÙ‡Ø§ÛŒ Ø®Ø·',
                'input.lineending.none.tip': 'Ø¨Ø¯ÙˆÙ† Ú©Ø§Ø±Ø§Ú©ØªØ± Ø§Ù†ØªÙ‡Ø§ÛŒ Ø®Ø·',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'ØªØºØ°ÛŒÙ‡ Ø®Ø·',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Ø¨Ø±Ú¯Ø´Øª Ú©Ø§Ù„Ø³Ú©Ù‡',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Ø¨Ø§ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØªÛŒ',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Ø¨Ø§ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ÛŒ',
                'stats.port.label': 'Ù¾ÙˆØ±Øª:',
                'stats.port.tip': 'Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ø³ØªÚ¯Ø§Ù‡',
                'stats.bytes': 'Ø¨Ø§ÛŒØª',
                'msg.copied': 'Ú©Ù¾ÛŒ Ø´Ø¯',
                'color.picker.title': 'Ø§Ù†ØªØ®Ø§Ø¨ Ø±Ù†Ú¯',
                'btn.cancel': 'Ù„ØºÙˆ',
                'btn.confirm': 'ØªØ§ÛŒÛŒØ¯',
                'browser.warning.title': 'Ù…Ø±ÙˆØ±Ú¯Ø± Ø§Ø² Web Serial API Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯',
                'manual.link': 'Ø±Ø§Ù‡Ù†Ù…Ø§',
                'manual.tip': 'Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±',
                'changelog.tip': 'Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú¯Ø²Ø§Ø±Ø´ ØªØºÛŒÛŒØ±Ø§Øª',
                'connection.waiting.title': 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø§ØªØµØ§Ù„',
                'connection.waiting.message': 'Ø±ÙˆÛŒ "Ø§Ù†ØªØ®Ø§Ø¨ Ù¾ÙˆØ±Øª" Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ØªØ§ ÛŒÚ© Ø¯Ø³ØªÚ¯Ø§Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯',
                'connection.disconnected': 'Ø§ØªØµØ§Ù„ Ù‚Ø·Ø¹ Ø´Ø¯',
                'connection.reconnect.tip': 'Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯ØŒ Ø±ÙˆÛŒ "Ø§Ù†ØªØ®Ø§Ø¨ Ù¾ÙˆØ±Øª" Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯',
                'connection.selected': 'Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡',
                'connection.port.selected': 'Ù¾ÙˆØ±Øª Ø³Ø±ÛŒØ§Ù„ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯',
                'connection.connected': 'Ù…ØªØµÙ„',
                'autoreconnect.enabled': 'Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± ÙØ¹Ø§Ù„ Ø´Ø¯',
                'autoreconnect.disabled': 'Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯',
                'autoreconnect.timeout': 'Ù…Ù‡Ù„Øª Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯',
                'plotter.enabled': 'Ø±Ø³Ø§Ù… ÙØ¹Ø§Ù„ Ø´Ø¯',
                'plotter.disabled': 'Ø±Ø³Ø§Ù… ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯',
                'device.detected': 'Ø¯Ø³ØªÚ¯Ø§Ù‡ Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ Ø´Ø¯',
                'device.restored': 'Ø¯Ø³ØªÚ¯Ø§Ù‡ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø´Ø¯ØŒ ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯...',
                'device.disconnected': 'Ø¯Ø³ØªÚ¯Ø§Ù‡ Ù‚Ø·Ø¹ Ø´Ø¯',
                'device.waiting': 'Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø§ØªØµØ§Ù„ Ù…Ø¬Ø¯Ø¯ Ø¯Ø³ØªÚ¯Ø§Ù‡...',
                'device.reconnected': 'Ù…Ø¬Ø¯Ø¯Ø§Ù‹ Ù…ØªØµÙ„ Ø´Ø¯',
                'serial.port': 'Ù¾ÙˆØ±Øª Ø³Ø±ÛŒØ§Ù„',
                'error.general': 'Ø®Ø·Ø§',
                'error.no.port': 'Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ù¾ÙˆØ±Øª Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯',
                'error.connection': 'Ø®Ø·Ø§ÛŒ Ø§ØªØµØ§Ù„',
                'error.read': 'Ø®Ø·Ø§ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù†',
                'error.send': 'Ø®Ø·Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„',
                'chart.reparsed': 'Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆØ¯Ø§Ø± Ù…Ø¬Ø¯Ø¯Ø§Ù‹ ØªØ¬Ø²ÛŒÙ‡ Ø´Ø¯',
                'chart.default.group': 'Ù¾ÛŒØ´â€ŒÙØ±Ø¶',
                'chart.btn.pause': 'ØªÙˆÙ‚Ù',
                'chart.btn.resume': 'Ø§Ø¯Ø§Ù…Ù‡',
                'chart.btn.smooth': 'ØµØ§Ù',
                'chart.btn.clear': 'Ù¾Ø§Ú© Ú©Ù†',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡',
                'chart.btn.map': 'Ù†Ù‚Ø´Ù‡',
                'chart.btn.chart': 'Ù†Ù…ÙˆØ¯Ø§Ø±',
                'map.points': 'Ù†Ù‚Ø§Ø· Ù…Ø³ÛŒØ±',
                'map.follow': 'Ø¯Ù†Ø¨Ø§Ù„ Ú©Ø±Ø¯Ù†',
                'map.lock': 'Ù‚ÙÙ„',
                'chart.bgcolor.label': 'Ø±Ù†Ú¯ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡',
                'error.solution.title': 'Ø±Ø§Ù‡â€ŒØ­Ù„:',
                'plotter.cleared': 'ØªÙ…Ø§Ù… Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§ Ù¾Ø§Ú© Ø´Ø¯Ù†Ø¯',
            },

            'ru-RU': {
                // Header - Connection Panel
                'btn.selectPort': 'Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚',
                'btn.selectPort.tip': 'Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ñ€Ñ‚ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ',
                'baudRate.tip': 'Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‡Ğ¸ (bps)',
                'autoReconnect.label': 'ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ',
                'autoReconnect.tip': 'ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ğ°Ñ‚ÑŒÑÑ Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸',
                'btn.disconnect': 'ĞÑ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ',
                'btn.disconnect.tip': 'ĞÑ‚ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ Ğ¾Ñ‚ Ğ¿Ğ¾Ñ€Ñ‚Ğ°',
                'status.tip': 'Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ',
                'status.disconnected': 'ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾',
                'status.connecting': 'ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ...',
                'status.connected': 'ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾',
                'lang.switch.tip': 'Ğ¡Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑĞ·Ñ‹Ğº',
                'tab.terminal': 'Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»',
                'terminal.output.title': 'Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğ°',
                'terminal.mode.text.tip': 'Ğ¢ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼: ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°Ñ‚ÑŒ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼Ñ‹Ğ¹ Ñ‚ĞµĞºÑÑ‚',
                'terminal.mode.hex.tip': 'HEX Ñ€ĞµĞ¶Ğ¸Ğ¼: ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°Ñ‚ÑŒ ÑˆĞµÑÑ‚Ğ½Ğ°Ğ´Ñ†Ğ°Ñ‚ĞµÑ€Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ',
                'terminal.echo.tip': 'Ğ­Ñ…Ğ¾: ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ',
                'terminal.timestamp.tip': 'ĞœĞµÑ‚ĞºĞ° Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸: ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ',
                'terminal.autoscroll.tip': 'ĞĞ²Ñ‚Ğ¾Ğ¿Ñ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ° Ğº Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ĞµĞ¼Ñƒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ',
                'input.history.title': 'Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹',
                'input.history.empty': 'ĞĞµÑ‚ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ğ¸',
                'input.history.send.tip': 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ°Ğ¿Ñ€ÑĞ¼ÑƒÑ',
                'tab.plotter': 'ĞŸĞ»Ğ¾Ñ‚Ñ‚ĞµÑ€',
                'tab.close': 'Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ',
                'plotter.toggle.tip': 'Ğ’ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ/Ğ’Ñ‹ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ¸Ğµ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ¸',
                'terminal.mode.text': 'Ğ¢Ğ•ĞšĞ¡Ğ¢',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ Ñ‚ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ»Ğ°',
                
                // Terminal Colors
                'terminal.color.tx': 'Ğ’Ğ²Ğ¾Ğ´ (TX)',
                'terminal.color.tx.tip': 'Ğ¦Ğ²ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ²Ğ²Ğ¾Ğ´Ğ° (TX)',
                'terminal.color.rx': 'Ğ’Ñ‹Ğ²Ğ¾Ğ´ (RX)',
                'terminal.color.rx.tip': 'Ğ¦Ğ²ĞµÑ‚ Ñ‚ĞµĞºÑÑ‚Ğ° Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ° (RX)',
                'terminal.color.sys': 'Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¾Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ',
                'terminal.color.sys.tip': 'Ğ¦Ğ²ĞµÑ‚ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹',
                'terminal.color.reset': 'Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ',
                
                'plotter.clear.tip': 'ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ¸',
                'terminal.empty.title': 'Ğ¢ĞµÑ€Ğ¼Ğ¸Ğ½Ğ°Ğ» Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½',
                'terminal.empty.message': 'ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ¾Ğ²Ñ‹Ñ… Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...',
                'input.placeholder': 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter...',
                'input.send': 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ',
                'input.send.tip': 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ (Enter)',
                'input.history.tip': 'ĞŸĞ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ¸ÑÑ‚Ğ¾Ñ€Ğ¸Ñ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹',
                'input.lineending.tip': 'Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ» ĞºĞ¾Ğ½Ñ†Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸',
                'input.lineending.none': 'Ğ‘ĞµĞ· ĞºĞ¾Ğ½Ñ†Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸',
                'input.lineending.none.tip': 'Ğ‘ĞµĞ· ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ° ĞºĞ¾Ğ½Ñ†Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'ĞŸĞµÑ€ĞµĞ²Ğ¾Ğ´ ÑÑ‚Ñ€Ğ¾ĞºĞ¸',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ĞºĞ°Ñ€ĞµÑ‚ĞºĞ¸',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ½Ñ‹Ğµ Ğ±Ğ°Ğ¹Ñ‚Ñ‹',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ‹Ğµ Ğ±Ğ°Ğ¹Ñ‚Ñ‹',
                'stats.port.label': 'ĞŸĞ¾Ñ€Ñ‚:',
                'stats.port.tip': 'Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğµ',
                'stats.bytes': 'Ğ±Ğ°Ğ¹Ñ‚',
                'msg.copied': 'Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾',
                'color.picker.title': 'Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ñ†Ğ²ĞµÑ‚',
                'btn.cancel': 'ĞÑ‚Ğ¼ĞµĞ½Ğ°',
                'btn.confirm': 'ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ',
                'browser.warning.title': 'Ğ‘Ñ€Ğ°ÑƒĞ·ĞµÑ€ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Web Serial API',
                'manual.link': 'Ğ ÑƒĞºĞ¾Ğ²Ğ¾Ğ´ÑÑ‚Ğ²Ğ¾',
                'manual.tip': 'ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ñ€ÑƒĞºĞ¾Ğ²Ğ¾Ğ´ÑÑ‚Ğ²Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ',
                'changelog.tip': 'ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¶ÑƒÑ€Ğ½Ğ°Ğ» Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹',
                'connection.waiting.title': 'ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ',
                'connection.waiting.message': 'ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ "Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚" Ğ´Ğ»Ñ Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°',
                'connection.disconnected': 'Ğ¡Ğ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ€Ğ°Ğ·Ğ¾Ñ€Ğ²Ğ°Ğ½Ğ¾',
                'connection.reconnect.tip': 'Ğ”Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ "Ğ’Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¿Ğ¾Ñ€Ñ‚"',
                'connection.selected': 'Ğ’Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ¾',
                'connection.port.selected': 'ĞŸĞ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ñ€Ñ‚ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½',
                'connection.connected': 'ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾',
                'autoreconnect.enabled': 'ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾',
                'autoreconnect.disabled': 'ĞĞ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾',
                'autoreconnect.timeout': 'Ğ¢Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ',
                'plotter.enabled': 'ĞŸĞ»Ğ¾Ñ‚Ñ‚ĞµÑ€ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½',
                'plotter.disabled': 'ĞŸĞ»Ğ¾Ñ‚Ñ‚ĞµÑ€ Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½',
                'device.detected': 'Ğ£ÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ¾Ğ±Ğ½Ğ°Ñ€ÑƒĞ¶ĞµĞ½Ğ¾',
                'device.restored': 'Ğ£ÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾, Ğ¿Ğ¾Ğ¿Ñ‹Ñ‚ĞºĞ° Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ...',
                'device.disconnected': 'Ğ£ÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾',
                'device.waiting': 'ĞĞ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°...',
                'device.reconnected': 'ĞŸĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾',
                'serial.port': 'ĞŸĞ¾ÑĞ»ĞµĞ´Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ğ¿Ğ¾Ñ€Ñ‚',
                'error.general': 'ĞÑˆĞ¸Ğ±ĞºĞ°',
                'error.no.port': 'Ğ¡Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ° Ğ²Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¿Ğ¾Ñ€Ñ‚',
                'error.connection': 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ',
                'error.read': 'ĞÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ',
                'error.send': 'ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸',
                'chart.reparsed': 'Ğ”Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ° Ğ¿ĞµÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ñ‹',
                'chart.default.group': 'ĞŸĞ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ',
                'chart.btn.pause': 'ĞŸĞ°ÑƒĞ·Ğ°',
                'chart.btn.resume': 'ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ',
                'chart.btn.smooth': 'Ğ¡Ğ³Ğ»Ğ°Ğ¶Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ',
                'chart.btn.clear': 'ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Ğ¤Ğ¾Ğ½',
                'chart.btn.map': 'ĞšĞ°Ñ€Ñ‚Ğ°',
                'chart.btn.chart': 'Ğ“Ñ€Ğ°Ñ„Ğ¸Ğº',
                'map.points': 'Ğ¢Ğ¾Ñ‡ĞºĞ¸ Ñ‚Ñ€ĞµĞºĞ°',
                'map.follow': 'Ğ¡Ğ»ĞµĞ´Ğ¸Ñ‚ÑŒ',
                'map.lock': 'Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ°',
                'chart.bgcolor.label': 'Ğ¦Ğ²ĞµÑ‚ Ñ„Ğ¾Ğ½Ğ°',
                'error.solution.title': 'Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:',
                'plotter.cleared': 'Ğ’ÑĞµ Ğ³Ñ€Ğ°Ñ„Ğ¸ĞºĞ¸ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ñ‹',
            },

            'hi-IN': {
                // Header - Connection Panel
                'btn.selectPort': 'à¤ªà¥‹à¤°à¥à¤Ÿ à¤šà¥à¤¨à¥‡à¤‚',
                'btn.selectPort.tip': 'à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¥€à¤°à¤¿à¤¯à¤² à¤ªà¥‹à¤°à¥à¤Ÿ à¤šà¥à¤¨à¥‡à¤‚',
                'baudRate.tip': 'à¤¬à¥‰à¤¡ à¤°à¥‡à¤Ÿ à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚ (bps)',
                'autoReconnect.label': 'à¤‘à¤Ÿà¥‹ à¤°à¥€à¤•à¤¨à¥‡à¤•à¥à¤Ÿ',
                'autoReconnect.tip': 'à¤¡à¤¿à¤¸à¥à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤¹à¥‹à¤¨à¥‡ à¤ªà¤° à¤¸à¥à¤µà¤šà¤¾à¤²à¤¿à¤¤ à¤°à¥‚à¤ª à¤¸à¥‡ à¤ªà¥à¤¨à¤ƒ à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤•à¤°à¥‡à¤‚',
                'btn.disconnect': 'à¤¡à¤¿à¤¸à¥à¤•à¤¨à¥‡à¤•à¥à¤Ÿ',
                'btn.disconnect.tip': 'à¤ªà¥‹à¤°à¥à¤Ÿ à¤¸à¥‡ à¤¡à¤¿à¤¸à¥à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤•à¤°à¥‡à¤‚',
                'status.tip': 'à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤¸à¥à¤¥à¤¿à¤¤à¤¿',
                'status.disconnected': 'à¤¡à¤¿à¤¸à¥à¤•à¤¨à¥‡à¤•à¥à¤Ÿà¥‡à¤¡',
                'status.connecting': 'à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤¹à¥‹ à¤°à¤¹à¤¾ à¤¹à¥ˆ...',
                'status.connected': 'à¤•à¤¨à¥‡à¤•à¥à¤Ÿà¥‡à¤¡',
                'lang.switch.tip': 'à¤­à¤¾à¤·à¤¾ à¤¬à¤¦à¤²à¥‡à¤‚',
                'tab.terminal': 'à¤Ÿà¤°à¥à¤®à¤¿à¤¨à¤²',
                'terminal.output.title': 'à¤Ÿà¤°à¥à¤®à¤¿à¤¨à¤² à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ',
                'terminal.mode.text.tip': 'à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤®à¥‹à¤¡: à¤ªà¤ à¤¨à¥€à¤¯ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤¦à¤¿à¤–à¤¾à¤à¤‚',
                'terminal.mode.hex.tip': 'HEX à¤®à¥‹à¤¡: à¤¹à¥‡à¤•à¥à¤¸à¤¾à¤¡à¥‡à¤¸à¤¿à¤®à¤² à¤®à¤¾à¤¨ à¤¦à¤¿à¤–à¤¾à¤à¤‚',
                'terminal.echo.tip': 'à¤‡à¤•à¥‹: à¤­à¥‡à¤œà¥‡ à¤—à¤ à¤¸à¤‚à¤¦à¥‡à¤¶ à¤¦à¤¿à¤–à¤¾à¤à¤‚',
                'terminal.timestamp.tip': 'à¤Ÿà¤¾à¤‡à¤®à¤¸à¥à¤Ÿà¥ˆà¤®à¥à¤ª: à¤¸à¤‚à¤¦à¥‡à¤¶ à¤•à¤¾ à¤¸à¤®à¤¯ à¤¦à¤¿à¤–à¤¾à¤à¤‚',
                'terminal.autoscroll.tip': 'à¤¨à¤µà¥€à¤¨à¤¤à¤® à¤¸à¤‚à¤¦à¥‡à¤¶ à¤ªà¤° à¤‘à¤Ÿà¥‹-à¤¸à¥à¤•à¥à¤°à¥‰à¤² à¤•à¤°à¥‡à¤‚',
                'input.history.title': 'à¤¸à¤‚à¤¦à¥‡à¤¶ à¤‡à¤¤à¤¿à¤¹à¤¾à¤¸',
                'input.history.empty': 'à¤•à¥‹à¤ˆ à¤‡à¤¤à¤¿à¤¹à¤¾à¤¸ à¤¨à¤¹à¥€à¤‚',
                'input.history.send.tip': 'à¤¸à¥€à¤§à¥‡ à¤­à¥‡à¤œà¥‡à¤‚',
                'tab.plotter': 'à¤ªà¥à¤²à¥‰à¤Ÿà¤°',
                'tab.close': 'à¤¬à¤‚à¤¦ à¤•à¤°à¥‡à¤‚',
                'plotter.toggle.tip': 'à¤°à¤¿à¤¯à¤²-à¤Ÿà¤¾à¤‡à¤® à¤ªà¥à¤²à¥‰à¤Ÿà¤¿à¤‚à¤— à¤Ÿà¥‰à¤—à¤² à¤•à¤°à¥‡à¤‚',
                'terminal.mode.text': 'à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'à¤Ÿà¤°à¥à¤®à¤¿à¤¨à¤² à¤¸à¤¾à¤®à¤—à¥à¤°à¥€ à¤¸à¤¾à¤«à¤¼ à¤•à¤°à¥‡à¤‚',
                
                // Terminal Colors
                'terminal.color.tx': 'à¤‡à¤¨à¤ªà¥à¤Ÿ (TX)',
                'terminal.color.tx.tip': 'à¤‡à¤¨à¤ªà¥à¤Ÿ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤•à¤¾ à¤°à¤‚à¤— (TX)',
                'terminal.color.rx': 'à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ (RX)',
                'terminal.color.rx.tip': 'à¤†à¤‰à¤Ÿà¤ªà¥à¤Ÿ à¤Ÿà¥‡à¤•à¥à¤¸à¥à¤Ÿ à¤•à¤¾ à¤°à¤‚à¤— (RX)',
                'terminal.color.sys': 'à¤¸à¤¿à¤¸à¥à¤Ÿà¤® à¤¸à¤‚à¤¦à¥‡à¤¶',
                'terminal.color.sys.tip': 'à¤¸à¤¿à¤¸à¥à¤Ÿà¤® à¤¸à¤‚à¤¦à¥‡à¤¶ à¤•à¤¾ à¤°à¤‚à¤—',
                'terminal.color.reset': 'à¤¡à¤¿à¤«à¤¼à¥‰à¤²à¥à¤Ÿ à¤ªà¤° à¤°à¥€à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚',
                
                'plotter.clear.tip': 'à¤¸à¤­à¥€ à¤šà¤¾à¤°à¥à¤Ÿ à¤¸à¤¾à¤«à¤¼ à¤•à¤°à¥‡à¤‚',
                'terminal.empty.title': 'à¤Ÿà¤°à¥à¤®à¤¿à¤¨à¤² à¤¸à¤¾à¤«à¤¼ à¤¹à¥‹ à¤—à¤¯à¤¾',
                'terminal.empty.message': 'à¤¨à¤ à¤¡à¥‡à¤Ÿà¤¾ à¤•à¥€ à¤ªà¥à¤°à¤¤à¥€à¤•à¥à¤·à¤¾ à¤®à¥‡à¤‚...',
                'input.placeholder': 'à¤­à¥‡à¤œà¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤¸à¤‚à¤¦à¥‡à¤¶ à¤Ÿà¤¾à¤‡à¤ª à¤•à¤°à¥‡à¤‚, Enter à¤¦à¤¬à¤¾à¤à¤‚...',
                'input.send': 'à¤­à¥‡à¤œà¥‡à¤‚',
                'input.send.tip': 'à¤¸à¤‚à¤¦à¥‡à¤¶ à¤­à¥‡à¤œà¥‡à¤‚ (Enter)',
                'input.history.tip': 'à¤¸à¤‚à¤¦à¥‡à¤¶ à¤‡à¤¤à¤¿à¤¹à¤¾à¤¸ à¤¦à¤¿à¤–à¤¾à¤à¤‚',
                'input.lineending.tip': 'à¤²à¤¾à¤‡à¤¨ à¤à¤‚à¤¡à¤¿à¤‚à¤— à¤•à¥ˆà¤°à¥‡à¤•à¥à¤Ÿà¤° à¤¸à¥‡à¤Ÿ à¤•à¤°à¥‡à¤‚',
                'input.lineending.none': 'à¤•à¥‹à¤ˆ à¤²à¤¾à¤‡à¤¨ à¤à¤‚à¤¡à¤¿à¤‚à¤— à¤¨à¤¹à¥€à¤‚',
                'input.lineending.none.tip': 'à¤•à¥‹à¤ˆ à¤²à¤¾à¤‡à¤¨ à¤à¤‚à¤¡à¤¿à¤‚à¤— à¤•à¥ˆà¤°à¥‡à¤•à¥à¤Ÿà¤° à¤¨à¤¹à¥€à¤‚',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'à¤²à¤¾à¤‡à¤¨ à¤«à¥€à¤¡',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'à¤•à¥ˆà¤°à¤¿à¤œ à¤°à¤¿à¤Ÿà¤°à¥à¤¨',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'à¤ªà¥à¤°à¤¾à¤ªà¥à¤¤ à¤¬à¤¾à¤‡à¤Ÿà¥à¤¸',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'à¤­à¥‡à¤œà¥‡ à¤—à¤ à¤¬à¤¾à¤‡à¤Ÿà¥à¤¸',
                'stats.port.label': 'à¤ªà¥‹à¤°à¥à¤Ÿ:',
                'stats.port.tip': 'à¤¡à¤¿à¤µà¤¾à¤‡à¤¸ à¤œà¤¾à¤¨à¤•à¤¾à¤°à¥€',
                'stats.bytes': 'à¤¬à¤¾à¤‡à¤Ÿà¥à¤¸',
                'msg.copied': 'à¤•à¥‰à¤ªà¥€ à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾',
                'color.picker.title': 'à¤°à¤‚à¤— à¤šà¥à¤¨à¥‡à¤‚',
                'btn.cancel': 'à¤°à¤¦à¥à¤¦ à¤•à¤°à¥‡à¤‚',
                'btn.confirm': 'à¤ªà¥à¤·à¥à¤Ÿà¤¿ à¤•à¤°à¥‡à¤‚',
                'browser.warning.title': 'à¤¬à¥à¤°à¤¾à¤‰à¤œà¤¼à¤° Web Serial API à¤•à¤¾ à¤¸à¤®à¤°à¥à¤¥à¤¨ à¤¨à¤¹à¥€à¤‚ à¤•à¤°à¤¤à¤¾',
                'manual.link': 'à¤®à¥ˆà¤¨à¥à¤…à¤²',
                'manual.tip': 'à¤‰à¤ªà¤¯à¥‹à¤—à¤•à¤°à¥à¤¤à¤¾ à¤®à¥ˆà¤¨à¥à¤…à¤² à¤¦à¥‡à¤–à¥‡à¤‚',
                'changelog.tip': 'à¤ªà¤°à¤¿à¤µà¤°à¥à¤¤à¤¨ à¤²à¥‰à¤— à¤¦à¥‡à¤–à¥‡à¤‚',
                'connection.waiting.title': 'à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤•à¥€ à¤ªà¥à¤°à¤¤à¥€à¤•à¥à¤·à¤¾ à¤®à¥‡à¤‚',
                'connection.waiting.message': 'à¤¡à¤¿à¤µà¤¾à¤‡à¤¸ à¤šà¥à¤¨à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ "à¤ªà¥‹à¤°à¥à¤Ÿ à¤šà¥à¤¨à¥‡à¤‚" à¤ªà¤° à¤•à¥à¤²à¤¿à¤• à¤•à¤°à¥‡à¤‚',
                'connection.disconnected': 'à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤¡à¤¿à¤¸à¥à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤¹à¥‹ à¤—à¤¯à¤¾',
                'connection.reconnect.tip': 'à¤ªà¥à¤¨à¤ƒ à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤, "à¤ªà¥‹à¤°à¥à¤Ÿ à¤šà¥à¤¨à¥‡à¤‚" à¤ªà¤° à¤•à¥à¤²à¤¿à¤• à¤•à¤°à¥‡à¤‚',
                'connection.selected': 'à¤šà¤¯à¤¨à¤¿à¤¤',
                'connection.port.selected': 'à¤¸à¥€à¤°à¤¿à¤¯à¤² à¤ªà¥‹à¤°à¥à¤Ÿ à¤šà¤¯à¤¨à¤¿à¤¤',
                'connection.connected': 'à¤•à¤¨à¥‡à¤•à¥à¤Ÿà¥‡à¤¡',
                'autoreconnect.enabled': 'à¤‘à¤Ÿà¥‹-à¤°à¥€à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤¸à¤•à¥à¤·à¤®',
                'autoreconnect.disabled': 'à¤‘à¤Ÿà¥‹-à¤°à¥€à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤…à¤•à¥à¤·à¤®',
                'autoreconnect.timeout': 'à¤‘à¤Ÿà¥‹-à¤°à¥€à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤Ÿà¤¾à¤‡à¤®à¤†à¤‰à¤Ÿ',
                'plotter.enabled': 'à¤ªà¥à¤²à¥‰à¤Ÿà¤° à¤¸à¤•à¥à¤·à¤®',
                'plotter.disabled': 'à¤ªà¥à¤²à¥‰à¤Ÿà¤° à¤…à¤•à¥à¤·à¤®',
                'device.detected': 'à¤¡à¤¿à¤µà¤¾à¤‡à¤¸ à¤•à¤¾ à¤ªà¤¤à¤¾ à¤šà¤²à¤¾',
                'device.restored': 'à¤¡à¤¿à¤µà¤¾à¤‡à¤¸ à¤ªà¥à¤¨à¤°à¥à¤¸à¥à¤¥à¤¾à¤ªà¤¿à¤¤, à¤ªà¥à¤¨à¤ƒ à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤•à¤°à¤¨à¥‡ à¤•à¤¾ à¤ªà¥à¤°à¤¯à¤¾à¤¸...',
                'device.disconnected': 'à¤¡à¤¿à¤µà¤¾à¤‡à¤¸ à¤¡à¤¿à¤¸à¥à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤¹à¥‹ à¤—à¤¯à¤¾',
                'device.waiting': 'à¤¡à¤¿à¤µà¤¾à¤‡à¤¸ à¤ªà¥à¤¨à¤ƒ à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤¹à¥‹à¤¨à¥‡ à¤•à¥€ à¤ªà¥à¤°à¤¤à¥€à¤•à¥à¤·à¤¾ à¤®à¥‡à¤‚...',
                'device.reconnected': 'à¤ªà¥à¤¨à¤ƒ à¤•à¤¨à¥‡à¤•à¥à¤Ÿ à¤¹à¥‹ à¤—à¤¯à¤¾',
                'serial.port': 'à¤¸à¥€à¤°à¤¿à¤¯à¤² à¤ªà¥‹à¤°à¥à¤Ÿ',
                'error.general': 'à¤¤à¥à¤°à¥à¤Ÿà¤¿',
                'error.no.port': 'à¤•à¥ƒà¤ªà¤¯à¤¾ à¤ªà¤¹à¤²à¥‡ à¤à¤• à¤ªà¥‹à¤°à¥à¤Ÿ à¤šà¥à¤¨à¥‡à¤‚',
                'error.connection': 'à¤•à¤¨à¥‡à¤•à¥à¤¶à¤¨ à¤¤à¥à¤°à¥à¤Ÿà¤¿',
                'error.read': 'à¤ªà¤¢à¤¼à¤¨à¥‡ à¤®à¥‡à¤‚ à¤¤à¥à¤°à¥à¤Ÿà¤¿',
                'error.send': 'à¤­à¥‡à¤œà¤¨à¥‡ à¤®à¥‡à¤‚ à¤¤à¥à¤°à¥à¤Ÿà¤¿',
                'chart.reparsed': 'à¤šà¤¾à¤°à¥à¤Ÿ à¤¡à¥‡à¤Ÿà¤¾ à¤ªà¥à¤¨à¤ƒ à¤ªà¤¾à¤°à¥à¤¸ à¤•à¤¿à¤¯à¤¾ à¤—à¤¯à¤¾',
                'chart.default.group': 'à¤¡à¤¿à¤«à¤¼à¥‰à¤²à¥à¤Ÿ',
                'chart.btn.pause': 'à¤°à¥‹à¤•à¥‡à¤‚',
                'chart.btn.resume': 'à¤«à¤¿à¤° à¤¸à¥‡ à¤¶à¥à¤°à¥‚ à¤•à¤°à¥‡à¤‚',
                'chart.btn.smooth': 'à¤¸à¥à¤®à¥‚à¤¥',
                'chart.btn.clear': 'à¤¸à¤¾à¤«à¤¼ à¤•à¤°à¥‡à¤‚',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'à¤ªà¥ƒà¤·à¥à¤ à¤­à¥‚à¤®à¤¿',
                'chart.btn.map': 'à¤¨à¤•à¥à¤¶à¤¾',
                'chart.btn.chart': 'à¤šà¤¾à¤°à¥à¤Ÿ',
                'map.points': 'à¤Ÿà¥à¤°à¥ˆà¤• à¤ªà¥‰à¤‡à¤‚à¤Ÿà¥à¤¸',
                'map.follow': 'à¤…à¤¨à¥à¤¸à¤°à¤£',
                'map.lock': 'à¤²à¥‰à¤•',
                'chart.bgcolor.label': 'à¤ªà¥ƒà¤·à¥à¤ à¤­à¥‚à¤®à¤¿ à¤°à¤‚à¤—',
                'error.solution.title': 'à¤¸à¤®à¤¾à¤§à¤¾à¤¨:',
                'plotter.cleared': 'à¤¸à¤­à¥€ à¤šà¤¾à¤°à¥à¤Ÿ à¤¸à¤¾à¤«à¤¼ à¤¹à¥‹ à¤—à¤',
            },

            'vi-VN': {
                // Header - Connection Panel
                'btn.selectPort': 'Chá»n Cá»•ng',
                'btn.selectPort.tip': 'Chá»n má»™t cá»•ng ná»‘i tiáº¿p Ä‘á»ƒ káº¿t ná»‘i',
                'baudRate.tip': 'Äáº·t tá»‘c Ä‘á»™ baud (bps)',
                'autoReconnect.label': 'Tá»± Ä‘á»™ng káº¿t ná»‘i láº¡i',
                'autoReconnect.tip': 'Tá»± Ä‘á»™ng káº¿t ná»‘i láº¡i khi bá»‹ ngáº¯t',
                'btn.disconnect': 'Ngáº¯t káº¿t ná»‘i',
                'btn.disconnect.tip': 'Ngáº¯t káº¿t ná»‘i khá»i cá»•ng',
                'status.tip': 'Tráº¡ng thÃ¡i káº¿t ná»‘i',
                'status.disconnected': 'ÄÃ£ ngáº¯t',
                'status.connecting': 'Äang káº¿t ná»‘i...',
                'status.connected': 'ÄÃ£ káº¿t ná»‘i',
                'lang.switch.tip': 'Chuyá»ƒn Ä‘á»•i ngÃ´n ngá»¯',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'Äáº§u ra Terminal',
                'terminal.mode.text.tip': 'Cháº¿ Ä‘á»™ vÄƒn báº£n: Hiá»ƒn thá»‹ vÄƒn báº£n Ä‘á»c Ä‘Æ°á»£c',
                'terminal.mode.hex.tip': 'Cháº¿ Ä‘á»™ HEX: Hiá»ƒn thá»‹ giÃ¡ trá»‹ tháº­p lá»¥c phÃ¢n',
                'terminal.echo.tip': 'Echo: Hiá»ƒn thá»‹ tin nháº¯n Ä‘Ã£ gá»­i',
                'terminal.timestamp.tip': 'Dáº¥u thá»i gian: Hiá»ƒn thá»‹ thá»i gian tin nháº¯n',
                'terminal.autoscroll.tip': 'Tá»± Ä‘á»™ng cuá»™n Ä‘áº¿n tin nháº¯n má»›i nháº¥t',
                'input.history.title': 'Lá»‹ch sá»­ tin nháº¯n',
                'input.history.empty': 'KhÃ´ng cÃ³ lá»‹ch sá»­',
                'input.history.send.tip': 'Gá»­i trá»±c tiáº¿p',
                'tab.plotter': 'Äá»“ thá»‹',
                'tab.close': 'ÄÃ³ng',
                'plotter.toggle.tip': 'Báº­t/Táº¯t váº½ Ä‘á»“ thá»‹ thá»i gian thá»±c',
                'terminal.mode.text': 'VÄ‚N Báº¢N',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'XÃ³a ná»™i dung terminal',
                
                // Terminal Colors
                'terminal.color.tx': 'Äáº§u vÃ o (TX)',
                'terminal.color.tx.tip': 'MÃ u vÄƒn báº£n Ä‘áº§u vÃ o (TX)',
                'terminal.color.rx': 'Äáº§u ra (RX)',
                'terminal.color.rx.tip': 'MÃ u vÄƒn báº£n Ä‘áº§u ra (RX)',
                'terminal.color.sys': 'ThÃ´ng bÃ¡o há»‡ thá»‘ng',
                'terminal.color.sys.tip': 'MÃ u thÃ´ng bÃ¡o há»‡ thá»‘ng',
                'terminal.color.reset': 'Äáº·t láº¡i máº·c Ä‘á»‹nh',
                
                'plotter.clear.tip': 'XÃ³a táº¥t cáº£ biá»ƒu Ä‘á»“',
                'terminal.empty.title': 'Terminal Ä‘Ã£ xÃ³a',
                'terminal.empty.message': 'Äang chá» dá»¯ liá»‡u má»›i...',
                'input.placeholder': 'Nháº­p tin nháº¯n Ä‘á»ƒ gá»­i, nháº¥n Enter...',
                'input.send': 'Gá»­i',
                'input.send.tip': 'Gá»­i tin nháº¯n (Enter)',
                'input.history.tip': 'Hiá»ƒn thá»‹ lá»‹ch sá»­ tin nháº¯n',
                'input.lineending.tip': 'Äáº·t kÃ½ tá»± káº¿t thÃºc dÃ²ng',
                'input.lineending.none': 'KhÃ´ng cÃ³ káº¿t thÃºc dÃ²ng',
                'input.lineending.none.tip': 'KhÃ´ng cÃ³ kÃ½ tá»± káº¿t thÃºc dÃ²ng',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Line Feed',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Carriage Return',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Bytes Ä‘Ã£ nháº­n',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Bytes Ä‘Ã£ gá»­i',
                'stats.port.label': 'Cá»•ng:',
                'stats.port.tip': 'ThÃ´ng tin thiáº¿t bá»‹',
                'stats.bytes': 'bytes',
                'msg.copied': 'ÄÃ£ sao chÃ©p',
                'color.picker.title': 'Chá»n mÃ u',
                'btn.cancel': 'Há»§y',
                'btn.confirm': 'XÃ¡c nháº­n',
                'browser.warning.title': 'TrÃ¬nh duyá»‡t khÃ´ng há»— trá»£ Web Serial API',
                'manual.link': 'HÆ°á»›ng dáº«n',
                'manual.tip': 'Xem hÆ°á»›ng dáº«n sá»­ dá»¥ng',
                'changelog.tip': 'Xem nháº­t kÃ½ thay Ä‘á»•i',
                'connection.waiting.title': 'Äang chá» káº¿t ná»‘i',
                'connection.waiting.message': 'Nháº¥p "Chá»n Cá»•ng" Ä‘á»ƒ chá»n thiáº¿t bá»‹',
                'connection.disconnected': 'ÄÃ£ ngáº¯t káº¿t ná»‘i',
                'connection.reconnect.tip': 'Äá»ƒ káº¿t ná»‘i láº¡i, nháº¥p "Chá»n Cá»•ng"',
                'connection.selected': 'ÄÃ£ chá»n',
                'connection.port.selected': 'ÄÃ£ chá»n cá»•ng ná»‘i tiáº¿p',
                'connection.connected': 'ÄÃ£ káº¿t ná»‘i',
                'autoreconnect.enabled': 'ÄÃ£ báº­t tá»± Ä‘á»™ng káº¿t ná»‘i láº¡i',
                'autoreconnect.disabled': 'ÄÃ£ táº¯t tá»± Ä‘á»™ng káº¿t ná»‘i láº¡i',
                'autoreconnect.timeout': 'Háº¿t thá»i gian tá»± Ä‘á»™ng káº¿t ná»‘i láº¡i',
                'plotter.enabled': 'ÄÃ£ báº­t Ä‘á»“ thá»‹',
                'plotter.disabled': 'ÄÃ£ táº¯t Ä‘á»“ thá»‹',
                'device.detected': 'ÄÃ£ phÃ¡t hiá»‡n thiáº¿t bá»‹',
                'device.restored': 'Thiáº¿t bá»‹ Ä‘Ã£ khÃ´i phá»¥c, Ä‘ang thá»­ káº¿t ná»‘i láº¡i...',
                'device.disconnected': 'Thiáº¿t bá»‹ Ä‘Ã£ ngáº¯t káº¿t ná»‘i',
                'device.waiting': 'Äang chá» thiáº¿t bá»‹ káº¿t ná»‘i láº¡i...',
                'device.reconnected': 'ÄÃ£ káº¿t ná»‘i láº¡i',
                'serial.port': 'Cá»•ng ná»‘i tiáº¿p',
                'error.general': 'Lá»—i',
                'error.no.port': 'Vui lÃ²ng chá»n cá»•ng trÆ°á»›c',
                'error.connection': 'Lá»—i káº¿t ná»‘i',
                'error.read': 'Lá»—i Ä‘á»c',
                'error.send': 'Lá»—i gá»­i',
                'chart.reparsed': 'ÄÃ£ phÃ¢n tÃ­ch láº¡i dá»¯ liá»‡u biá»ƒu Ä‘á»“',
                'chart.default.group': 'Máº·c Ä‘á»‹nh',
                'chart.btn.pause': 'Táº¡m dá»«ng',
                'chart.btn.resume': 'Tiáº¿p tá»¥c',
                'chart.btn.smooth': 'LÃ m mÆ°á»£t',
                'chart.btn.clear': 'XÃ³a',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Ná»n',
                'chart.btn.map': 'Báº£n Ä‘á»“',
                'chart.btn.chart': 'Biá»ƒu Ä‘á»“',
                'map.points': 'Äiá»ƒm theo dÃµi',
                'map.follow': 'Theo dÃµi',
                'map.lock': 'KhÃ³a',
                'chart.bgcolor.label': 'MÃ u ná»n',
                'error.solution.title': 'Giáº£i phÃ¡p:',
                'plotter.cleared': 'ÄÃ£ xÃ³a táº¥t cáº£ biá»ƒu Ä‘á»“',
            },

            'th-TH': {
                // Header - Connection Panel
                'btn.selectPort': 'à¹€à¸¥à¸·à¸­à¸à¸à¸­à¸£à¹Œà¸•',
                'btn.selectPort.tip': 'à¹€à¸¥à¸·à¸­à¸à¸à¸­à¸£à¹Œà¸•à¸­à¸™à¸¸à¸à¸£à¸¡à¹€à¸à¸·à¹ˆà¸­à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'baudRate.tip': 'à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸­à¸±à¸•à¸£à¸²à¸šà¸­à¸” (bps)',
                'autoReconnect.label': 'à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´',
                'autoReconnect.tip': 'à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹ƒà¸«à¸¡à¹ˆà¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´à¹€à¸¡à¸·à¹ˆà¸­à¸–à¸¹à¸à¸•à¸±à¸”à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'btn.disconnect': 'à¸•à¸±à¸”à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'btn.disconnect.tip': 'à¸•à¸±à¸”à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸ˆà¸²à¸à¸à¸­à¸£à¹Œà¸•',
                'status.tip': 'à¸ªà¸–à¸²à¸™à¸°à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'status.disconnected': 'à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'status.connecting': 'à¸à¸³à¸¥à¸±à¸‡à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­...',
                'status.connected': 'à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹à¸¥à¹‰à¸§',
                'lang.switch.tip': 'à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ à¸²à¸©à¸²',
                'tab.terminal': 'à¹€à¸—à¸­à¸£à¹Œà¸¡à¸´à¸™à¸±à¸¥',
                'terminal.output.title': 'à¹€à¸­à¸²à¸•à¹Œà¸à¸¸à¸•à¹€à¸—à¸­à¸£à¹Œà¸¡à¸´à¸™à¸±à¸¥',
                'terminal.mode.text.tip': 'à¹‚à¸«à¸¡à¸”à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡: à¹à¸ªà¸”à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸—à¸µà¹ˆà¸­à¹ˆà¸²à¸™à¹„à¸”à¹‰',
                'terminal.mode.hex.tip': 'à¹‚à¸«à¸¡à¸” HEX: à¹à¸ªà¸”à¸‡à¸„à¹ˆà¸²à¸à¸²à¸™à¸ªà¸´à¸šà¸«à¸',
                'terminal.echo.tip': 'Echo: à¹à¸ªà¸”à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸—à¸µà¹ˆà¸ªà¹ˆà¸‡',
                'terminal.timestamp.tip': 'à¸à¸²à¸£à¸›à¸£à¸°à¸—à¸±à¸šà¹€à¸§à¸¥à¸²: à¹à¸ªà¸”à¸‡à¹€à¸§à¸¥à¸²à¸‚à¸­à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡',
                'terminal.autoscroll.tip': 'à¹€à¸¥à¸·à¹ˆà¸­à¸™à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´à¹„à¸›à¸¢à¸±à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸¥à¹ˆà¸²à¸ªà¸¸à¸”',
                'input.history.title': 'à¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡',
                'input.history.empty': 'à¹„à¸¡à¹ˆà¸¡à¸µà¸›à¸£à¸°à¸§à¸±à¸•à¸´',
                'input.history.send.tip': 'à¸ªà¹ˆà¸‡à¹‚à¸”à¸¢à¸•à¸£à¸‡',
                'tab.plotter': 'à¸à¸¥à¹‡à¸­à¸•à¹€à¸•à¸­à¸£à¹Œ',
                'tab.close': 'à¸›à¸´à¸”',
                'plotter.toggle.tip': 'à¹€à¸›à¸´à¸”/à¸›à¸´à¸”à¸à¸²à¸£à¸à¸¥à¹‡à¸­à¸•à¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¡à¹Œ',
                'terminal.mode.text': 'à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'à¸¥à¹‰à¸²à¸‡à¹€à¸™à¸·à¹‰à¸­à¸«à¸²à¹€à¸—à¸­à¸£à¹Œà¸¡à¸´à¸™à¸±à¸¥',
                
                // Terminal Colors
                'terminal.color.tx': 'à¸­à¸´à¸™à¸à¸¸à¸• (TX)',
                'terminal.color.tx.tip': 'à¸ªà¸µà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸­à¸´à¸™à¸à¸¸à¸• (TX)',
                'terminal.color.rx': 'à¹€à¸­à¸²à¸•à¹Œà¸à¸¸à¸• (RX)',
                'terminal.color.rx.tip': 'à¸ªà¸µà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹€à¸­à¸²à¸•à¹Œà¸à¸¸à¸• (RX)',
                'terminal.color.sys': 'à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸£à¸°à¸šà¸š',
                'terminal.color.sys.tip': 'à¸ªà¸µà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸£à¸°à¸šà¸š',
                'terminal.color.reset': 'à¸£à¸µà¹€à¸‹à¹‡à¸•à¹€à¸›à¹‡à¸™à¸„à¹ˆà¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™',
                
                'plotter.clear.tip': 'à¸¥à¹‰à¸²à¸‡à¸à¸£à¸²à¸Ÿà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”',
                'terminal.empty.title': 'à¸¥à¹‰à¸²à¸‡à¹€à¸—à¸­à¸£à¹Œà¸¡à¸´à¸™à¸±à¸¥à¹à¸¥à¹‰à¸§',
                'terminal.empty.message': 'à¸£à¸­à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸«à¸¡à¹ˆ...',
                'input.placeholder': 'à¸à¸´à¸¡à¸à¹Œà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹€à¸à¸·à¹ˆà¸­à¸ªà¹ˆà¸‡, à¸à¸” Enter...',
                'input.send': 'à¸ªà¹ˆà¸‡',
                'input.send.tip': 'à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡ (Enter)',
                'input.history.tip': 'à¹à¸ªà¸”à¸‡à¸›à¸£à¸°à¸§à¸±à¸•à¸´à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡',
                'input.lineending.tip': 'à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸­à¸±à¸à¸‚à¸£à¸°à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”à¸šà¸£à¸£à¸—à¸±à¸”',
                'input.lineending.none': 'à¹„à¸¡à¹ˆà¸¡à¸µà¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”à¸šà¸£à¸£à¸—à¸±à¸”',
                'input.lineending.none.tip': 'à¹„à¸¡à¹ˆà¸¡à¸µà¸­à¸±à¸à¸‚à¸£à¸°à¸ªà¸´à¹‰à¸™à¸ªà¸¸à¸”à¸šà¸£à¸£à¸—à¸±à¸”',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Line Feed',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Carriage Return',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'à¹„à¸šà¸•à¹Œà¸—à¸µà¹ˆà¹„à¸”à¹‰à¸£à¸±à¸š',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'à¹„à¸šà¸•à¹Œà¸—à¸µà¹ˆà¸ªà¹ˆà¸‡',
                'stats.port.label': 'à¸à¸­à¸£à¹Œà¸•:',
                'stats.port.tip': 'à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸­à¸¸à¸›à¸à¸£à¸“à¹Œ',
                'stats.bytes': 'à¹„à¸šà¸•à¹Œ',
                'msg.copied': 'à¸„à¸±à¸”à¸¥à¸­à¸à¹à¸¥à¹‰à¸§',
                'color.picker.title': 'à¹€à¸¥à¸·à¸­à¸à¸ªà¸µ',
                'btn.cancel': 'à¸¢à¸à¹€à¸¥à¸´à¸',
                'btn.confirm': 'à¸¢à¸·à¸™à¸¢à¸±à¸™',
                'browser.warning.title': 'à¹€à¸šà¸£à¸²à¸§à¹Œà¹€à¸‹à¸­à¸£à¹Œà¹„à¸¡à¹ˆà¸£à¸­à¸‡à¸£à¸±à¸š Web Serial API',
                'manual.link': 'à¸„à¸¹à¹ˆà¸¡à¸·à¸­',
                'manual.tip': 'à¸”à¸¹à¸„à¸¹à¹ˆà¸¡à¸·à¸­à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™',
                'changelog.tip': 'à¸”à¸¹à¸šà¸±à¸™à¸—à¸¶à¸à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡',
                'connection.waiting.title': 'à¸£à¸­à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'connection.waiting.message': 'à¸„à¸¥à¸´à¸ "à¹€à¸¥à¸·à¸­à¸à¸à¸­à¸£à¹Œà¸•" à¹€à¸à¸·à¹ˆà¸­à¹€à¸¥à¸·à¸­à¸à¸­à¸¸à¸›à¸à¸£à¸“à¹Œ',
                'connection.disconnected': 'à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸–à¸¹à¸à¸•à¸±à¸”',
                'connection.reconnect.tip': 'à¹€à¸à¸·à¹ˆà¸­à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹ƒà¸«à¸¡à¹ˆ, à¸„à¸¥à¸´à¸ "à¹€à¸¥à¸·à¸­à¸à¸à¸­à¸£à¹Œà¸•"',
                'connection.selected': 'à¹€à¸¥à¸·à¸­à¸à¹à¸¥à¹‰à¸§',
                'connection.port.selected': 'à¹€à¸¥à¸·à¸­à¸à¸à¸­à¸£à¹Œà¸•à¸­à¸™à¸¸à¸à¸£à¸¡à¹à¸¥à¹‰à¸§',
                'connection.connected': 'à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹à¸¥à¹‰à¸§',
                'autoreconnect.enabled': 'à¹€à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´',
                'autoreconnect.disabled': 'à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´',
                'autoreconnect.timeout': 'à¸«à¸¡à¸”à¹€à¸§à¸¥à¸²à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´',
                'plotter.enabled': 'à¹€à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸à¸¥à¹‡à¸­à¸•à¹€à¸•à¸­à¸£à¹Œ',
                'plotter.disabled': 'à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸à¸¥à¹‡à¸­à¸•à¹€à¸•à¸­à¸£à¹Œ',
                'device.detected': 'à¸•à¸£à¸§à¸ˆà¸à¸šà¸­à¸¸à¸›à¸à¸£à¸“à¹Œ',
                'device.restored': 'à¸­à¸¸à¸›à¸à¸£à¸“à¹Œà¸–à¸¹à¸à¸à¸¹à¹‰à¸„à¸·à¸™, à¸à¸³à¸¥à¸±à¸‡à¸à¸¢à¸²à¸¢à¸²à¸¡à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹ƒà¸«à¸¡à¹ˆ...',
                'device.disconnected': 'à¸­à¸¸à¸›à¸à¸£à¸“à¹Œà¸–à¸¹à¸à¸•à¸±à¸”à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'device.waiting': 'à¸£à¸­à¸­à¸¸à¸›à¸à¸£à¸“à¹Œà¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹ƒà¸«à¸¡à¹ˆ...',
                'device.reconnected': 'à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¹ƒà¸«à¸¡à¹ˆà¹à¸¥à¹‰à¸§',
                'serial.port': 'à¸à¸­à¸£à¹Œà¸•à¸­à¸™à¸¸à¸à¸£à¸¡',
                'error.general': 'à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”',
                'error.no.port': 'à¸à¸£à¸¸à¸“à¸²à¹€à¸¥à¸·à¸­à¸à¸à¸­à¸£à¹Œà¸•à¸à¹ˆà¸­à¸™',
                'error.connection': 'à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­',
                'error.read': 'à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸­à¹ˆà¸²à¸™',
                'error.send': 'à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸ªà¹ˆà¸‡',
                'chart.reparsed': 'à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸à¸£à¸²à¸Ÿà¹ƒà¸«à¸¡à¹ˆà¹à¸¥à¹‰à¸§',
                'chart.default.group': 'à¸„à¹ˆà¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™',
                'chart.btn.pause': 'à¸«à¸¢à¸¸à¸”à¸Šà¸±à¹ˆà¸§à¸„à¸£à¸²à¸§',
                'chart.btn.resume': 'à¸”à¸³à¹€à¸™à¸´à¸™à¸à¸²à¸£à¸•à¹ˆà¸­',
                'chart.btn.smooth': 'à¹€à¸£à¸µà¸¢à¸š',
                'chart.btn.clear': 'à¸¥à¹‰à¸²à¸‡',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'à¸à¸·à¹‰à¸™à¸«à¸¥à¸±à¸‡',
                'chart.btn.map': 'à¹à¸œà¸™à¸—à¸µà¹ˆ',
                'chart.btn.chart': 'à¹à¸œà¸™à¸ à¸¹à¸¡à¸´',
                'map.points': 'à¸ˆà¸¸à¸”à¸•à¸´à¸”à¸•à¸²à¸¡',
                'map.follow': 'à¸•à¸´à¸”à¸•à¸²à¸¡',
                'map.lock': 'à¸¥à¹‡à¸­à¸„',
                'chart.bgcolor.label': 'à¸ªà¸µà¸à¸·à¹‰à¸™à¸«à¸¥à¸±à¸‡',
                'error.solution.title': 'à¸§à¸´à¸˜à¸µà¹à¸à¹‰:',
                'plotter.cleared': 'à¸¥à¹‰à¸²à¸‡à¸à¸£à¸²à¸Ÿà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹à¸¥à¹‰à¸§',
            },

            'ms-MY': {
                // Header - Connection Panel
                'btn.selectPort': 'Pilih Port',
                'btn.selectPort.tip': 'Pilih port bersiri untuk disambung',
                'baudRate.tip': 'Tetapkan kadar baud (bps)',
                'autoReconnect.label': 'Sambung Semula Auto',
                'autoReconnect.tip': 'Sambung semula secara automatik apabila terputus',
                'btn.disconnect': 'Putuskan',
                'btn.disconnect.tip': 'Putuskan sambungan dari port',
                'status.tip': 'Status sambungan',
                'status.disconnected': 'Terputus',
                'status.connecting': 'Menyambung...',
                'status.connected': 'Disambung',
                'lang.switch.tip': 'Tukar bahasa',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'Output Terminal',
                'terminal.mode.text.tip': 'Mod teks: Paparkan teks yang boleh dibaca',
                'terminal.mode.hex.tip': 'Mod HEX: Paparkan nilai heksadesimal',
                'terminal.echo.tip': 'Echo: Paparkan mesej yang dihantar',
                'terminal.timestamp.tip': 'Cap masa: Paparkan masa mesej',
                'terminal.autoscroll.tip': 'Auto-tatal ke mesej terkini',
                'input.history.title': 'Sejarah Mesej',
                'input.history.empty': 'Tiada sejarah',
                'input.history.send.tip': 'Hantar terus',
                'tab.plotter': 'Plotter',
                'tab.close': 'Tutup',
                'plotter.toggle.tip': 'Togol plotting masa nyata',
                'terminal.mode.text': 'TEKS',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Kosongkan kandungan terminal',
                
                // Terminal Colors
                'terminal.color.tx': 'Input (TX)',
                'terminal.color.tx.tip': 'Warna teks input (TX)',
                'terminal.color.rx': 'Output (RX)',
                'terminal.color.rx.tip': 'Warna teks output (RX)',
                'terminal.color.sys': 'Mesej Sistem',
                'terminal.color.sys.tip': 'Warna mesej sistem',
                'terminal.color.reset': 'Set semula ke lalai',
                
                'plotter.clear.tip': 'Kosongkan semua carta',
                'terminal.empty.title': 'Terminal Dikosongkan',
                'terminal.empty.message': 'Menunggu data baru...',
                'input.placeholder': 'Taip mesej untuk dihantar, tekan Enter...',
                'input.send': 'Hantar',
                'input.send.tip': 'Hantar mesej (Enter)',
                'input.history.tip': 'Paparkan sejarah mesej',
                'input.lineending.tip': 'Tetapkan aksara akhir baris',
                'input.lineending.none': 'Tiada akhir baris',
                'input.lineending.none.tip': 'Tiada aksara akhir baris',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Line Feed',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Carriage Return',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Bait diterima',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Bait dihantar',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'Maklumat peranti',
                'stats.bytes': 'bait',
                'msg.copied': 'Disalin',
                'color.picker.title': 'Pilih warna',
                'btn.cancel': 'Batal',
                'btn.confirm': 'Sahkan',
                'browser.warning.title': 'Pelayar tidak menyokong Web Serial API',
                'manual.link': 'Manual',
                'manual.tip': 'Lihat manual pengguna',
                'changelog.tip': 'Lihat log perubahan',
                'connection.waiting.title': 'Menunggu sambungan',
                'connection.waiting.message': 'Klik "Pilih Port" untuk memilih peranti',
                'connection.disconnected': 'Sambungan terputus',
                'connection.reconnect.tip': 'Untuk menyambung semula, klik "Pilih Port"',
                'connection.selected': 'Dipilih',
                'connection.port.selected': 'Port bersiri dipilih',
                'connection.connected': 'Disambung',
                'autoreconnect.enabled': 'Sambung semula auto diaktifkan',
                'autoreconnect.disabled': 'Sambung semula auto dinyahaktifkan',
                'autoreconnect.timeout': 'Tamat masa sambung semula auto',
                'plotter.enabled': 'Plotter diaktifkan',
                'plotter.disabled': 'Plotter dinyahaktifkan',
                'device.detected': 'Peranti dikesan',
                'device.restored': 'Peranti dipulihkan, cuba menyambung semula...',
                'device.disconnected': 'Peranti terputus',
                'device.waiting': 'Menunggu peranti menyambung semula...',
                'device.reconnected': 'Disambung semula',
                'serial.port': 'Port Bersiri',
                'error.general': 'Ralat',
                'error.no.port': 'Sila pilih port dahulu',
                'error.connection': 'Ralat sambungan',
                'error.read': 'Ralat baca',
                'error.send': 'Ralat hantar',
                'chart.reparsed': 'Data carta dianalisis semula',
                'chart.default.group': 'Lalai',
                'chart.btn.pause': 'Jeda',
                'chart.btn.resume': 'Sambung',
                'chart.btn.smooth': 'Licin',
                'chart.btn.clear': 'Kosongkan',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Latar Belakang',
                'chart.btn.map': 'Peta',
                'chart.btn.chart': 'Carta',
                'map.points': 'Titik jejak',
                'map.follow': 'Ikut',
                'map.lock': 'Kunci',
                'chart.bgcolor.label': 'Warna latar belakang',
                'error.solution.title': 'Penyelesaian:',
                'plotter.cleared': 'Semua carta dikosongkan',
            },

            'id-ID': {
                // Header - Connection Panel
                'btn.selectPort': 'Pilih Port',
                'btn.selectPort.tip': 'Pilih port serial untuk koneksi',
                'baudRate.tip': 'Atur baud rate (bps)',
                'autoReconnect.label': 'Koneksi Ulang Otomatis',
                'autoReconnect.tip': 'Otomatis terhubung kembali saat terputus',
                'btn.disconnect': 'Putuskan',
                'btn.disconnect.tip': 'Putuskan koneksi dari port',
                'status.tip': 'Status koneksi',
                'status.disconnected': 'Terputus',
                'status.connecting': 'Menghubungkan...',
                'status.connected': 'Terhubung',
                'lang.switch.tip': 'Ganti bahasa',
                'tab.terminal': 'Terminal',
                'terminal.output.title': 'Output Terminal',
                'terminal.mode.text.tip': 'Mode teks: Tampilkan teks yang dapat dibaca',
                'terminal.mode.hex.tip': 'Mode HEX: Tampilkan nilai heksadesimal',
                'terminal.echo.tip': 'Echo: Tampilkan pesan yang dikirim',
                'terminal.timestamp.tip': 'Timestamp: Tampilkan waktu pesan',
                'terminal.autoscroll.tip': 'Gulir otomatis ke pesan terbaru',
                'input.history.title': 'Riwayat Pesan',
                'input.history.empty': 'Tidak ada riwayat',
                'input.history.send.tip': 'Kirim langsung',
                'tab.plotter': 'Plotter',
                'tab.close': 'Tutup',
                'plotter.toggle.tip': 'Aktifkan/Nonaktifkan plotting real-time',
                'terminal.mode.text': 'TEKS',
                'terminal.mode.hex': 'HEX',
                'terminal.clear.tip': 'Bersihkan konten terminal',
                
                // Terminal Colors
                'terminal.color.tx': 'Input (TX)',
                'terminal.color.tx.tip': 'Warna teks input (TX)',
                'terminal.color.rx': 'Output (RX)',
                'terminal.color.rx.tip': 'Warna teks output (RX)',
                'terminal.color.sys': 'Pesan Sistem',
                'terminal.color.sys.tip': 'Warna pesan sistem',
                'terminal.color.reset': 'Atur ulang ke default',
                
                'plotter.clear.tip': 'Bersihkan semua grafik',
                'terminal.empty.title': 'Terminal Dibersihkan',
                'terminal.empty.message': 'Menunggu data baru...',
                'input.placeholder': 'Ketik pesan untuk dikirim, tekan Enter...',
                'input.send': 'Kirim',
                'input.send.tip': 'Kirim pesan (Enter)',
                'input.history.tip': 'Tampilkan riwayat pesan',
                'input.lineending.tip': 'Atur karakter akhir baris',
                'input.lineending.none': 'Tanpa akhir baris',
                'input.lineending.none.tip': 'Tanpa karakter akhir baris',
                'input.lineending.lf': 'LF',
                'input.lineending.lf.tip': 'Line Feed',
                'input.lineending.cr': 'CR',
                'input.lineending.cr.tip': 'Carriage Return',
                'input.lineending.crlf': 'CRLF',
                'input.lineending.crlf.tip': 'CR + LF (Windows)',
                'stats.rx.label': 'RX:',
                'stats.rx.tip': 'Byte diterima',
                'stats.tx.label': 'TX:',
                'stats.tx.tip': 'Byte dikirim',
                'stats.port.label': 'Port:',
                'stats.port.tip': 'Info perangkat',
                'stats.bytes': 'byte',
                'msg.copied': 'Disalin',
                'color.picker.title': 'Pilih warna',
                'btn.cancel': 'Batal',
                'btn.confirm': 'Konfirmasi',
                'browser.warning.title': 'Browser tidak mendukung Web Serial API',
                'manual.link': 'Manual',
                'manual.tip': 'Lihat manual pengguna',
                'changelog.tip': 'Lihat log perubahan',
                'connection.waiting.title': 'Menunggu koneksi',
                'connection.waiting.message': 'Klik "Pilih Port" untuk memilih perangkat',
                'connection.disconnected': 'Koneksi terputus',
                'connection.reconnect.tip': 'Untuk menghubungkan kembali, klik "Pilih Port"',
                'connection.selected': 'Dipilih',
                'connection.port.selected': 'Port serial dipilih',
                'connection.connected': 'Terhubung',
                'autoreconnect.enabled': 'Koneksi ulang otomatis diaktifkan',
                'autoreconnect.disabled': 'Koneksi ulang otomatis dinonaktifkan',
                'autoreconnect.timeout': 'Waktu koneksi ulang habis',
                'plotter.enabled': 'Plotter diaktifkan',
                'plotter.disabled': 'Plotter dinonaktifkan',
                'device.detected': 'Perangkat terdeteksi',
                'device.restored': 'Perangkat dipulihkan, mencoba menghubungkan kembali...',
                'device.disconnected': 'Perangkat terputus',
                'device.waiting': 'Menunggu perangkat terhubung kembali...',
                'device.reconnected': 'Terhubung kembali',
                'serial.port': 'Port Serial',
                'error.general': 'Error',
                'error.no.port': 'Silakan pilih port terlebih dahulu',
                'error.connection': 'Error koneksi',
                'error.read': 'Error baca',
                'error.send': 'Error kirim',
                'chart.reparsed': 'Data grafik dianalisis ulang',
                'chart.default.group': 'Default',
                'chart.btn.pause': 'Jeda',
                'chart.btn.resume': 'Lanjutkan',
                'chart.btn.smooth': 'Halus',
                'chart.btn.clear': 'Bersihkan',
                'chart.btn.export': 'CSV',
                'chart.btn.bgcolor': 'Latar Belakang',
                'chart.btn.map': 'Peta',
                'chart.btn.chart': 'Grafik',
                'chart.bgcolor.label': 'Warna latar belakang',
                'map.points': 'Titik jejak',
                'map.follow': 'Ikuti',
                'map.lock': 'Kunci',
                'error.solution.title': 'Solusi:',
                'plotter.cleared': 'Semua grafik dibersihkan',
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  Language Manager (ç°¡åŒ–ç‰ˆ)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        class LanguageManager {
            constructor() {
                this.currentLang = this.loadLanguage();
                this.translations = window.i18nStrings;
                // å»¶é²åˆå§‹åŒ–ï¼Œç¢ºä¿ DOM å·²è¼‰å…¥
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        this.initLanguageSelector();
                        this.updateUI();
                    });
                } else {
                    this.initLanguageSelector();
                    this.updateUI();
                }
            }

            loadLanguage() {
                const saved = localStorage.getItem('numonitor-language');
                if (saved && window.i18nStrings[saved]) {
                    return saved;
                }
                const browserLang = navigator.language || navigator.userLanguage;
                if (browserLang.startsWith('zh')) return 'zh-TW';
                if (browserLang.startsWith('ja')) return 'ja-JP';
                if (browserLang.startsWith('fr')) return 'fr-FR';
                if (browserLang.startsWith('de')) return 'de-DE';
                if (browserLang.startsWith('it')) return 'it-IT';
                if (browserLang.startsWith('es')) return 'es-ES';
                if (browserLang.startsWith('pt')) return 'pt-PT';
                if (browserLang.startsWith('tr')) return 'tr-TR';
                if (browserLang.startsWith('ar')) return 'ar-SA';
                if (browserLang.startsWith('he')) return 'he-IL';
                if (browserLang.startsWith('fa')) return 'fa-IR';
                if (browserLang.startsWith('ru')) return 'ru-RU';
                if (browserLang.startsWith('hi')) return 'hi-IN';
                if (browserLang.startsWith('vi')) return 'vi-VN';
                if (browserLang.startsWith('th')) return 'th-TH';
                if (browserLang.startsWith('ms')) return 'ms-MY';
                if (browserLang.startsWith('id')) return 'id-ID';
                if (browserLang.startsWith('en')) return 'en-US';
                return 'en-US';
            }

            saveLanguage(lang) {
                localStorage.setItem('numonitor-language', lang);
            }

            t(key) {
                return this.translations[this.currentLang]?.[key] || key;
            }

            setLanguage(lang) {
                if (!this.translations[lang]) return;
                this.currentLang = lang;
                this.saveLanguage(lang);
                this.updateUI();
                this.updateLanguageSelector();
            }

            initLanguageSelector() {
                const selector = document.getElementById('languageSelector');
                const trigger = document.getElementById('languageTrigger');
                const dropdown = document.getElementById('languageDropdown');
                
                if (!selector || !trigger || !dropdown) {
                    console.warn('Language selector elements not found, retrying...');
                    setTimeout(() => this.initLanguageSelector(), 100);
                    return;
                }
                
                const options = dropdown.querySelectorAll('.language-option');
                
                if (options.length === 0) {
                    console.warn('Language options not found, retrying...');
                    setTimeout(() => this.initLanguageSelector(), 100);
                    return;
                }

                // Toggle dropdown
                trigger.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isOpen = selector.classList.contains('open');
                    selector.classList.toggle('open');
                    console.log('Language selector', isOpen ? 'closed' : 'opened');
                });

                // Select language
                options.forEach(option => {
                    option.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const lang = option.dataset.lang;
                        console.log('Selected language:', lang);
                        this.setLanguage(lang);
                        selector.classList.remove('open');
                    });
                });

                // Close on outside click
                document.addEventListener('click', () => {
                    selector.classList.remove('open');
                });

                // Initial update
                this.updateLanguageSelector();
                console.log('Language selector initialized');
            }

            updateLanguageSelector() {
                const langConfig = {
                    'zh-TW': { flag: 'https://flagcdn.com/w20/tw.png', text: 'ç¹é«”ä¸­æ–‡', alt: 'TW' },
                    'en-US': { flag: 'https://flagcdn.com/w20/us.png', text: 'English', alt: 'US' },
                    'ja-JP': { flag: 'https://flagcdn.com/w20/jp.png', text: 'æ—¥æœ¬èª', alt: 'JP' },
                    'fr-FR': { flag: 'https://flagcdn.com/w20/fr.png', text: 'FranÃ§ais', alt: 'FR' },
                    'de-DE': { flag: 'https://flagcdn.com/w20/de.png', text: 'Deutsch', alt: 'DE' },
                    'it-IT': { flag: 'https://flagcdn.com/w20/it.png', text: 'Italiano', alt: 'IT' },
                    'es-ES': { flag: 'https://flagcdn.com/w20/es.png', text: 'EspaÃ±ol', alt: 'ES' },
                    'pt-PT': { flag: 'https://flagcdn.com/w20/pt.png', text: 'PortuguÃªs', alt: 'PT' },
                    'tr-TR': { flag: 'https://flagcdn.com/w20/tr.png', text: 'TÃ¼rkÃ§e', alt: 'TR' },
                    'ar-SA': { flag: 'https://flagcdn.com/w20/sa.png', text: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', alt: 'SA' },
                    'he-IL': { flag: 'https://flagcdn.com/w20/il.png', text: '×¢×‘×¨×™×ª', alt: 'IL' },
                    'fa-IR': { flag: 'https://flagcdn.com/w20/ir.png', text: 'ÙØ§Ø±Ø³ÛŒ', alt: 'IR' },
                    'ru-RU': { flag: 'https://flagcdn.com/w20/ru.png', text: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹', alt: 'RU' },
                    'hi-IN': { flag: 'https://flagcdn.com/w20/in.png', text: 'à¤¹à¤¿à¤¨à¥à¤¦à¥€', alt: 'IN' },
                    'vi-VN': { flag: 'https://flagcdn.com/w20/vn.png', text: 'Tiáº¿ng Viá»‡t', alt: 'VN' },
                    'th-TH': { flag: 'https://flagcdn.com/w20/th.png', text: 'à¸ à¸²à¸©à¸²à¹„à¸—à¸¢', alt: 'TH' },
                    'ms-MY': { flag: 'https://flagcdn.com/w20/my.png', text: 'Bahasa Melayu', alt: 'MY' },
                    'id-ID': { flag: 'https://flagcdn.com/w20/id.png', text: 'Bahasa Indonesia', alt: 'ID' }
                };

                const config = langConfig[this.currentLang];
                const flagImg = document.getElementById('currentLanguageFlag');
                const textEl = document.getElementById('currentLanguageText');
                
                if (flagImg && config) {
                    flagImg.src = config.flag;
                    flagImg.alt = config.alt;
                }
                
                if (textEl && config) {
                    textEl.textContent = config.text;
                }

                // Update active state
                const options = document.querySelectorAll('.language-option');
                options.forEach(opt => {
                    if (opt.dataset.lang === this.currentLang) {
                        opt.classList.add('active');
                    } else {
                        opt.classList.remove('active');
                    }
                });
            }

            updateUI() {
                // Update all data-i18n elements (text content)
                document.querySelectorAll('[data-i18n]').forEach(el => {
                    const key = el.dataset.i18n;
                    const text = this.t(key);
                    if (text !== key) {
                        el.textContent = text;
                    }
                });
                
                // Update all data-i18n-tip elements (tooltips)
                document.querySelectorAll('[data-i18n-tip]').forEach(el => {
                    const key = el.dataset.i18nTip;
                    const text = this.t(key);
                    if (text !== key) {
                        el.setAttribute('data-tip', text);
                    }
                });
                
                // Update all data-i18n-placeholder elements
                document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                    const key = el.dataset.i18nPlaceholder;
                    const text = this.t(key);
                    if (text !== key) {
                        el.setAttribute('placeholder', text);
                    }
                });
                
                // Update select options with data-i18n spans
                document.querySelectorAll('option span[data-i18n]').forEach(span => {
                    const key = span.dataset.i18n;
                    const text = this.t(key);
                    if (text !== key) {
                        span.textContent = text;
                    }
                });

                document.documentElement.lang = this.currentLang;
            }
        }

        // Initialize Language Manager
        window.languageManager = new LanguageManager();

    </script>
</body>
</html>
